% !TEX root = MAIN.tex

\chapter{Configuration of the toolset}

\section{Probe insertion}

In the \case the mutation probes were inserted into one of the functions that handles Remote Commands over PDO (Process Data Object), i.e., \emph{PdhuPdoService::IndicationReceived}. The function is implemented in the file \emph{PdhuPdoService.cpp}.
The OBSW initiates a remote access by sending a command (Cmd) and the PDHU processes the command and send back its answer (Ans).

\emph{PdhuPdoService::IndicationReceived} mainly consists of a switch command that generates a response to different commands.

The layouts of the commands and answers are are composed of a signal ID that must match between command and answer and a payload with size depending on the ID.

The vector that represents the input command is called \emph{data} and the answer is tored in a new one called \emph{newData} which contains elements of type UInt8.


A \emph{Mutation Probe} has been inserted to mutate the data contained in the \emph{newData} for different commands.

An example of this probe insertion strategy is reported in Listing~\ref{lst:probe_insertion}.

\begin{lstlisting}[language=C++, caption=Probe insertion Strategy, label={lst:probe_insertion}]

case 0x04: //RMTCMD(O1,04) STO_GET_HEAD
{
    ::Smp::UInt64 sequenceId;
    auto statusCode = Pdhu->StorageReadBack->GetHeadPointer(data[1], sequenceId);

    if(statusCode == RCSC_CmdOk)
    {
        Generic::Utils::SerializeLe(sequenceId, newData.begin() + 2, 5);

        // MANUALLY INSERTED PROBE
        mutate_FM_STO_GET_HEAD( &newData );
        // END OF THE PROBE

        }
    else
    {
        newData[1] = statusCode;
        }
}
break;

\end{lstlisting}

\section{Fault Model}
We defined one Fault Model for every command/answer pair of interest (according to LuxSpace), based on the structure of the buffer and on the data contained in it.
They are:
\begin{itemize}
\item STO\_GET\_HEAD
\item STO\_GET\_TAIL
\item CRC\_COMPUTE
\end{itemize}

The Fault Models for the \case were defined in the \emph{.csv} file format; their content is reported in Table~\ref{tab:fault_model}.

\input{tables/fault_model}

Every line of the fault model file represents a mutation operator, while every column represents a configuration parameter for that operator.

\begin{itemize}
  \item Column \emph{FaultModel} contains the name of the Fault Model containing the operator. Typically the user shall define a fault model for every different kind of message exchanged through the buffer.

  \item Column \emph{DataItem} refers to the index of the first element of the targeted data item in the array representing the buffer.

  \item Column \emph{Span} reports the number of array elements that make up the data item target by the mutation.

  \item Column \emph{Type} reports about the type of data targeted by the mutation: \texttt{INT}, \texttt{LONG}, \texttt{FLOAT}, \texttt{DOUBLE}, \texttt{BIN} or \texttt{HEX}.

  \item Column \emph{FaultClass} contains the type of fault that the mutation will emulate, depending on the chosen mutation operator. A summary of the mutation operators can be found in Table~\ref{tab:operators}.

  \item The other columns represent configuration parameters and assume different meanings depending on the mutation operator they refer to. More details on the data-driven mutation operators and their configuration can be found in Table~\ref{tab:operators}.

\end{itemize}

\input{tables/operators}

A mutation operator can generate one or more mutants performing a \emph{Mutation Operation}.
