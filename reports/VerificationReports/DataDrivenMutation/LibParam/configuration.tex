% !TEX root = MAIN.tex

\chapter{Configuration of the toolset}

\section{Probe insertion}

In the \case the mutation probes were inserted into the function \emph{gs\_rparam\_process\_packet}, which take care of encapsulating the \emph{libParam} data and provide it to the communication library \emph{libGSCSP}. The function is implemented in the file \emph{libparam/src/csp\_service\_handler.c}.

It consist mainly of switch statements that handle the different kinds of action requested within each packet and the different kinds of payload that go along with them.

For every notable switch case, a \emph{Mutation Probe} has been inserted to mutate the data contained in the buffer. In addition to that, there is also a \emph{General} mutation probe that applies to all switch cases.

The buffer to mutate is implemented as a custom data structure of type \emph{gs\_rparam\_query\_t}, called \texttt{request}; for this reason the data is converted into an array before mutation and converted back afterwards.

An example of this probe insertion strategy is reported in Listing~\ref{lst:probe_insertion}.

\begin{lstlisting}[language=C++, caption=Probe insertion Strategy, label={lst:probe_insertion}]

case RPARAM_SET: {

  //start of the  mutation probe
  unsigned long long int v_SET[7];

  v_SET[0] = (unsigned long long int) request->action;
  v_SET[1] = (unsigned long long int) request->table_id;
  v_SET[2] = (unsigned long long int) request->length;
  v_SET[3] = (unsigned long long int) request->checksum;
  v_SET[4] = (unsigned long long int) request->seq;
  v_SET[5] = (unsigned long long int) request->total;
  v_SET[6] = (unsigned long long int)request->payload.packed[0];

  mutate_FM_SET(v_SET);

  request->action = (uint8_t) v_SET[0];
  request->table_id = (uint8_t) v_SET[1];
  request->length = (uint16_t) v_SET[2];
  request->checksum = (uint16_t) v_SET[3];
  request->seq = (uint16_t) v_SET[4];
  request->total = (uint16_t) v_SET[5];
  request->payload.packed[0]=(uint8_t)v_SET[6];

  //end of the mutation probe

          if (!validate_checksum(tinst, request->checksum)) {
              request_packet->data[0] = RPARAM_ERROR;
              goto out_send_status;
          }


          if (gs_param_deserialize(tinst, request->payload.packed, request->length, F_FROM_BIG_ENDIAN) == GS_OK) {
              request_packet->data[0] = RPARAM_SET_OK;
          } else {
              request_packet->data[0] = RPARAM_ERROR;
          }
          goto out_send_status;
}

\end{lstlisting}

\section{Fault Model}

We defined one Fault Model for every type of action performed by \emph{gs\_rparam\_process\_packet}, based on the structure of the buffer and on the data contained in it.
They are:
\begin{itemize}
\item GET
\item SET
\item SAVE
\item LOAD
\end{itemize}

An additional fault model (General), as mentioned, applies to all switch cases and modifies header information.

The Fault Models for the \case were defined in the \emph{.csv} file format; their content is reported in Table~\ref{tab:fault_model}.

\input{tables/fault_model}

% \TODO{What file? the fault model? Maybe we shall say that for more information the reader can refer to the SUM?}
Every line of the fault model file represents a mutation operator, while every column represents a configuration parameter for that operator.

\begin{itemize}
  \item Column \emph{FaultModel} contains the name of the Fault Model containing the operator. Typically the user shall define a fault model for every different kind of message exchanged through the buffer.

  \item Column \emph{DataItem} refers to the index of the first element of the targeted data item in the array representing the buffer.

  \item Column \emph{Span} reports the number of array elements that make up the data item target by the mutation.

  \item Column \emph{Type} reports about the type of data targeted by the mutation: \texttt{INT}, \texttt{LONG}, \texttt{FLOAT}, \texttt{DOUBLE}, \texttt{BIN} or \texttt{HEX}.

  \item Column \emph{FaultClass} contains the type of fault that the mutation will emulate, depending on the chosen mutation operator. A summary of the mutation operators can be found in Table~\ref{tab:operators}.

  \item The other columns represent configuration parameters and assume different meanings depending on the mutation operator they refer to. More details on the data-driven mutation operators and their configuration can be found in Table~\ref{tab:operators}.

\end{itemize}

\input{tables/operators}

A mutation operator can generate one or more mutants performing a \emph{Mutation Operation}.
