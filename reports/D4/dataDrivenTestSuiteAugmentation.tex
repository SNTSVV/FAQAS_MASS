% !TEX root = MAIN.tex
\clearpage
\section{Data-driven Mutation Testing (Test Suite Augmentation)}
\label{sec:testGeneration:dataDriven}

\STARTCHANGEDFINAL
% Empirical evaluation concerning an approach for data-driven test suite augmentation has not performed because of the lack of an automated solution (see D2). In WP4, however, we will perform an empirical evaluation of the feasibility of the proposed manual approach.

\subsection{Overview}

\DAMTE aims to address a task (i.e., test generation at system and integration level) that is particularly difficult to address with state-of-the-art technology (e.g., test generation toolsets based on symbolic execution). In particular, the test generation backend selected for adoption in FAQAS (i.e., KLEE) requires manual intervention to specify which are the inputs to select thus preventing the automated generation of a large number of test cases. For code-driven mutation testing we have addressed this issue by relying on a template generator, which is difficult to implement for data-driven test generation because the identification of the function to test is hardly to automate (given that data-driven mutation analysis targets integration and system testing, it might be either the function with the mutation probe or another one). Also, and more importantly, it requires the compilation of the whole software under analysis through LLVM, which is often not feasible. For the reasons above, it is not feasible at the current stage to automate test generation of the whole software under test; consequently,
it is not possible to perform a large scale evaluation of the approach but only to focus on its feasibility analysis.

To summarize, in our evaluation, we address the following research question:

\emph{RQ1. Is DAMTE feasible in the context of space software?}



\subsection{Subject of the study}

To perform our empirical evaluation, we considered LibParam, which is a client-server component to manage configuration parameters in cubesats.

We rely on DAMTE to generate inputs for the \PARAM client API functions. The invocation of the \PARAM client API functions with the identified inputs enables the definition of integration test cases that exchange messages between the \PARAM client and the \PARAM server. The exchanged messages include data item instances that enable the execution of mutation operations that were not covered in the DAMAt empirical evaluation (see Section~\ref{sec:testSuiteEvaluation:dataDriven}).

\subsection{Experimental Setup}

To address our research question, we consider mutation analysis as a precondition for our subject; this is necessary since test generation only requires the list of the mutation operations uncovered by the test suite. Table~\ref{table:mutationresults:damat} reports the current mutation analysis results (i.e., DAMAt output) for \PARAM.
Particularly, it can be seen that \PARAM reaches a Mutation Operation Coverage of 93.20\%, which means that only 3 operations out of 44 were not covered by the test suite.

\begin{table}[tb]
\caption{Mutation Analysis Results.}
\label{table:mutationresults:damat}
\center
\footnotesize
\begin{tabular}{|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{24mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{17mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{12mm}@{\hspace{1pt}}|
}
\hline
\textbf{Subject} &
\textbf{\# FMs} &
\textbf{FMC} &
\textbf{\#MOs-CFM} &
\textbf{\#CMOs} &
\textbf{MOC}
&\textbf{Killed}&\textbf{Live}&\textbf{MS}
\\
\hline
\PARAM &6 &100.00\%  &   44 & 41 & 93.20\%  &        37&4&90.24\%\\
\hline
\end{tabular}

CMO=Covered Mutation Operation, MOs-CFM=Mutation Operations in covered FMs.

\end{table}

We applied DAMTE to generate test cases for mutants of the \emph{General} fault model that were not covered by the \PARAM test suite.
The \emph{General} fault model concerns the header structure of \PARAM messages sent from the \PARAM client to the \PARAM server.
%The \emph{General} fault model thus does not concerns the header structure of \emph{REPLY} messages sent from the \PARAM server to the \PARAM client.
The other fault model affected by a mutation operation not being covered is the fault model concerning \emph{REPLY} messages;  however, since such messages are generated by the server and received by the client, we cannot automatically generate them by applying test generation on the client.  More precisely, specific REPLY messages from the server can only be generated if an appropriate request is generated by the client; however, as described in D2, the automated generation of an appropriate request from the client is not feasible because of the communication channel that separates client and server.

Table~\ref{table:partial_fm} shows the specification of each analyzed mutant. It shows that the \PARAM test suite does not include input partitions covering non-nominal cases for the \emph{table ID} field (i.e., values above 20), and for the \emph{length} field (i.e., values above 180).

\begin{table}[tb]
\caption{Uncovered mutants from the General Fault Model.}
\label{table:partial_fm}
\center
\footnotesize
\begin{tabular}{|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{28mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{16mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{15mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{11mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{14mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{14mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{10mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{20mm}@{\hspace{1pt}}|
@{\hspace{0pt}}>{\raggedleft\arraybackslash}p{16mm}@{\hspace{1pt}}|
}
\hline
\textbf{MutationOperationID} &
\textbf{FaultModel} &
\textbf{DataItem} &
\textbf{Type} &
\textbf{FaultClass} &
\textbf{Threshold} &
\textbf{Status} &
\textbf{Application} &
\textbf{Description}
\\
\hline
10&General&1&LONG&FVAT&20&LIVE&NOT\_APPLIED&table ID\\
18&General&2&LONG&FVAT&180&LIVE&NOT\_APPLIED&length\\
\hline
\end{tabular}

\end{table}

For the generation of missing inputs we used KLEE 2.3 with LLVM 9.0.1. We performed our experiments on a MacBook Pro with 2,3 GHz 8-Core Intel Core i9.

Since KLEE requires the SUT to be compiled with clang to produce the bitcode files (i.e., KLEE input) and \PARAM is not originally expected to be compiled with clang but gcc,
%, and also to avoid incompatibilities with the original compiler (i.e., gcc).
we evaluated two different approaches for compiling \PARAM. First, we compiled the whole library into one bitcode file, to minimize the risk of imprecise results (i.e., KLEE might simulate the output of a function if the implementation of it is not provided). Second, we isolated the function under test in a different source file, so that only the required functions are compiled with clang. In the following, we discuss both the feasibility of each compilation strategy and the quality of the identified test inputs.

To drive test generation with KLEE, as presented in D2, we rely on a test template that initializes the required data structures and invokes the function under test.
The generation of the inputs that cover the mutant is enabled by the use of the DAMAt mutation probe API configured for test generation instead of mutation.
In particular, following the procedure described in D2, we add a call to function \texttt{\_FAQAS\_mutate} in the code of the \PARAM client. In the context of test generation, function \texttt{\_FAQAS\_mutate} instead of mutating the data includes a reachability assertion (i.e., \emph{assert(false)}) that forces the generation of a specific data item instance (see D2).

\subsection{RQ1 - Feasibility}


% (i.e., the uncovered input partition for a specific data item).

In the following, we discuss the procedure and the results obtained when applying DAMTE to LibParam using the two different configurations introduced above  (i.e., \emph{full compilation of \PARAM} and \emph{isolating the function under test}).

\subsubsection{Full compilation of \PARAM}

We modified the WAF compilation configuration file, and enabled clang as the main compiler of the library. This was done by replacing \texttt{conf.load('gcc')} by \texttt{conf.load('clang')} in the \url{tools/buildtools/waftool/gs_gcc.py} script.
Then, we proceeded by adding the following compiler arguments to the configuration file \url{tools/buildtools/gs/buildtools/compiler_settings.json}:


\begin{lstlisting}[style=CStyle]
"CFLAGS": ["-c", "-std=gnu99", "-m64", "-g", "-Xclang" , "-disable-O0-optnone", "-save-temps"],
\end{lstlisting}

Note that the parameter \texttt{-save-temps} forces clang to produce \texttt{bc} files along with the object files.

After generating all the \texttt{bc} files, we linked together into one bitcode file with the following command:

\begin{lstlisting}[style=CStyle]
$ llvm-link-9 *.bc -o libparam.exe
\end{lstlisting}

We processed then \texttt{libparam.exe} with KLEE with the following command:

\begin{lstlisting}[style=CStyle]
$ klee --libc=uclibc --posix-runtime --external-calls=all libparam.exe
\end{lstlisting}

However, with the approach described above, KLEE throws several errors about missing function implementations. These errors occur because the WAF clang module outputs all the bitcode files into a same folder without respecting the original compiler organization (i.e., the object files are stored in the same structure of the source code). Since \PARAM contains multiple source files having the same name but different content (i.e., source code), object files without the required definitions may overwrite the ones without them; consequently, the LLVM linker generates an executable including only a subset of the required objects, which leads to errors during the execution of KLEE. A possible solution consists of extending the WAF clang module to store bitcode files appropriately - it will be evaluated in the maintenance period of the project.


\subsubsection{Isolating the function under test}

In this setup, we isolated the function under test along its dependencies and copied them into a same test template source file. Below, we describe the output observed for the two data items targeted by mutation, i.e.,
\emph{table ID} and \emph{length}.


\paragraph{Table ID}\

When generating inputs for \texttt{tableID}, we have first identified the API command that generates messages including the table ID. As indicated in D2, we selected function
\texttt{gs\_rparam\_get\_array}. Then we have identified a higher-level function that relies on function
\texttt{gs\_rparam\_get\_array}; although function \texttt{gs\_rparam\_get\_array} can be directly targeted in test cases, invoking a higher-level function is easier for an engineer (less parameters are required).
Finally, we have included in the test template all these functions and their dependencies, which are \texttt{gs\_rparam\_get}, and \texttt{csp\_hton16}.
%which are necessary for correctly running \texttt{gs\_rparam\_get\_string}.

Listing~\ref{get_array} shows the source code for the function \texttt{gs\_rparam\_get\_array} with the mutation probe that enables the reachability analysis.
%so that KLEE can generate an input for the uncovered mutation operations (e.g., FVAT for table ID).

\begin{lstlisting}[style=CStyle,float=t, caption=Instrumented code for function gs\_rparam\_get\_array., label=get_array]
gs_error_t gs_rparam_get_array(uint8_t node,
                               gs_param_table_id_t table_id,
                               uint16_t addr,
                               gs_param_type_t type,
                               uint16_t checksum,
                               uint32_t timeout_ms,
                               void * value,
                               size_t value_element_size,
                               size_t array_size)
{
    /* Calculate length */
    gs_rparam_query_t * query;
    const size_t query_payload_size = sizeof(query->payload.addr[0]) * array_size;
    const size_t query_size = RPARAM_QUERY_LENGTH(query, query_payload_size);
    const size_t reply_payload_element_size = value_element_size + sizeof(query->payload.addr[0]);
    const size_t reply_payload_size = reply_payload_element_size * array_size;
    const size_t reply_size = RPARAM_QUERY_LENGTH(query, reply_payload_size);

    query = alloca(reply_size);
    query->action = RPARAM_GET;
    query->table_id = table_id;
    query->checksum = csp_hton16(checksum);
    query->seq = 0;
    query->total = 0;
    for(unsigned int i = 0; i < array_size; i++) {
        query->payload.addr[i] = csp_hton16(addr + (value_element_size * i));
    }
    query->length = csp_hton16(query_payload_size);

    FaultModel *fm_General = _FAQAS_General_FM();
    unsigned long long int v_General[6];

    v_General[0] = (unsigned long long int) query->action;
    v_General[1] = (unsigned long long int) query->table_id;
    v_General[2] = (unsigned long long int) query->length;
    v_General[3] = (unsigned long long int) query->checksum;
    v_General[4] = (unsigned long long int) query->seq;
    v_General[5] = (unsigned long long int) query->total;

    _FAQAS_mutate(v_General,fm_General);

    return GS_OK;
}
\end{lstlisting}



Listing~\ref{get_string} shows the implementation of the test template for driving the test generation for the function \texttt{gs\_rparam\_get\_string}. Particularly, it can be seen how \texttt{tableID} is made symbolic by the KLEE API function \texttt{klee\_make\_symbolic}. Then, the function under test is called with concrete parameters and the symbolic one; concrete parameters match the one in other test cases of the \PARAM test suite.

Note that the function \texttt{gs\_rparam\_get\_string} calls \texttt{gs\_rparam\_get}, which, in turn, invokes the instrumented \\
function \texttt{gs\_rparam\_get\_array}.

\begin{lstlisting}[style=CStyle,float=t, caption=Test template for function gs\_rparam\_get\_string., label=get_string]
int main(void) {
    // a little hack - this is next element, we use it check for overwrite and missing 0 termination
    memset(alltypes_mem.string_A, 'Z', sizeof(alltypes_mem.string_A));
    alltypes_mem.string_A[0][1] = 0;

    char buf[GS_TEST_ALLTYPES_STRING_LENGTH + 10];

    // get max size - no 0 termination
    memset(alltypes_mem.string, 'B', sizeof(alltypes_mem.string));
    memset(buf, 'A', sizeof(buf));
    buf[GS_TEST_ALLTYPES_STRING_LENGTH + 1] = 0;

    uint8_t tableID;
    klee_make_symbolic(&tableID, sizeof(tableID), "tableID");
    gs_rparam_get_string(CSP_NODE, tableID, GS_TEST_ALLTYPES_STRING, GS_RPARAM_MAGIC_CHECKSUM, 1000, buf, GS_TEST_ALLTYPES_STRING_LENGTH);

    return 0;
}
\end{lstlisting}

To compile the isolated functions along with the test template, we use the KLEE compilation arguments (i.e., \texttt{-g -Xclang -disable-O0-optnone -c -emit-llvm}) through the following command:

\begin{lstlisting}[style=CStyle]
$ /usr/bin/clang -std=gnu99 -m64 -g -Xclang -disable-O0-optnone -c -emit-llvm -Wall -Wextra -Wshadow -Wcast-align -Wwrite-strings -Wno-unused-parameter -Wall -Wextra -Wshadow -Wcast-align -Wwrite-strings -Wno-unused-parameter -Wno-unused-parameter -Iinclude -I../include -I__root__/opt/libparam/lib/libgscsp/lib/libcsp/include -I../../../lib/libgscsp/lib/libcsp/include -I__root__/opt/libparam/lib/libgscsp/lib/libutil/include -I../../../lib/libgscsp/lib/libutil/include -I__root__/opt/libparam/lib/libgscsp/lib/libutil/include/gs -I../../../lib/libgscsp/lib/libutil/include/gs -I__root__/opt/libparam/lib/libgscsp/lib/libutil/include/deprecated -I../../../lib/libgscsp/lib/libutil/include/deprecated -I__root__/opt/libparam/lib/libgscsp/lib/libutil/include/deprecated/gs/gosh -I../../../lib/libgscsp/lib/libutil/include/deprecated/gs/gosh -I__root__/opt/libparam/lib/libgscsp/include -I../../../lib/libgscsp/include -I__root__/opt/libparam/lib/libparam_client/include -I../../../lib/libparam_client/include -I__root__/opt/libparam/lib/libparam_client/include/deprecated -I../../../lib/libparam_client/include/deprecated -I__root__/opt/libparam/lib/libparam_client/include/deprecated/param -I../../../lib/libparam_client/include/deprecated/param -I__root__/opt/libparam/include -I../../../include -I__root__/opt/libparam/include/deprecated -I../../../include/deprecated -Iinclude -DSTRING_1="string 1" -DFALSE=false -DELEVEN=11 -DZERO_POINT_ZERO=0.0 -DMUTATIONOPT=10 ../main_table_id.c
\end{lstlisting}

Listing~\ref{klee_damte} shows the corresponding KLEE output for the variable \emph{tableID}. In particular, it shows that the  value that enables executing the FVAT mutation operation is the value \emph{21} assigned to \emph{tableID}. In this case, we can see that DAMTE provides the expected results (i.e., a vaue above 20). Please note that despite having a name that is similar to the data item to be mutated (i.e., \emph{query->table\_id}), the variable \emph{tableID} is not processed directly by the mutation analysis tool but it is first copied into the message data structure, which exemplifies the case of KLEE generating an input that drives (after further computation) the generation of the required messages.
%which shows that KLEE may handle the identification of inputs that lead to the definition of correctly for simple variables that are directly processed by the function.

\begin{lstlisting}[style=CStyle,float=t, caption=KLEE output for the variable tableID., label=klee_damte]
object 1: name: 'tableID'
object 1: size: 1
object 1: data: b'\x15'
object 1: hex : 0x15
object 1: int : 21
object 1: uint: 21
object 1: text: .
\end{lstlisting}

\paragraph{length}\

To generate test cases that enable executing the operator affecting the \texttt{length} message item, we introduced the test template used in Listing~\ref{get_string}. In this case, we directly test the function \texttt{gs\_rparam\_get\_array} using \texttt{value\_size} as a symbolic value because function \emph{gs\_rparam\_get\_string} uses a constant value for variable \texttt{value\_size} (and therefore cannot enable test generation).

\begin{lstlisting}[style=CStyle,float=t, caption=Test template for function gs\_rparam\_get\_array.]
int main(void) {
    uint8_t buf[1000];
    memset(buf, 0, sizeof(buf));
    size_t value_size;
    klee_make_symbolic(&value_size, sizeof(value_size), "value_size");
    gs_rparam_get_array(CSP_NODE, GS_TEST_ALLTYPES_TABLE_ID, GS_TEST_ALLTYPES_UINT8_A(0), PARAM_UINT8, GS_RPARAM_MAGIC_CHECKSUM, 1000,
                                              &buf, sizeof(uint8_t), value_size);
    return 0;
}
\end{lstlisting}

Unfortunately, the execution of KLEE leads to an error stating that line 19 of Listing~\ref{get_array} produces a memory error because the symbolic value is used to  specify the dimension of a memory buffer to be allocated. The concretized symbolic value is usually assigned with a value equal to zero, which leads to an out-of-bound error; this is a known limitation of KLEE\footnote{See for example https://github.com/klee/klee/issues/1227}.
%most probably because the tool has concretized a huge value for the \texttt{alloca} function.
In this case, we can see that DAMTE does not work properly when the variable to be tested represents memory size.

Overall, we conclude that the DAMTE approach may be feasible; however, it requires some manual effort for the configuration and execution of test cases which may limit its usefulness. The first step towards its large scale applicability is the improvement of underlying test generation tools and compiler procedures, such changes will facilitate DAMTE application to large projects without the need for manually creating test template files with dependencies.

\begin{lstlisting}[style=CStyle,float=t, caption=KLEE error output, label=klee_error]
KLEE: NOTE: Using POSIX model: /tmp/klee_build90stp_z3/runtime/lib/libkleeRuntimePOSIX64_Debug+Asserts.bca
KLEE: NOTE: Using klee-uclibc : /tmp/klee_build90stp_z3/runtime/lib/klee-uclibc.bca
KLEE: output directory is "/opt/libparam/tst/rparam4_llvm/build/klee-out-1"
KLEE: Using STP solver backend
KLEE: WARNING: executable has module level assembly (ignoring)
KLEE: WARNING ONCE: calling external: syscall(16, 0, 21505, 94391800950288) at klee_src/runtime/POSIX/fd.c:1007 10
KLEE: WARNING ONCE: Alignment of memory from call "malloc" is not modelled. Using alignment of 8.
KLEE: WARNING ONCE: calling __klee_posix_wrapped_main with extra arguments.
KLEE: NOTE: found huge malloc, returning 0
KLEE: ERROR: ../main_length.c:250: concretized symbolic size
KLEE: NOTE: now ignoring this error at this location
KLEE: ERROR: ../main_length.c:251: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location
KLEE: WARNING ONCE: Alignment of memory from call "realloc" is not modelled. Using alignment of 8.
\end{lstlisting}

\ENDCHANGEDFINAL
