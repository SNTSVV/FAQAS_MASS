% !TEX root = MutationTestingSurvey.tex

\subsection{Solutions to Improve Compile-time Scalability}
\label{sub:compileTime}
\label{sec:opt:selection}

Another source of \INDEX{scalability issues} is the compilation of mutants;
indeed, because of the large number of mutation operators available in the literature, the number of mutants to be compiled is not negligible. In this section we report the main research results aiming at reducing the time required to compile mutants.
%has worked on approaches based on optimising the compilation process.

Untch et al. \cite{untch1993mutation} proposed a technique called \INDEX{mutant schemata}; the technique introduces the concept of meta-program, which stands for including and compiling all the mutants in a single executable file, instead of compiling one executable per mutation generated. The mutations are then managed at run-time through parameters that enable software engineers to choose the mutation to be executed, results show speed improvements over 300\% \cite{untch1993mutation,papadakis2010automatic}. Modern mutation testing tools such as Accmut \cite{wang2017faster} and Milu \cite{jia2008milu} include this type of optimisation.

Another solution consists of mutating directly the compiled code so that mutants can be executed without compiling each of them.
This optimisation has been applied on 
Assembly languages \cite{crouzet2006sesame},
Java bytecode \cite{ma2006mujava}, 
binary code for embedded software \cite{becker2012xemu},
Common Intermediate Language (.NET) \cite{derezinska2011object} 
and LLVM Intermediate Representation \cite{hariri2016evaluating}. 
% \REVTWO{C8}{Results obtained by Derezinska and Kowalski \cite{derezinska2011object} show that, on average, the mutation testing process mutating compiled code requires only 50\% of the time required by a traditional mutation testing process applied to source code. 
% Additionally, the mutations performed on compiled code can be applied directly to multiple source languages (e.g., LLVM IR supports C, C++, Objective-C, Objective-C++, OpenMP, OpenCL and CUDA) \cite{hariri2019comparing}.
% However, there are some drawbacks when mutating compiled code, for example many of the mutations generated cannot be represented at the source code level \cite{jia2010analysis}, creating not relevant mutations. 
% In the case of mutation of binary code, the mutation process can become very expensive since it is necessary to translate the code into machine readable instructions \cite{becker2012xemu}.}



\TODO{I think we need here a paragraph where you say that LLVM IR is a common target of multiple research work. You can reuse the text in A1.3.1 CLANG/LLVM, along with the picture.}

\TODO{In the paragraph below it is not clear what do you mean for 'compiled code', I expect a follow-up sentence where you specify the type of compiled code they consider in their experiments.} \TODO{In general, If the experiments below target LLVM IR say it explicitly}
\REVTWO{C8}{About the advantages of performing mutation at different levels,
results obtained by Derezinska and Kowalski~\cite{derezinska2011object} show that, on average, the mutation of compiled code requires only 50\% of the time required by a traditional mutation testing process applied to source code.}
\TODO{The following sentence is unclear. Do you mean that toolsets that work on IR can be easily adopted to work on multiple languages?}
\REVTWO{C8}{Additionally, the mutations performed on compiled code can be applied directly to multiple source languages, for example, LLVM IR supports C, C++, Objective-C, Objective-C++, OpenMP, OpenCL and CUDA~\cite{hariri2019comparing}.}
\TODO{Below, an example is needed. Also add a sentence that indicates which type of compiled code was considered Can you present the solutions invented by MULL to overcome this problem? Can you present the features of MULL in a dedicated paragraph?}
\REVTWO{C8}{However, there are some drawbacks when mutating compiled code, for example many of the mutations generated cannot be represented at the source code level, creating not relevant mutations~\cite{jia2010analysis}.}

\TODO{demonstrated on an empirical evaluation => provided empirical evidence that}
Furthermore, recently Hariri et al.~\cite{hariri2019comparing} demonstrated on an empirical evaluation that \textit{the number of generated mutants is much higher at the intermediate representation level than at source code level, suggesting that mutation testing at source code level is much faster to perform than at intermediate representation level.}


\TODO{Can you report some numbers? is it binary code or executable code or executable binary code (i.e., .EXE programs)?}
\TODO{Also, I cannot understand what is the point what does it mean "to translate the code into machine readable instructions"? Do you mean that compiling an .EXE is more expensive than compiling a IR?}
{On a different context, such as the mutation of binary code, the mutation process can become very expensive since it is necessary to translate the code into machine readable instructions before performing actual mutations~\cite{becker2012xemu}.}


