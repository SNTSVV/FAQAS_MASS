% !TEX root =  ../MutationTestingSurvey.tex


\clearpage



\setlength\LTleft{0pt}
\setlength\LTright{0pt}
\tiny 
\begin{longtable}{@{\extracolsep{\fill}}|p{1.2cm}|l|p{1.2cm}|p{3.5cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.4cm}|p{0.4cm}|p{0.8cm}|@{}}
\caption{\normalsize Code-driven Mutation Operators. Column \emph{S} indicates if the operator is a sufficient operator.}
\label{table:codeoperators} \\
%	\toprule 
\hline

	\textbf{Name}	&	\textbf{S}	&	\textbf{Category}	&	\textbf{Definition}	&	\textbf{C/C++}	&	\textbf{LLVM}		&	 \textbf{\begin{tabular}[c]{@{}l@{}}Other OO\\ Languages\end{tabular}} 	&	\textbf{ADA} 	&	\textbf{SQL} 	&  \textbf{Simulink}	\\
%	\midrule
\hline
	OAAN & Yes & arithmetic & The operator OAAN performs arithmetic mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), $\beta$ is another arithmetic operator (e.g., *), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC, \Sciror & \Mull, \Sciror, \Accmut & \Major, \MuJava &  & \TuyaSQL & \BinhSimulink\\
	OABN &  & arithmetic & The operator OABN performs arithmetic mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), $\beta$ is another bitwise operator (e.g., \&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OALN &  & arithmetic & The operator OALN performs arithmetic mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), $\beta$ is another logical operator (e.g., \&\&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OARN &  & arithmetic & The operator OARN performs arithmetic mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), $\beta$ is another relational operator (e.g., <), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OASN &  & arithmetic & The operator OASN performs arithmetic mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), $\beta$ is another shift operator (e.g., \textless \textless), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OEAA &  & arithmetic assignment & The operator OEAA performs plain assignment mutations. Given $\alpha$ is a plain assignment (e.g., =), $\beta$ is another arithmetic assignment operator (e.g., +=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OAAA &  & arithmetic assignment & The operator OAAA performs arithmetic assignment mutations. Given $\alpha$ is an assignment operator (e.g., +=), $\beta$ is another binary operator (e.g., -=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC & \Mull & \MuJava &  &  & \\
	OABA &  & arithmetic assignment & The operator OABA performs arithmetic assignment mutations.  Given $\alpha$ is an arithmetic assignment operator (e.g., +=), $\beta$ is another bitwise assignment operator (e.g., |=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OAEA &  & arithmetic assignment & The operator OAEA performs arithmetic assignment mutations.  Given $\alpha$ is an arithmetic operator (e.g., +), the mutation is performed by removing $\alpha$ from the assignment. & \MUSIC &  &  &  &  & \\
	OASA &  & arithmetic assignment & The operator OASA performs arithmetic assignment mutations.  Given $\alpha$ is an arithmetic assignment operator (e.g., +=), $\beta$ is another shift assignment operator (e.g., \textless \textless =), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OBAN &  & bitwise & The operator OBAN performs bitwise mutations.  Given $\alpha$ is a bitwise operator (e.g., \&), $\beta$ is another arithmetic operator (e.g., +), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OBBN & Yes & bitwise & The operator OBBN performs bitwise mutations.  Given $\alpha$ is a bitwise operator (e.g., \&), $\beta$ is another bitwise operator (e.g., |), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC, \Sciror & \Sciror, \Accmut & \Major &  & \TuyaSQL & \\
	OBLN &  & bitwise & The operator OBLN performs bitwise mutations. Given $\alpha$ is a bitwise operator (e.g., \&), $\beta$ is another logical operator (e.g., \&\&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OBNG &  & bitwise & The OBNG operator performs bitwise negation mutations. For example, the expression \texttt{x op y} mutates to (1) \texttt{x op \textasciitilde y}, (2) \texttt{\textasciitilde x op y} and (3) \texttt{\textasciitilde(x op y)}. & \MUSIC &  &  &  &  & \\
	OBRN &  & bitwise & The operator OBRN performs bitwise mutations.  Given $\alpha$ is a bitwise operator (e.g., \&), $\beta$ is another relational operator (e.g., <), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OBSN &  & bitwise & The operator OBSN performs bitwise mutations.  Given $\alpha$ is a bitwise operator (e.g., \&), $\beta$ is another shift operator (e.g., \textless \textless), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OCNG &  & bitwise & The operator OCNG performs logical context mutations. In particular, negate expressions within if and while statements. & \Milu &  &  &  &  & \\
	OBAA &  & bitwise assignment & The operator OBAA performs bitwise assignment mutations.  Given $\alpha$ is a bitwise assignment operator (e.g., |=), $\beta$ is another arithmetic assignment operator (e.g., +=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OBBA &  & bitwise assignment & The operator OBBA performs bitwise assignment mutations.  Given $\alpha$ is an bitwise assignment operator (e.g., \&=), $\beta$ is another bitwise assignment operator (e.g., |=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OBEA &  & bitwise assignment & The operator OBEA performs bitwise assignment mutations.  Given $\alpha$ is a bitwise operator (e.g., \&), the mutation is performed by removing $\alpha$ from the assignment. & \MUSIC &  &  &  &  & \\
	OBSA &  & bitwise assignment & The operator OBSA performs bitwise assignment mutations.  Given $\alpha$ is a bitwise assignment operator (e.g., \&=), $\beta$ is another shift assignment operator (e.g., \textless \textless=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OEBA &  & bitwise assignment & The operator OEBA performs plain assignment mutations. Given $\alpha$ is a plain assignment (e.g., =), $\beta$ is another bitwise assignment operator (e.g., \&=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OCOR &  & casts & The operator OCOR performs mutations on cast types. In particular, modifies the type of the cast being applied by a different one. & \MUSIC &  &  &  &  & \\
	CGCR &  & constants & The operator CGCR mutate constants using other global constants in the program. & \MUSIC &  &  &  &  & \\
	CLSR &  & constants & The operator CLSR mutates the program by replacing scalar variables with local constants. & \MUSIC &  &  &  &  & \\
	CGSR &  & constants & The operator CGSR mutates the program by replacing scalar variables with global constants. & \MUSIC &  &  &  &  & \\
	CRCR & Yes & constants & The operator CRCR mutates systematically each scalar by elements of $I=\{0, 1, -1, u_i\}$ or $R=\{0.0, 1.0, -1.0, u_r\}$. If the scalar reference is integral, $I$ is used. For references of floating type, $R$ is used. & \MUSIC, \Sciror & \Sciror & \Major &  &  & \\
	CLCR &  & constants & The operator CGCR mutate constants using other local constants in the program. & \MUSIC &  &  &  &  & \\
	SBRC &  & control flow & The operator SBRC mutates \texttt{break} statements by replacing them with \texttt{continue} statements. & \MUSIC &  &  &  &  & \\
	SBRn &  & control flow & The operator SBRn mutates the break or continue statements, and replaces them by the function \texttt{break\_out\_to\_level\_n(j)}, for 2 <= j <= n. When the mutated code is executed, it causes the loop, inside which the mutated statement is nested, and the $j$ enclosing loops to terminate. & \MUSIC &  &  &  &  & \\
	SCRB &  & control flow & The operator SCRB mutates \texttt{continue} statements by replacing them with \texttt{break} statements. & \MUSIC &  &  &  &  & \\
	SDWD &  & control flow & The operator SDWD mutates \texttt{do-while} statements by replacing them with \texttt{while} statements. & \MUSIC &  &  &  &  & \\
	SGLR &  & control flow & The SGLR operator mutates the label of the \texttt{goto} statement with the labels defined in $L=\{l_1, l_2, ..., l_n\}$ & \MUSIC &  &  &  &  & \\
	SRSR &  & control flow & The SRSR operator mutates the code by replacing statements with \texttt{return} statements. & \MUSIC &  &  &  &  & \\
	SSWM &  & control flow & The SSWM operator mutates the expression within the switch statement with the \texttt{trap\_on\_case()} function. This mutations forces the execution of each case within the switch structure. & \MUSIC &  &  &  &  & \\
	SMTT &  & control flow & The SMTT operator mutates the code by introducing the false\_after\_nth\_loop\_iteration(n) function before a loop. This function assures that the loop is executed at least once. & \MUSIC &  &  &  &  & \\
	SWDD &  & control flow & The operator SDWD mutates \texttt{do-while} statements by replacing them with \texttt{while} statements. & \MUSIC &  &  &  &  & \\
	SSDL & Yes & deletion & The SSDL operator delete statements maintaining syntax validity. The operator is designed to show that each statement in the program has an effect on the output. On~\Mull~tool there is an option to remove void functions on LLVM-IR code. & \MUSIC, \Proteum & \Mull, \Accmut & \Major &  &  & \\
	OLAN &  & logical & The operator OLAN performs logical mutations. Given $\alpha$ is a logical operator (e.g., \&\&), $\beta$ is another arithmetic operator (e.g., +), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OLBN &  & logical & The operator OLBN performs logical mutations. Given $\alpha$ is a logical operator (e.g., \&\&), $\beta$ is another bitwise operator (e.g., \&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OLLN &  & logical & The operator OLLN performs logical mutations. Given $\alpha$ is a logical operator (e.g., \&\&), $\beta$ is another logical operator (e.g., ||), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC & \Mull & \Major, \MuJava &  &  & \BinhSimulink\\
	OLNG & Yes & logical & The operator OLNG performs logical mutations. Consider the expression \texttt{x op y}, (\texttt{op} can be \&\& or ||). OLNG will generate three mutants: \texttt{x op !y}, \texttt{!x op y}, and \texttt{!(x op y)}. & \MUSIC & \Mull, \Accmut & \Major, \MuJava &  &  & \\
	OLRN &  & logical & The operator OLRN performs logical mutations. Given $\alpha$ is a logical operator (e.g., \&\&), $\beta$ is another relational operator (e.g., <), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OLSN &  & logical & The operator OLSN performs logical mutations. Given $\alpha$ is a logical operator (e.g., \&\&), $\beta$ is another shift operator (e.g., \textless \textless), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	ORAN &  & relational & The operator ORAN performs relational mutations. Given $\alpha$ is a relational operator (e.g., <), $\beta$ is another arithmetic operator (e.g., +), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	ORBN &  & relational & The operator ORBN performs relational mutations. Given $\alpha$ is a relational operator (e.g., <), $\beta$ is another bitwise operator (e.g., <), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	ORLN &  & relational & The operator ORLN performs relational mutations. Given $\alpha$ is a relational operator (e.g., <), $\beta$ is another logical operator (e.g., \&\&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	ORRN & Yes & relational & The operator ORRN performs relational mutations. Given $\alpha$ is a relational operator (e.g., <), $\beta$ is another relational operator (e.g., <=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC, \Sciror & \Sciror, \Accmut & \Major, \MuJava &  & \TuyaSQL & \BinhSimulink\\
	ORSN &  & relational & The operator ORSN performs relational mutations. Given $\alpha$ is a relational operator (e.g., <), $\beta$ is another shift operator (e.g., \textless \textless), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSAN &  & shift & The operator OSAN performs shift mutations. Given $\alpha$ is a shift operator (e.g., \textless \textless), $\beta$ is another arithmetic operator (e.g., +), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSBN &  & shift & The operator OSBN performs shift mutations. Given $\alpha$ is a shift  operator (e.g., \textless \textless), $\beta$ is another bitwise operator (e.g., \&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSLN &  & shift & The operator OSLN performs shift mutations. Given $\alpha$ is a shift  operator (e.g., \textless \textless), $\beta$ is another logical operator (e.g., \&\&), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSRN &  & shift & The operator OSRN performs shift mutations. Given $\alpha$ is a shift operator (e.g., \textless \textless), $\beta$ is another relational operator (e.g., <), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSSN &  & shift & The operator OSSN performs shift mutations. Given $\alpha$ is a shift operator (e.g., \textless \textless), $\beta$ is another shift operator (e.g., \textgreater \textgreater), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OESA &  & shift assignment & The operator OESA performs plain assignment mutations. Given $\alpha$ is a plain assignment (e.g., =), $\beta$ is another shift assignment operator (e.g., \textless \textless=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$ & \MUSIC &  &  &  &  & \\
	OSAA &  & shift assignment & The operator OSAA performs shift assignment mutations. Given $\alpha$ is a shift assignment operator (e.g., \textless \textless=), $\beta$ is another arithmetic assignment operator (e.g., +=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OSBA &  & shift assignment & The operator OSBA performs shift assignment mutations. Given $\alpha$ is a shift assignment operator (e.g., \textless \textless), $\beta$ is another bitwise assignment operator (e.g., |=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	OSEA &  & shift assignment & The operator OSEA performs shift assignment mutations. Given $\alpha$ is a shift assignment operator (e.g., \textless \textless=), $\beta$ is another plain assignment operator (e.g., =), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  &  &  &  & \\
	OSSA &  & shift assignment & The operator OSAA performs shift assignment mutations. Given $\alpha$ is a shift assignment operator (e.g., \textless \textless=), $\beta$ is another arithmetic assignment operator (e.g., +=), the mutation is performed by replacing $a\:\alpha\:b$ with $a\:\beta\:b$. & \MUSIC &  & \MuJava &  &  & \\
	SMVB &  & statements & The SMVB operator mutates the code by moving up and down the brace '\}' systematically. Including, or excluding, some statements within a compound statement. & \MUSIC &  &  &  &  & \\
	SSOM &  & statements & The SSOM rotates the expressions separated internally by a comma. For example, the function \texttt{f(a, (b=1, b+2), c);} has three parameters, the operator SSOM could generate the following function call: \texttt{f(c, a, (b=1, b+2));}.   & \MUSIC &  &  &  &  & \\
	STRI &  & statements & The STRI operator mutates if statements by replacing each if statement with the \texttt{trap\_on\_true(v)} function. The \texttt{trap\_on\_true(v)} function forces the execution of the if branch. & \MUSIC &  &  &  &  & \\
	STRP &  & statements & The STRP operator mutates statements by replacing each statement with the \texttt{trap\_on\_statement()} function. The \texttt{trap\_on\_statement()} function forces the execution of each statement. & \MUSIC &  &  &  &  & \\
	SMTC &  & statements & The SMTC operator mutates the code by introducing the \texttt{false\_after\_nth\_loop\_iteration(n)} function before a loop. This function assures that the loop is executed at least $n$ times. & \MUSIC &  &  &  &  & \\
	VGTR &  & structures & The VGTR operator mutates structure references using global structure references. & \MUSIC &  &  &  &  & \\
	VLTR &  & structures & The operator mutates a structure reference using local structure references. & \MUSIC &  &  &  &  & \\
	VSCR &  & structures & The VSCR operator mutates the references to a structure component (e.g., selecting the wrong component of a structure).  & \MUSIC &  &  &  &  & \\
	OIPM &  & variable references & The operator OIPM (Indirection Operator Precedence Mutation) mutates a reference of the form \texttt{*x op} to \texttt{(*x) op} and \texttt{op(*x)}, where \texttt{op} can be ++ and - -. & \MUSIC &  &  &  &  & \\
	VASM &  & variable references & The VASM operator rotates the sub-scripts order in a multi-dimensional array. For example, the reference $a[e_1][e_2]...[e_n]$ could be mutated to $a[e_n][e_1]...[e_{n-1}]$. & \MUSIC &  &  &  &  & \\
	VGAR &  & variable references & This operator mutates an array reference using other global array references. & \MUSIC &  &  &  &  & \\
	VLAR &  & variable references & The VLAR operator mutates array references using local array references. & \MUSIC &  &  &  &  & \\
	VGLA &  & variable references & This operator mutates an array reference using both global and local array references. &  &  &  &  &  & \\
	VGPR &  & variable references & The VGPR operator mutates pointer references using global pointer references. & \MUSIC &  &  &  &  & \\
	VLPR &  & variable references & The VLPR operator mutates pointer references using local pointer references. & \MUSIC &  &  &  &  & \\
	VDTR & Yes & variable references & The operator mutates each scalar reference x of type \texttt{t} in a expression, by \texttt{f(x)}, where \texttt{f} could be one of the several functions (1) trap on negative \texttt{x}: mutant killed if arg is negative, else return argument value, (2) trap on positive \texttt{x}: mutant killed if arg is positive, else return arg value, and (3) trap on zero \texttt{x}: mutant killed if arg is zero, else return arg value. & \MUSIC & \Accmut &  &  & \TuyaSQL & \\
	VGSR &  & variable references & The VGSR operator mutates scalar variables using global scalar references & \MUSIC &  &  &  &  & \\
	VLSR &  & variable references & The VLSR operator mutates scalar references using local scalar references. & \MUSIC &  &  &  &  & \\
	VTWD & Yes & variable references & The VTWD operator modifies scalar references by +-1. & \MUSIC & \Accmut & \MuJava &  & \TuyaSQL & \\
	CCDL &  & deletion & The CCDL operator removes all occurrences of constant references. & \Proteum &  &  &  &  & \\
	OODL &  & deletion & The OODL operator removes each arithmetic, relational, logical, bitwise and shift operator in expressions. It also removes them from assignment operators, replacing them by a plain assignment operator. & \Proteum &  &  &  &  & \\
	VVDL &  & deletion & The VVDL operator removes all occurrences of variable references from every expression. & \Proteum &  &  &  &  & \\
	RMNLS &  & deletion & The RMNLS operator removes statements that assign null character at the end of buffer. Since null character is used to mark the end of a buffer, removal of the statement allows reading to contiguous memory location beyond the buffer size. & \Shahriar &  &  &  &  & \\
	MFC\_C &  & floating points & The MFC\_C operator performs comparisons between float operands. The operator finds a floating point comparison (FPC) and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flcmp} introduces a small $\epsilon$ number as a tolerance, which means that, if the difference between two operands of an FPC is smaller than the $\epsilon$, the two operands are considered to be equal. The MFC\_C uses a constant to introduce the tolerance. & \SMT &  &  &  &  & \\
	MFC\_F &  & floating points & The MFC\_F operator performs comparisons between float operands. The operator finds a floating point comparison (FPC) and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flpcmp} introduces a small epsilon number as the tolerance which means that, if the difference between two operands of an FPC is smaller than epsilon, the two operands are considered to be equal. Differently from the MFC\_C operator, the MFC\_F operator uses the FCMP algorithm to introduce tolerance. The FCMP takes three parameters: the first two are operands of the FPC and the third is the original $\epsilon$. The return values of fcmp are 1, 0,−1 representing the first operand being bigger than, equivalent to or smaller than the second operand, respectively. & \SMT &  &  &  &  & \\
	MFC\_H &  & floating points & The MFC\_H operator performs comparisons between float operands. The operator finds an FPC and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flpcmp} introduces a small epsilon number as the tolerance which means that, if the difference between two operands of an FPC is smaller than epsilon, the two operands are considered to be equal. The MFC\_H operator uses the hybrid algorithm to introduce tolerance. & \SMT &  &  &  &  & \\
	MDC\_C &  & floating points & The MDC\_C operator performs comparisons between double operands. The operator finds an FPC and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flpcmp} introduces a small epsilon number as the tolerance which means that, if the difference between two operands of an FPC is smaller than epsilon, the two operands are considered to be equal. The MDC\_C uses a constant to introduce the tolerance. & \SMT &  &  &  &  & \\
	MDC\_F &  & floating points & The MDC\_F operator performs comparisons between double operands. The operator finds an FPC and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flpcmp} introduces a small epsilon number as the tolerance which means that, if the difference between two operands of an FPC is smaller than epsilon, the two operands are considered to be equal. The operator uses the FCMP algorithm to introduce tolerance. The FCMP takes three parameters: the first two are operands of the FPC and the third is the original $\epsilon$. The return values of fcmp are 1, 0,−1 representing the first operand being bigger than, equivalent to or smaller than the second operand, respectively. & \SMT &  &  &  &  & \\
	MDC\_H &  & floating points & The MDC\_H operator performs comparisons between double operands. The operator find an FPC and then changes the expression to a call of the function \texttt{flpcmp}. \texttt{flpcmp} introduces a small epsilon number as the tolerance which means that, if the difference between two operands of an FPC is smaller than epsilon, the two operands are considered to be equal. The operator uses the hybrid algorithm to introduce tolerance. & \SMT &  &  &  &  & \\
	RSSBO &  & function calls & The RSSBO operator modifies buffer size argument of safe ANSI C library functions such as \texttt{strncpy}, \texttt{strncat}, \texttt{memcpy}, \texttt{memset}, \texttt{memmove}, \texttt{snprintf}, \texttt{fgets}, and \texttt{vsnprintf}. The size is set to the length of destination buffer plus one. & \Shahriar &  &  &  &  & \\
	MBSBO &  & function calls & The MBSBO operator increases buffer variable sizes by one byte during buffer declarations. & \Shahriar &  &  &  &  & \\
	S2UCP &  & function calls & The S2UCP replaces the \texttt{strncpy} function with the \texttt{strcpy} function. This class of operators replaces safe ANSI library function calls with unsafe function calls. & \Shahriar &  &  &  &  & \\
	S2UCT &  & function calls & The S2UCP replaces \texttt{strncat} with the \texttt{strcat} function. This class of operators replaces safe ANSI library function calls with unsafe function calls. & \Shahriar &  &  &  &  & \\
	S2UGT &  & function calls & The S2UCP replaces \texttt{fgets} with \texttt{gets} function. This class of operators replaces safe ANSI library function calls with unsafe function calls. & \Shahriar &  &  &  &  & \\
	S2USN &  & function calls & The S2UCP replaces \texttt{snprintf} with \texttt{sprintf} function. This class of operators replaces safe ANSI library function calls with unsafe function calls. & \Shahriar &  &  &  &  & \\
	S2UVS &  & function calls & The S2UCP replaces \texttt{vsnprintf} with \texttt{vsprintf} function. This class of operators replaces safe ANSI library function calls with unsafe function calls. & \Shahriar &  &  &  &  & \\
	FGSR &  & function calls & The FGSR operator mutates the code by replacing function calls returning scalar for a global scalar variable. & \MUSIC &  &  &  &  & \\
	FLSR &  & function calls & The FLSR operator mutates the code by replacing function calls returning scalar for a local scalar variable. & \MUSIC &  &  &  &  & \\
	FGTR &  & function calls & The FGTR operator mutates the code by replacing function calls returning structure for a global structure. & \MUSIC &  &  &  &  & \\
	FLTR &  & function calls & The FLTR operator mutates the code by replacing function calls returning structure for a local structure. & \MUSIC &  &  &  &  & \\
	FGPR &  & function calls & The FGPR operator mutates the code by replacing function calls returning pointer for a global pointer variable. & \MUSIC &  &  &  &  & \\
	FLPR &  & function calls & The FLPR operator mutates the code by replacing function calls returning pointer for a local pointer variable. & \MUSIC &  &  &  &  & \\
	FTWD &  & function calls & The FTWD operator performs function call twiddle mutations. & \MUSIC & \Mull &  &  &  & \\
	REC2M &  & memory operations & The operator REC2M replaces the \texttt{calloc()} function with the \texttt{malloc()} function. & \Milu &  &  &  &  & \\
	RMNA &  & memory operations & The RMNA operator remove \texttt{NULL} assignments. & \Milu &  &  &  &  & \\
	REDAWN &  & memory operations & The REDAWN operator replaces dynamic allocations (e.g., \texttt{malloc()}, \texttt{calloc()}, \texttt{alloca()} and \texttt{realloc()}) with \texttt{NULL} pointers. & \Milu &  &  &  &  & \\
	REDAWZ &  & memory operations & The REDAWZ replaces size of the requested block with 0 for dynamic memory allocation functions. & \Milu &  &  &  &  & \\
	REMSOTP &  & memory operations & The REMSOTP operator replaces the arguments of the \texttt{sizeof()} unary operator with the non-pointer type equivalent if a pointer type is specified. & \Milu &  &  &  &  & \\
	RESOTPE &  & memory operations & The RESOTPE operator replaces the arguments of the \texttt{sizeof()} unary operator with the pointer type equivalent if a non-pointer type is specified. & \Milu &  &  &  &  & \\
	RMFS &  & memory operations & The RMFS operator removes \texttt{free()} statements. & \Milu &  &  &  &  & \\
	REC2A &  & memory operations & The REC2A operator replaces \texttt{calloc()} with \texttt{alloca()}. & \Milu &  &  &  &  & \\
	REM2A &  & memory operations & The REM2A operator replaces \texttt{malloc()} with \texttt{alloca()}. & \Milu &  &  &  &  & \\
	RFSNS &  & strings & The RFSNS operator replaces \texttt{"\%ns"} format string with \texttt{"\%s"}. This class of operators mutate format strings of \texttt{scanf} and \texttt{printf} family functions to emulate BOF vulnerabilities in destination buffers, which are passed as arguments. & \Shahriar &  &  &  &  & \\
	RFSBO &  & strings & The RFSBO operator replaces \texttt{"\%ns"} format string with \texttt{"\%ms"}, where, \texttt{m = size} of the destination buffer plus one. This class of operators mutate format strings of \texttt{scanf} and \texttt{printf} family functions to emulate BOF vulnerabilities in destination buffers, which are passed as arguments. & \Shahriar &  &  &  &  & \\
	RFSBD &  & strings & The RFSBD operator replace \texttt{"\%ns"} format string with \texttt{"\%ms"}, where, $m$ is the size of the destination buffer plus a $\Delta$. This class of operators mutate format strings of \texttt{scanf} and \texttt{printf} family functions to emulate BOF vulnerabilities in destination buffers, which are passed as arguments. & \Shahriar &  &  &  &  & \\
	RFSIFS &  & strings & The RFSNS operator replaces \texttt{"\%ns"} format string with \texttt{"\%s"}. This class of operators mutate format strings of \texttt{scanf} and \texttt{printf} family functions to emulate BOF vulnerabilities in destination buffers, which are passed as arguments. & \Shahriar &  &  &  &  & \\
	SRWS &  & strings & The SRWS operator removes a white space in a string variable. & \MUSIC &  &  &  &  & \\
	SANL &  & strings & The SANL operator add a new line in a string variable. & \MUSIC &  &  &  &  & \\
	SCSR &  & strings & The SCSR operator mutates a string variable by replacing a string constant with a different string constant.  & \MUSIC &  &  &  &  & \\
	DirVarRepPar &  & function calls & Suppose that the interaction between function A and function B is being tested. \texttt{P(B)} is defined as the set of formal parameters of B. And \texttt{G(B)} is defined as the set of global variables accessed by B. One way to perturb the value of an interface variable, i.e., a variable in sets P or G, is to directly replace each use or definition of the variable by another variable or constant. Operators DirVarRep do so. These operators replace each occurrence of a member of sets P and G by different groups of variables and constants and any level of dereferences and indexing of variables belonging to one of these sets. They intend to perturb a value entering or exiting a function. It is important to note that only replacements between objects of compatible types are carried. & \Proteum &  &  &  &  & \\
	DirVarRepGlo &  & function calls & Variables in set G are called \emph{Globally Accessed Variables}. The DirVarRepGlo operator replaces interface variable by each element of G. & \Proteum &  &  &  &  & \\
	DirVarRepLoc &  & function calls & \texttt{L(B)} is defined as the set of variables declared in B (local variables). The DirVarRepLoc operator replaces every interface variable with each element of L. & \Proteum &  &  &  &  & \\
	DirVarRepExt &  & function calls & \texttt{E(B)} is defined as the set of global variables not accessed in B. Variables in set E are called \emph{External Variables}. The DirVarRepExt operator replaces every interface variable with each element of E. & \Proteum &  &  &  &  & \\
	DirVarRepCon &  & function calls & \texttt{C(B)} is defined as the set of constants used in B. The DirVarRepCon operator replaces every interface variable with each element of C. & \Proteum &  &  &  &  & \\
	DirVarRepReq &  & function calls & In addition, one more set R is defined; it does not depend on G. This set is the set of required constants (e.g., -1, 1, 0, MAXINT, MININT, MAXUNSIGNED). It contains some special values relevant for each data type and associated operators. The DirVarRepReq operator replaces every interface variable with each element of R. & \Proteum &  &  &  &  & \\
	IndVarRepPar &  & function calls & Another way to perturb the value of an interface variable is to change another variable or a constant that can influence its final value. The operators IndVarRep do so. They are applied at places where variables or constants in sets L and C (non-interface variables) are used. These operators are applied only in the following two situations: (1) When the variable/constant to be changed is in a return statement. (2) When a variable from sets P or G is used in the same statement of the variable/constant to be changed. The IndVarRepPar operator replaces non interface variable by each element of P. & \Proteum &  &  &  &  & \\
	IndVarRepGlo &  & function calls & The IndVarRepGlo operator replaces non interface variable by each element of G. & \Proteum &  &  &  &  & \\
	IndVarRepLoc &  & function calls & The IndVarRepLoc operator replaces non interface variable by each element of L. & \Proteum &  &  &  &  & \\
	IndVarRepExt &  & function calls & The IndVarRepExt operator replaces non interface variable by each element of E. & \Proteum &  &  &  &  & \\
	IndVarRepCon &  & function calls & The IndVarRepCon operator replaces non interface variable by each element of C. & \Proteum &  &  &  &  & \\
	IndVarRepReq &  & function calls & The IndVarRepReq operator replaces non interface variable by each element of R. & \Proteum &  &  &  &  & \\
	DirVarIncDec &  & function calls & The DirVarIncDec operator inserts a pre-decrement operator (e.g., - -) and a pre-increment operator (e.g., ++) at each reference to an interface variable, i.e., to variables that belong to the sets P and G. & \Proteum &  &  &  &  & \\
	IndVarIncDec &  & function calls & The IndVarIncDec operator adds and subtracts one from each constant reference, i.e., each reference to constant C is replaced with the expression C+1. & \Proteum &  &  &  &  & \\
	DirVarAriNeg &  & arithmetic & The DirVarAriNeg inserts an arithmetic negation operator (e.g., -) before each interface variable reference. & \Proteum &  &  &  &  & \\
	IndVarAriNeg &  & arithmetic & The IndVarAriNeg operator inserts arithmetic negation at non-interface variable uses, they are applied on elements of sets L and C. & \Proteum &  &  &  &  & \\
	DirVarLogNeg &  & logical & The DirVarLogNeg operator inserts logical negation at interface variable uses. & \Proteum &  &  &  &  & \\
	IndVarLogNeg &  & logical & The IndVarLogNeg operator inserts logical negation at non-interface variable uses, they are applied on elements of sets L and C. & \Proteum &  &  &  &  & \\
	DirVarBitNeg &  & bitwise & The DirVarBitNeg operator inserts bit negation at interface variable uses. & \Proteum &  &  &  &  & \\
	IndVarBitNeg &  & bitwise & The IndVarBitNeg operator inserts bit negation at non-interface variable uses. They are applied on elements of sets L and C. & \Proteum &  &  &  &  & \\
	RetStaDel &  & control flow & The RetStaDel operator eliminates each \texttt{return} statement in the called function, one at a time. This forces the function to continue execution when it should stop and return a value. & \Proteum &  &  &  &  & \\
	RetStaRep &  & control flow & The RetStaRep replaces the expression used in a \texttt{return} statement by all the other expressions used in other return statements in the called function, one at a time, creating one mutant for each such replacement. & \Proteum &  &  &  &  & \\
	CovAllNod &  & coverage & The CovAllNod operator assures that the test set used to test a interaction \texttt{A-B} (e.g., function \texttt{A} calling a \texttt{B} function) reaches a minimal degree of coverage for the called function for all nodes. & \Proteum &  &  &  &  & \\
	CovAllEdg &  & coverage & The CovAllEdg operator assures that the test set used to test a interaction \texttt{A-B} reaches a minimal degree of coverage for the called function for all edges. & \Proteum &  &  &  &  & \\
	ArgRepReq &  & function calls & The ArgRepReq operator replaces arguments by each element of R and is applied to each argument in the call statement. & \Proteum &  &  &  &  & \\
	ArgStcAli &  & function calls & The ArgStcAli operator switches arguments of compatible type. It changes the order of the arguments in a call. Each argument is switched with each other compatible argument. & \Proteum &  &  &  &  & \\
	ArgStcDif &  & function calls & The ArgStcDif operator switches arguments of non-compatible type. It performs the same kind of switch between arguments with non-compatible types. In C, this error is easily caught at compile time, if the arguments have non-compatible types. & \Proteum &  &  &  &  & \\
	ArgDel &  & function calls & The ArgDel operator deletes each argument, one at each time. & \Proteum &  &  &  &  & \\
	ArgAriNeg &  & arithmetic & The ArgAriNeg operator inserts an arithmetic negation before each argument. & \Proteum &  &  &  &  & \\
	ArgLogNeg &  & logical & The ArgLogNeg operator inserts a logical negation for each argument. & \Proteum &  &  &  &  & \\
	ArgBitNeg &  & bitwise & The ArgBitNeg operator inserts a bit negation before each argument & \Proteum &  &  &  &  & \\
	FunCalDel &  & function calls & The FunCalDel operator eliminates the call to the function \texttt{G} in the interaction \texttt{F-G}. & \Proteum &  &  &  &  & \\
	AMC &  & encapsulation & The AMC operator replaces each access control modifier in a program by each other modifier. &  &  & \MuJava &  &  & \\
	IHI &  & inheritance & A child class can override a variable declared in an ancestor by declaring a new variable with the same name and type. The new variable is called a hiding variable. The IHI operator inserts hiding variable declarations. & \MuCPP &  & \MuJava &  &  & \\
	IHD &  & inheritance & The IHD operator deletes hiding variable declarations. & \MuCPP &  & \MuJava &  &  & \\
	IOD &  & inheritance & The IOD operator deletes methods that override methods in a class’ parent to ensure that the method invocation actually invokes the intended method. If the overriding method is exactly the same as the method it overrides, the IOD operator generates an equivalent mutant. & \MuCPP &  & \MuJava, \jMINT &  &  & \\
	IOP &  & inheritance & The IOP (overriding method calling position change) operator simulates the error that often occurs when calling a method of a base class, which is overridden in the child class, at the wrong time, producing an undesired state. & \MuCPP &  & \MuJava &  &  & \\
	IOR &  & inheritance & When a method \texttt{f()} in a child class overrides method \texttt{f()} in the parent class, the IOR mutation operator changes the name of the method in the parent, including all references to the method in the parent. This means that the child class no longer overrides the method. & \MuCPP &  & \MuJava &  &  & \\
	ISI &  & inheritance & If a sub-class hides a variable or method of one of its ancestors, it can still reference the hidden member by using the \texttt{super} keyword. The subclass can also use \texttt{super} to invoke a parents version of a method that has been overridden. The ISI operator inserts the \texttt{super} keyword when possible. & \MuCPP &  & \MuJava &  &  & \\
	ISD &  & inheritance & The ISD operator deletes occurrences of \texttt{super}. & \MuCPP &  & \MuJava &  &  & \\
	IPC &  & inheritance & The IPC operator deletes an explicit call of a parent's constructor. & \MuCPP &  & \MuJava, \ILMutator, \jMINT &  &  & \\
	IMR &  & inheritance & When a derived class inherits from two or more classes, it may occur that those base classes have member variables with the same name or methods with the same signature. Thus, the programmer can be mistaken when referencing a certain inherited member. The IMR (multiple inheritance replacement) operator simulates this potential mistake.  & \MuCPP &  &  &  &  & \\
	JTI/CTI &  & language-specific features & The JTI/CTI operators mutate the code by inserting the keyword \texttt{this}. & \MuCPP &  & \MuJava, \jMINT &  &  & \\
	JTD/CTD &  & language-specific features & The JTI/CTI operators mutate the code by deleting the keyword \texttt{this}. & \MuCPP &  & \MuJava, \jMINT &  &  & \\
	JID/CID &  & language-specific features & The JID/CID operators remove the initial value given to member variables, checking thereby that the proposed initialisation is correct. Initial values are assigned in the constructors, either in the body or using initialisation lists. Thus, if the initialisation is within the body of the constructor, the assignment statement is deleted, while, if it is within the initialisation list, then that element is removed from the list. & \MuCPP &  & \MuJava, \ILMutator, \jMINT &  &  & \\
	JDC/CDC &  & language-specific features & The JDC/CDC operators create the default constructor if a class contains no constructors. It forces the creation by deleting the implemented default constructor. & \MuCPP &  & \MuJava, \ILMutator &  &  & \\
	EOC &  & language-specific features & The EOC (reference comparison and content comparison replacement) operator swaps occurrences of method \texttt{equals()} used for variable comparison with usage of operator '==' and vice versa. &  &  & \MuJava, \ILMutator &  &  & \\
	CDD &  & language-specific features & C++ enables the programmer to define not only how the objects are constructed, but also how they are destroyed. If a destructor is not specified, the compiler automatically provides one. The CDD operator deletes the destructor checking its correct implementation. & \MuCPP &  &  &  &  & \\
	CCA &  & language-specific features & The task of copying objects is accomplished through the definition of a copy constructor and, usually, the assignment operator overloading (when they are not defined, the compiler provides them automatically). The CCA operator deletes the defined copy constructor or the assignment operator overloading, to verify if they are correctly implemented. & \MuCPP &  &  &  &  & \\
	JSI &  & language-specific features & The JSI operator mutates the code by inserting the keyword \texttt{static}. &  &  & \MuJava &  &  & \\
	JSD &  & language-specific features & The JSI operator mutates the code by deleting the keyword \texttt{static}. &  &  & \MuJava &  &  & \\
	EOA &  & language-specific features & The EOA (reference assignment and content assignment replacement) operator replaces an assignment of a pointer reference with a copy of the object, using the Java convention of a \texttt{clone()} method. The \texttt{clone()} method duplicates the contents of an object, creating and returning a reference to a new object. &  &  & \MuJava &  &  & \\
	EAM &  & language-specific features & The EAM operator replaces an accessor method name with other compatible accessor method names, where compatible means that the signatures are the same.  &  &  & \MuJava, \jMINT &  &  & \\
	EMM &  & language-specific features & The EMM operator does the same as EAM, except it works with modifier methods instead of accessor methods. &  &  & \MuJava &  &  & \\
	OMR &  & method overloading & The OMR (overloading method contents replace) operator substitutes a body of an overloaded method having some parameters with a calling of an overloaded method with a less number of parameters. & \MuCPP &  & \MuJava, \ILMutator, \jMINT &  &  & \\
	OMD &  & method overloading & The OMD (overloading method deletion) operator deletes overloading method declarations. & \MuCPP &  & \MuJava, \jMINT &  &  & \\
	OAC &  & method overloading & The OAC (arguments of overloading method call change) operator changes the order or the number of the arguments in method invocations, but only if there is an overloading method that can accept the new argument list. If there is one, the OAC operator causes a different method to be called, thus checking for a common fault in the use of overloading. &  &  & \MuJava &  &  & \\
	OAN &  & method overloading & The OAN operator mutates the number of arguments in method invocations of overloaded methods. & \MuCPP &  &  &  &  & \\
	OAO &  & method overloading & The OAO operator mutates the code by changing the order of the arguments in method invocations of overloaded methods. & \MuCPP &  &  &  &  & \\
	MCO &  & object and member replacement & When an object member variable is referenced and calls a method, the MCO operator replaces that reference to the object with another variable of the same class type (the invoked method is not changed). & \MuCPP &  &  &  &  & \\
	MCI &  & object and member replacement & This operator is similar to MCO in the sense that it makes that a method is invoked from a different object, but now the objects are from different class types, both having the same base class. & \MuCPP &  &  &  &  & \\
	PNC &  & polymorphism & The PNC operator adds a new method call with child class type. & \MuCPP &  & \MuJava, \ILMutator, \jMINT &  &  & \\
	PMD &  & polymorphism & The PMD operator modifies a member variable declaration with a parent class type. & \MuCPP &  & \MuJava &  &  & \\
	PPD &  & polymorphism & The PPD operator modifies a parameter variable declaration with a child class type & \MuCPP &  & \MuJava &  &  & \\
	PCI &  & polymorphism & The PCI operator changes the actual type of an object reference to the parent or to the child of the original declared type. The mutant will trigger different behavior when the object to be cast has hiding variables or overriding methods. & \MuCPP &  & \MuJava &  &  & \\
	PCD &  & polymorphism & The PCD operator deletes type casting operators; the inverse of PCI. & \MuCPP &  & \MuJava &  &  & \\
	PCC &  & polymorphism & The PCC operator changes the type to which an object reference is being cast. The new type must be in the type hierarchy of the declared type, that is, a valid cast. & \MuCPP &  & \MuJava &  &  & \\
	PRV &  & polymorphism & The PRV operator replaces a reference assignment with other comparable variable. &  &  & \MuJava, \jMINT &  &  & \\
	L2F &  & higher-order & This operator uses a list of $n$ first order mutants (FOM) to generate second order mutants (SOM). This is achieved through the combination of the first FOM in the list with the last FOM in the list and so on. &  &  & \MuJava &  &  & \\
	DiffOp &  & higher-order & This operator generates SOMs by combining two FOMs, each FOM should be created using a different mutation operator. &  &  & \MuJava &  &  & \\
	RMix &  & higher-order & This operator combines any two randomly selected FOMs to generate a SOM. &  &  & \MuJava &  &  & \\
	F2L &  & higher-order & This operator orders FOMs according to their respective statement appearance in the objective source code. The mutant pairs are then constructed based on the combination of the first with the last mutant, the second mutant with the second last one, and so on. & \Proteum &  &  &  &  & \\
	SNode &  & higher-order & This operator combines mutants by selecting them from the same basic block. & \Proteum &  &  &  &  & \\
	SUnit &  & higher-order & This operator selects the mutant pairs from the same program unit, in order to generate a SOM. & \Proteum &  &  &  &  & \\
	SU\_F2Last &  & higher-order & This operator selects candidate mutants based on the use of the \emph{F2L} approach by applying them individually to each program unit. & \Proteum &  &  &  &  & \\
	SU\_DiffOp &  & higher-order & This operator selects candidate mutants based on the use of the \emph{DiffOp} approach by applying them individually to each program unit. & \Proteum &  &  &  &  & \\
	NeighPair &  & higher-order & This operator combines FOMs which are as close to each other as possible, i.e., a list of mutation points for FOMs is created and neighbouring pairs are selected to construct SOMs. The number of generated SOMs is, thus, reduced by half. &  &  & \Judy &  &  & \\
	JudyDiffOp &  & higher-order & This operator works similar as \emph{DiffOp} but it does not create SOMs from two consecutive FOMs, if the latter involve the same operator. &  &  & \Judy &  &  & \\
	Greedy &  & higher-order & By using this operator, an initial FOM is chosen at random as a starting point. Subsequently, the normal greedy algorithm process is performed to incrementally augment with additional the correct solution FOMs. An archive operation is used to store the HOM found. The overall algorithm is iterated with repeated randomized initial position, much like a random-restart hill climbing algorithm. The fitness function measures the ease with which the S/HOM can be killed. & \Milu &  &  &  &  & \\
	Genetic Algorithm &  & higher-order & This operator proposes the use of a genetic algorithm. Each gene of a chromosome represents the position and possible types of mutation operators, and in additional to crossover and mutation operators, an archive operator is used to store the HOMs found. The fitness function measures the ease with which the S/HOM can be killed. & \Milu &  &  &  &  & \\
	Hill Climbing &  & higher-order & The process starts from random initial solution (a FOM). By comparing the current solution and its neighbour solutions' fitness, the greater one becomes the new current solution, until the fitness cannot be further improved. The algorithm is based on a random-restart hill climbing algorithm, which chooses a random starting solution for each run. The fitness function measures the ease with which the S/HOM can be killed. & \Milu &  &  &  &  & \\
	TFLD &  & system-configuration & The TFLD operator removes a line of a text in a configuration file. &  &  & \BacterioSystem &  &  & \\
	TFLI &  & system-configuration & The TFLI operator inserts an empty line into a configuration file. &  &  & \BacterioSystem &  &  & \\
	TFALD &  & system-configuration & The TFALD operator removes all lines from configuration file. &  &  & \BacterioSystem &  &  & \\
	CNVI &  & system-configuration & The CNVI operator interchanges a component of the system with a new version of the same component. &  &  & \BacterioSystem &  &  & \\
	COVI &  & system-configuration & The COVI operator interchanges a component of the system with an old version of the same component. &  &  & \BacterioSystem &  &  & \\
	CPVI &  & system-configuration & The CPVI operator interchanges the value of two configuration parameters with compatible types. &  &  & \BacterioSystem &  &  & \\
	CPDV &  & system-configuration & The CPDV operator changes the value of a configuration parameter to the default value. &  &  & \BacterioSystem &  &  & \\
	CMCR &  & system-level & The CMCR operator belongs to the sequences of interactions category, in particular replace a method call by another compatible method call of the same called class. &  &  & \BacterioSystem &  &  & \\
	MOR &  & system-level & The MOR operator belongs to the sequences of interactions category, in particular replaces the call to a method by the call to another overloaded method. &  &  & \BacterioSystem &  &  & \\
	COI &  & system-level & The COI operator belongs to the sequences of interactions category, in particular interchanges two calls made in the body of a method. &  &  & \BacterioSystem &  &  & \\
	GCPI &  & system-level & The GCPI operator interchanges the position of two graphical components. &  &  & \BacterioSystem &  &  & \\
	GOCOC &  & system-level & The GOCOC operator changes the order of the elements of a graphical ordered element. &  &  & \BacterioSystem &  &  & \\
	CGD &  & system-level & The CGD operator removes a graphical component of the graphical user interface. &  &  & \BacterioSystem &  &  & \\
	DGCM &  & system-level & The DGCM operator converts an enabled component into a disable one. &  &  & \BacterioSystem &  &  & \\
	BTW &  & SQL clauses & In the BTW (between predicate) mutation, each condition in the form a \texttt{BETWEEN} x \texttt{AND} y is replaced (1) by a > x \texttt{AND} a <=y and (2) by a >= x \texttt{AND} a < y. If the condition is \texttt{NOT BETWEEN}, the mutants are negated. &  &  &  &  & \TuyaSQL & \\
	LKE &  & SQL clauses & The possible combinations of string conditions in the form \texttt{a LIKE s} are infinite, since \texttt{s} is a search pattern. Therefore, the mutations will be restricted to exercising the behaviour of the wildcards \{\%,\_\} (the percent symbol means for any character string and the underscore means for an individual character). In the LKE (like predicate) mutation each occurrence of a wildcard is mutated by (1) removing the wildcard, (2) replacing the wildcard by the other, (3) removing the character just before the wildcard if it is not at the beginning of s and (4) removing the character just after the wildcard if it is not at the end of s. (5) If no wildcard is present at the beginning of s, then add each of the wildcards at the beginning, and (6) if no wildcard is present at the end of s then add each of the wildcards at the end. &  &  &  &  & \TuyaSQL & \\
	SEL &  & SQL clauses & The SEL (select clause) operator, with this mutation operator, each occurrence of one of the \texttt{SELECT} or \texttt{SELECT DISTINCT} keywords is replaced with the other. &  &  &  &  & \TuyaSQL & \\
	JOI &  & SQL clauses & JOI (join clause) operator. In the mutation, each occurrence of a join-type keyword (\texttt{INNER JOIN}, \texttt{LEFT OUTER JOIN}, \texttt{RIGHT OUTER JOIN}, \texttt{FULL OUTER JOIN}, \texttt{CROSS JOIN}) is replaced with each of the others. When a join-type is replaced with \texttt{CROSS JOIN}, the search-conditions under the \texttt{ON} keyword are removed. When \texttt{CROSS JOIN} is replaced with another join-type, an \texttt{ON} clause is added and its corresponding join-condition is created based on the primary keys of the joined tables. &  &  &  &  & \TuyaSQL & \\
	SUB &  & SQL clauses & Subqueries are normally used in predicates by following the general form $e\:R\:p(Q)$, where $e$ is the row value constructor (usually an attribute or expression), $R$ is a relational operator \{=,<>,<,<=,>,>=\}, $p$ is a keyword representing the predicate and $Q$ is the subquery. Three types of predicate can be formed depending on the kind of the keyword $p$ (a) Type I ($p \in$ \texttt{{ALL, ANY, SOME}}): of the form $e\:R\:p(Q)$ (b) Type II ($p \in$ \texttt{{IN, NOT IN}}): of the form $e\:p(Q)$. (c) Type III ($p \in$ \texttt{{EXISTS, NOT EXISTS}}) of the form $p(Q)$. The mutations are the following: (1) Each occurrence of a keyword in a predicate of any type is replaced with every of the other keywords of the same type except for the replacement of \texttt{ANY} by \texttt{SOME}, as these have the same semantic meaning. (2) Additional replacements are made depending on the keyword type: (a) Each type I keyword is (i) replaced with every of the type II keywords and then the relational operator is removed, (ii) replaced with every of the type III keywords and then both the relational operator and the row value constructor are removed. The operator does not replace neither \texttt{=SOME} with \texttt{IN} nor \texttt{<> ALL} with \texttt{NOT IN} because they have the same meaning. (b) Each type II keyword is (i) replaced with all the combinations of each type I keywords and relational operators and (ii) replaced with every of the type III keywords and then the row value constructor is removed. The operator does not replace either \texttt{{IN}} with \texttt{{=SOME}} nor \texttt{{NOT IN}} with \texttt{{<> ALL}} because they have the same meaning. (c) Each type III keyword is replaced with another. &  &  &  &  & \TuyaSQL & \\
	GRU &  & SQL clauses & The GRU (groupings) operator performs SQL clauses mutations, with this mutation operator, each of the group-by-expressions is removed. If the removed expression in the \texttt{GROUP BY} is present in the select-list or in the order-by-list, this expression must be enclosed in an aggregate function to avoid a syntactically wrong query. In this case, two mutants are generated for each of the expressions, one using the MIN and the other using the MAX aggregate functions. If there is only one group-by-expression, then the whole clause is removed. &  &  &  &  & \TuyaSQL & \\
	AGR &  & SQL clauses & The AGR (aggregate functions) operator performs SQL clauses mutations, with this mutation operator, each occurrence of one of the aggregate functions (\texttt{MAX, MIN, AVG, AVG(DISTINCT), SUM, SUM(DISTINCT), COUNT, COUNT (DISTINCT)}) in a select-list or having-list is replaced with each of the others. Replacement must take into account the data type of the function argument. If the data type is \texttt{character}, then \texttt{AVG} and \texttt{SUM} are excluded from the replacement. Also, if the data type is character and the aggregate function belongs to a \texttt{HAVING} clause, then the \texttt{COUNT} function is not mutated if it participates in a comparison with a numeric expression. &  &  &  &  & \TuyaSQL & \\
	UNI &  & SQL clauses & The UNI (query concatenation) operator performs SQL clauses mutations, with this mutation operator, (1) each occurrence of one of the union keywords (\texttt{UNION, UNION ALL}) is replaced with the other keyword. (2) Each of the queries that participate in the union is removed. &  &  &  &  & \TuyaSQL & \\
	ORD &  & SQL clauses & The ORD (ordering of the result set) operator performs SQL clauses mutations, with this mutation operator, for each occurrence of an order-by-expression (1) the direction of ordering is changed by replacing each of the keywords (\texttt{ASC, DESC}) by the other. If neither of these keywords is present, \texttt{DESC} is added. (2) Remove each of the order-by-expressions (if there is only one order-by-expression, then the entire clause is removed), and (3) exchange each pair of adjacent order- by-expressions. &  &  &  &  & \TuyaSQL & \\
	NLF &  & SQL NULL operators & In the NLF (null check predicates) mutation, each occurrence of one of the predicates \texttt{IS NULL} or \texttt{IS NOT NULL} is replaced with the other. &  &  &  &  & \TuyaSQL & \\
	NLS &  & SQL NULL operators & The NLS (null in select list) operator replaces each column reference $c$ in the select-list with a function \texttt{ifnull}$(c, r)^2$ that substitutes a value $c$ by $r$ ($r$ is a replacement value outside of the domain of $c$) when a null value is encountered in $c$. The column reference is not mutated if all the attributes involved in it are declared \texttt{NOT NULL} by the database schema. &  &  &  &  & \TuyaSQL & \\
	NLI &  & SQL NULL operators & The NLI (include nulls) operator forces a true value of the condition when there is a null value. &  &  &  &  & \TuyaSQL & \\
	IRC &  & SQL replacement operators & In the IRC (column replacement) mutation, each column reference is replaced with all of the other column references, constants and parameters that are present in the query and are type compatible. &  &  &  &  & \TuyaSQL & \\
	IRT &  & SQL replacement operators & In the IRT (constant replacement) mutation, each constant is replaced with all of the other constants, columns and parameters that are present in the query and are type compatible. &  &  &  &  & \TuyaSQL & \\
	IRP &  & SQL replacement operators & In the IRP (parameter replacement) mutation, each query parameter reference is replaced with all of the other parameters, columns and constants that are present in the query and are type compatible. &  &  &  &  & \TuyaSQL & \\
	IRH &  & SQL replacement operators & The aim of the IRH (hidden column replacement) operator is to detect potential errors produced when many similar columns appear in the same table and test cases have not enough diversity in their values to detect the use of a wrong column name. Each column attribute reference is replaced with all of the other columns that are defined in its table provided that they have not been the replacement in any of the other IR operators and are type compatible. &  &  &  &  & \TuyaSQL & \\
	PTCR &  & SQL replacement operators & The PTCR (participation constraint replacement) operator toggles the participation requirements of entity types in the relation. &  &  &  &  & \SQLChan & \\
	CDCR &  & SQL replacement operators & The CDCR (cardinality constraint replacement) replaces the cardinalities of entity types in the relation. &  &  &  &  & \SQLChan & \\
	IWKR &  & SQL replacement operators & The IWKR (identifying/weak entity type replacement) operator replaces (an expression of) identifying type(s) by (an expression of) weak entity type(s), or vice versa. &  &  &  &  & \SQLChan & \\
	ATTR &  & SQL replacement operators & The ATTR (attribute replacement) operator replaces (an expression on) attribute(s) by (an expression on) other attribute(s) of a compatible type. &  &  &  &  & \SQLChan & \\
	GSCR &  & SQL replacement operators & The GSCR (generalization/specialization completeness replacement) operator replaces an expression on a partial superclass by an expression on a subclass and the negation form of the superclass &  &  &  &  & \SQLChan & \\
	GSDR &  & SQL replacement operators & The GSDR (generalization/specialization disjointness replacement) operator replaces (an expression on) sibling entity type(s) by (an expression on) other sibling entity type(s) under the same superclass. &  &  &  &  & \SQLChan & \\
	UTCR &  & SQL replacement operators & The UTCR (union type completeness replacement) operator replaces an entity type by a subclass and/or superclasses of the subclass, such that these superclasses have the same union type constraint. &  &  &  &  & \SQLChan & \\
	RMWH &  & SQL WHERE operators & The RMWH (remove \texttt{WHERE} keywords and conditions) operator removes where conditions of SQL queries, which results in selecting all rows form tables. &  &  &  &  & \MUSICShahriar & \\
	NEGC &  & SQL WHERE operators & The NEGC operator negates unit expressions (e.g., uid=’aaa’ to uid!=’aaa’) present in where conditions of SQL queries. The operator is applicable for \texttt{SELECT}, \texttt{UPDATE}, and \texttt{DELETE} type queries. &  &  &  &  & \MUSICShahriar & \\
	FADP &  & SQL WHERE operators & The FADP operator parenthesizes the where condition of a SQL query and prepend ‘false and’ after the \texttt{WHERE} keyword. The objective is to nullify any output generated by the execution of an intended query in case of non attack test cases. &  &  &  &  & \MUSICShahriar & \\
	UNPR &  & SQL WHERE operators & The UNPR operator makes SQL queries syntactically incorrect to the database engine by appending left parenthesis at the beginning of where condition. &  &  &  &  & \MUSICShahriar & \\
	MQFT &  & function calls & The MQTF operator injects \emph{SQLIV} (SQL Injection Vulnerability) by setting multiple query flag values to true. &  &  &  &  & \MUSICShahriar & \\
	OVCR &  & function calls & The commit and rollback options are used to maintain the information consistency in database tables. The OVCR operator is used to override the commit and rollback flag to allow \emph{SQLIV}, which can be exploited by creating the state of inconsistencies in databases with appropriate \emph{SQLIAs} (SQL Injection Attacks). &  &  &  &  & \MUSICShahriar & \\
	SMRZ &  & function calls & Database manipulation APIs often enable developers to specify the maximum number of records that can be returned by the result sets after executing \texttt{SELECT} type SQL queries. The SMRZ operator will set this value to zero in order to make the database return the maximum number of records. &  &  &  &  & \MUSICShahriar & \\
	SQDZ &  & function calls & There are delays between issuing database queries and receiving results from the database. Programmers can specify the maximum delay (or query timeout value) with supported database API method calls. The SQDZ operator makes the delay to infinite as a way of injecting \emph{SQLIV}. The operator forces to generate test cases that exploit SQLIV by performing time-based attacks to infer execution paths of applications. &  &  &  &  & \MUSICShahriar & \\
	OVEP &  & function calls & The database manipulation API provides developers the option to allow escape character processing. The OVEP operator modifies the flag responsible for processing escape characters. It toggles the flag value and forces the generation of test cases incorporating both escape and non escape characters. The operator generates mutants that can be distinguished in the presence of piggybacked query or union type attacks. &  &  &  &  & \MUSICShahriar & \\
	EAI &  & ADA expressions & The EAI operator inserts the unary operator \texttt{ABS} in front of every arithmetic expression and subexpression. Do not mutate if the expression can be statically determined to be greater than or equal to zero. &  &  &  & \OffuttADA &  & \\
	ENI &  & ADA expressions & The ENI operator inserts \texttt{ABS} in front of every arithmetic expression and subexpression. Do not mutate if the expression can be statically determined to be less than or equal to zero.  &  &  &  & \OffuttADA &  & \\
	EEZ &  & ADA expressions & The EEZ operator inserts the subprogram \texttt{Except\_on\_Zero} in front of every arithmetic expression and subexpression. \texttt{Except\_on\_Zero(E);} raises \texttt{EEZ\_Exception} if E is 0, else it returns E. Do not mutate if the expression can be statically determined to be not equal to 0. &  &  &  & \OffuttADA &  & \\
	EOR &  & ADA expressions & The EOR operator replaces each binary arithmetic operator (+; -; *; /; \texttt{MOD}, \texttt{REM}, **) with each other binary arithmetic operator that is syntactically legal. &  &  &  & \OffuttADA &  & \\
	ERR &  & ADA expressions & The ERR operator replaces each relational operator with each other relational operator that is syntactically legal. The operators <; >; >=; <= are only defined for scalar and discrete array types. &  &  &  & \OffuttADA &  & \\
	EMR &  & ADA expressions & The EMR operator replaces each \texttt{IN} operator with \texttt{NOT IN} and viceversa. &  &  &  & \OffuttADA &  & \\
	ELR &  & ADA expressions & The ELR operator replaces each logical operator (i.e., \texttt{AND, OR, XOR, AND THEN, OR ELSE}) with each other logical operator. \texttt{AND, OR, and XOR} are defined for Boolean expressions and one-dimensional arrays of type Boolean. &  &  &  & \OffuttADA &  & \\
	EUI &  & ADA expressions & The EUI operator inserts the unary operator - in front of each arithmetic expression and subexpression. Note: the unary operator + is the identity operation. &  &  &  & \OffuttADA &  & \\
	EUR &  & ADA expressions & The EUR operator replaces each unary operator (+; -; \texttt{ABS}) with each other unary operator. Expressions should be fully parenthesized, since \texttt{ABS} has higher precedence than + and -. &  &  &  & \OffuttADA &  & \\
	ESR &  & ADA expressions & The ESR operator replaces each function and subroutine name with each other function or subroutine name that has the same syntactic signature and comes from the same package. It also replaces functions/subroutines with "=" and "= =" if the signature is appropriate (please note that "=" and "= =" are implicitly defined for all types). It does not consider the parameter class in the signature comparison. &  &  &  & \OffuttADA &  & \\

	EDT &  & ADA expressions & By using the EDT operator, each innermost expression (i.e., operand, constant, variable, array reference, record reference, pointer reference) is twiddled, that is, modified by a small amount. For each operand, the modification produces two mutants, one where the modification is in a positive direction, the other in a negative direction. &  &  &  & \OffuttADA &  & \\
	EAR &  & ADA expressions & By using the EAR operator, each attribute is replaced with another syntactically legal attribute. &  &  &  & \OffuttADA &  & \\
	EEO &  & ADA expressions & The EEO operator inserts the subprogram \texttt{Except\_on\_OverFlow} in front of every arithmetic expression. \texttt{Except\_on\_OverFlow(E)} raises \texttt{EEO\_Exception} if the expression results in an overflow, else it returns the value of the expression. Do not mutate if the expression can be statically determined to not overflow. &  &  &  & \OffuttADA &  & \\
	EEU &  & ADA expressions & The EEU operator inserts the subprogram \texttt{Except\_on\_UnderFlow} in front of every arithmetic expression. \texttt{Except\_on\_UnderFlow(E)} raises \texttt{EEU\_Exception} if the expression results in an underflow, else it returns the value of the expression. Do not mutate if the expression can be statically determined to not underflow. &  &  &  & \OffuttADA &  & \\
	OVV &  & ADA operands & The OVV operator performs operand replacement mutations, particularly variables are replaced with a different variable. &  &  &  & \OffuttADA &  & \\
	OVC &  & ADA operands & The OVC operator performs operand replacement mutations, particularly variables are replaced with a constant. &  &  &  & \OffuttADA &  & \\
	OVA &  & ADA operands & The OVA operator performs operand replacement mutations, with this mutation operator, variables are replaced with an array reference. &  &  &  & \OffuttADA &  & \\
	OVR &  & ADA operands & The OVR operator performs operand replacement mutations, with this mutation operator, variables are replaced with a record reference. &  &  &  & \OffuttADA &  & \\
	OVP &  & ADA operands & The OVP operator performs operand replacement mutations, with this mutation operator, variables are replaced with a pointer reference. &  &  &  & \OffuttADA &  & \\
	OVI &  & ADA operands & The OVI operator performs operand replacement mutations, the mutation eliminates the initialization part of each variable initialization. &  &  &  & \OffuttADA &  & \\
	OCV &  & ADA operands & The OCV operator performs operand replacement mutations, with this mutation operator, constants are replaced with a variable. &  &  &  & \OffuttADA &  & \\
	OCC &  & ADA operands & The OCC operator performs operand replacement mutations, with this mutation operator, constants are replaced with a different constant. &  &  &  & \OffuttADA &  & \\
	OCA &  & ADA operands & The OCA operator performs operand replacement mutations, with this mutation operator, constants are replaced with an array reference. &  &  &  & \OffuttADA &  & \\
	OCR &  & ADA operands & The OCR operator performs operand replacement mutations, with this mutation operator, constants are replaced with a record reference. &  &  &  & \OffuttADA &  & \\
	OCP &  & ADA operands & The OCP operator performs operand replacement mutations, with this mutation operator, constants are replaced with a pointer reference. &  &  &  & \OffuttADA &  & \\
	OAV &  & ADA operands & The OAV operator performs operand replacement mutations, with this mutation operator, array references are replaced with a variable. &  &  &  & \OffuttADA &  & \\
	OAC &  & ADA operands & The OAC operator performs operand replacement mutations, with this mutation operator, array references are replaced with a constant. &  &  &  & \OffuttADA &  & \\
	OAA &  & ADA operands & The OAA operator performs operand replacement mutations, with this mutation operator, array references are replaced with an array reference. &  &  &  & \OffuttADA &  & \\
	OAR &  & ADA operands & The OAR operator performs operand replacement mutations, with this mutation operator, array references are replaced with a record reference. &  &  &  & \OffuttADA &  & \\
	OAP &  & ADA operands & The OAP operator performs operand replacement mutations, with this mutation operator, array references are replaced with a pointer reference. &  &  &  & \OffuttADA &  & \\
	OAN &  & ADA operands & The OAN operator performs operand replacement mutations, the mutation replaces just the array name in an array reference by other array names when the base types are the same, and the index types are the same. &  &  &  & \OffuttADA &  & \\
	ORV &  & ADA operands & The ORV operator performs operand replacement mutations, with this mutation operator, record references are replaced with a variable. &  &  &  & \OffuttADA &  & \\
	ORC &  & ADA operands & The ORC operator performs operand replacement mutations, with this mutation operator, record references are replaced with a constant. &  &  &  & \OffuttADA &  & \\
	ORA &  & ADA operands & The ORA operator performs operand replacement mutations, with this mutation operator, record references are replaced with an array reference. &  &  &  & \OffuttADA &  & \\
	ORR &  & ADA operands & The ORR operator performs operand replacement mutations. &  &  &  & \OffuttADA &  & \\
	ORP &  & ADA operands & The ORP operator performs operand replacement mutations, with this mutation operator, record references are replaced with a pointer reference. &  &  &  & \OffuttADA &  & \\
	ORF &  & ADA operands & The ORF operator performs operand replacement mutations, the mutation replaces a record field reference by another field name of the same record when the second field is of the same type. &  &  &  & \OffuttADA &  & \\
	ORN &  & ADA operands & The ORN operator performs operand replacement mutations, the mutation replaces just the record name in a record reference by other record names when the field names and types are the same. &  &  &  & \OffuttADA &  & \\
	OPV &  & ADA operands & The OPV operator performs operand replacement mutations, with this mutation operator, pointer references are replaced with a variable. &  &  &  & \OffuttADA &  & \\
	OPC &  & ADA operands & The OPC operator performs operand replacement mutations, with this mutation operator, pointer references are replaced with a constant. &  &  &  & \OffuttADA &  & \\
	OPA &  & ADA operands & The OPA operator performs operand replacement mutations, with this mutation operator, pointer references are replaced with an array reference. &  &  &  & \OffuttADA &  & \\
	OPR &  & ADA operands & The OPR operator performs operand replacement mutations, with this mutation operator, pointer references are replaced with a record reference. &  &  &  & \OffuttADA &  & \\
	OPP &  & ADA operands & The OPP operator performs operand replacement mutations, with this mutation operator, pointer references are replaced with a pointer reference. &  &  &  & \OffuttADA &  & \\
	OPN &  & ADA operands & The OPN operator performs operand replacement mutations, the mutation replaces just the pointer name in a pointer reference by other pointer names when the field names and types are the same. &  &  &  & \OffuttADA &  & \\
	TEM &  & ADA tasking & By using the TEM operator, each \texttt{ENTRY} call is modified just as procedure calls are modified by the ESR operator. The operator replaces each \texttt{ENTRY} call name with each other \texttt{ENTRY} name that has the same syntactic signature and comes from the same task. Also, it replaces conditional and timed entry calls with simple entries. &  &  &  & \OffuttADA &  & \\
	TAR &  & ADA tasking & The TAR operator, replaces entry names by other visible entries with the same scheduling time. &  &  &  & \OffuttADA &  & \\
	TSA &  & ADA tasking & By using the TSA operator, each \texttt{SELECT} alternative is modified in the same way the \texttt{CASE} statement is modified by the SCA operator. First, each \texttt{SELECT} statement alternative with multiple choices is separated into alternatives where each alternative contains only one choice. Next, the TSA operator replaces each statement sequence with each other sequence in the \texttt{SELECT} statement. &  &  &  & \OffuttADA &  & \\
	CDE &  & coverage & By using the CDE operator, each decision must evaluate to both \texttt{TRUE} and \texttt{FALSE}. The operator replaces each decision by \texttt{TRUE} and \texttt{FALSE}. &  &  &  & \OffuttADA &  & \\
	CCO &  & coverage & By using the CCO operator, each condition must evaluate to both \texttt{TRUE} and \texttt{FALSE}. The operator replaces each condition by \texttt{TRUE} and \texttt{FALSE}. &  &  &  & \OffuttADA &  & \\
	CDC &  & coverage & The CDC operator combines the decision/condition coverage criteria of \texttt{CCO} and \texttt{CDE}. &  &  &  & \OffuttADA &  & \\
	CMC &  & coverage & By using the CMC operator, all combinations of conditions must be exercised separately. Another way of stating the \texttt{MCC} requirement is that the entire truth table for the decision must be covered. &  &  &  & \OffuttADA &  & \\
	SEE &  & statements & The SEE operator replaces the first statement in each basic block with \texttt{RAISE mut\_trap}. The \texttt{mut\_trap} is a mutation-defined exception. &  &  &  & \OffuttADA &  & \\
	SRN &  & statements & The SRN operator replaces each statement with \texttt{NULL}. &  &  &  & \OffuttADA &  & \\
	SRR &  & statements & The SRR operator replaces each statement in a function or procedure with a \texttt{return} statement. &  &  &  & \OffuttADA &  & \\
	SGL &  & statements & The SGL operator replaces each \texttt{GOTO} label with all other visible, legal labels. &  &  &  & \OffuttADA &  & \\
	SRE &  & statements & The SRE operator replaces statements within loops with \texttt{EXIT} statements. There are three variations. (a) Replace each statement in a loop with \texttt{EXIT;} (b) Replace each statement in a loop with an \texttt{EXIT name;} for each named enclosing loop. (c) Replace each statement in a loop with each \texttt{EXIT WHEN ...;} that appears in the loop. &  &  &  & \OffuttADA &  & \\
	SWR &  & statements & The SWR operator replaces \texttt{WHILE} with \texttt{repeat-until}. &  &  &  & \OffuttADA &  & \\
	SRW &  & statements & The SRW operator replaces \texttt{repeat-until} with \texttt{WHILE}. &  &  &  & \OffuttADA &  & \\
	SZI &  & statements & The SZI operator bypasses loops entirely. &  &  &  & \OffuttADA &  & \\
	SOI &  & statements & The SOI operator cause the loop to iterate once. &  &  &  & \OffuttADA &  & \\
	SNI &  & statements & The SNI operator cause the loop to be iterated $N$ times. &  &  &  & \OffuttADA &  & \\
	SRI &  & statements & The SRI operator cause the loop to be executed in reverse. &  &  &  & \OffuttADA &  & \\
	SES &  & statements & The SES operator moves each \texttt{END} statement up and down one statement. This applies to \texttt{END} statements occurring in \texttt{BLOCK} and \texttt{LOOP} statements, but not \texttt{CASE} statements and subprograms. &  &  &  & \OffuttADA &  & \\
	SCA &  & statements & The SCA operator replaces \texttt{CASE} alternatives. First, each case statement alternative with multiple choices is separated into alternatives where each alternative contains only one choice. A range (e.g., 5...20) is considered to be only one choice. Next, substitute each statement sequence with each other sequence in the \texttt{CASE} statement. &  &  &  & \OffuttADA &  & \\
	SER &  & statements & By using the SER operator, for each explicit \texttt{RAISE} statement, the operator replaces the name of the exception by other exceptions. SER replaces programmer-defined exceptions only by other programmer-defined exceptions, and built-in exceptions by other built-in exceptions. &  &  &  & \OffuttADA &  & \\
	VCO &  & arithmetic & The VCO (variable change) operator is responsible for adding, multiplying, assigning the signal carried on the input with a certain value. &  &  &  &  &  & \BinhSimulink\\
	CCO &  & constants & The CCO (constant change) operator is responsible for changing (increasing 1, decreasing 1 or assigning by 0) the value of the constants of a model in Simulink. &  &  &  &  &  & \BinhSimulink\\
	CRO &  & constants & The CRO (constant replacement) operator replaces the values among the constants of a model in Simulink. &  &  &  &  &  & \BinhSimulink\\
	DCO &  & constants & The DCO (delay change) operator changes the delay in which the output of the Integrator block or the UnitDelay block will be provided to the system in Simulink. &  &  &  &  &  & \BinhSimulink\\
	VNO &  & logical & The VNO (variable negation) operator negates the value that is being carried on the connections among the blocks of a mode. &  &  &  &  &  & \BinhSimulink\\
	SCO &  & statements & The SCO (statement change) operator is responsible for changing the value threshold of the \texttt{switch} block in a model. It aims to modify the second input of the \texttt{switch} block. &  &  &  &  &  & \BinhSimulink\\
	SSO &  & statements & The SSO (statement swap) operator is responsible for swapping the first and the third input of the \texttt{switch} block. &  &  &  &  &  & \BinhSimulink\\
	TRO &  & variable references & The TRO (types replacement) operator replaces the type indicated in the variable declaration statement with a compatible type. A set of compatible types is, for example, \texttt{double, single, int8, uint8, int16, uint16, int32, uint32} and \texttt{boolean}. &  &  &  &  &  & \BinhSimulink \\
\bottomrule                                                             
\end{longtable}
\normalsize