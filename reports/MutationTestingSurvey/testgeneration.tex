% !TEX root = MutationTestingSurvey.tex

\section{Automated Augmentation of Test Suites}
\label{sec:testGeneration}

The mutation process relies on the existence of a test suite containing test cases that may or may not kill the mutants.
To kill a mutant we need test cases that reach the mutation point, causes changes, or corruptions, in the program state right after the mutation in comparison to the non-mutated version of the program, and manifest these corruptions into the program output (e.g., test assertion) with a software failure \cite{papadakis2019mutation}, these conditions are also known as the killing conditions of a mutant.
In the literature, there exists two groups of approaches for driving automated test generation processes aimed to kill mutants, based on the above mentioned conditions. The first group are techniques based on symbolic procedures and the second group relies on search-based test generation techniques.

\subsection{Symbolic Test Generation Procedures}

Techniques based on symbolic procedures determine the existence of input data that can satisfy the requirements of a test case to kill a mutant \cite{offutt1997automatically}. A way to prove such existence is to use constraint-based methods, in which each test killing requirement represents a constraint in a constraint system, the solution to such system will be a test case that kills the mutant \cite{demillo1991constraint}.

Recently, Holling et al. \cite{holling2016nequivack} proposed to use a symbolic execution approach to identify new test cases, the idea is to execute symbolically both the original and the mutated function, and then to check if their return values are equivalent or not. Each non-equivalent value proves that a new input, that make the original and the mutated function generate different results, has been found. 

We introduce an example of Holling's approach in Listing \ref{function}. We show the \texttt{isPositive} function that checks if an integer number is positive or not. Also, we present the mutated version of \texttt{isPositive}, that mutates the relational $\geq$ into $>$.

In Holling's approach, first, the \texttt{isPositive} parameter \texttt{num} needs to be treated as symbolic value, which is done by the function \texttt{make\_symbolic} (see Listing \ref{example}) which converts concrete variables to symbolic by considering its memory address and size. Then, the original and mutated functions are called using the \texttt{numSymbolic} argument, which is done in lines 5 and 6. Finally, the \texttt{assert} function of line 8 verifies if the integer return values of both functions are equal or not.

In the concrete, if we consider the implementation of \texttt{isPositive} and \texttt{MUT\_isPositive}, the symbolic execution engine will detect the case when \texttt{num} is equal to 0, input that will make both the original and mutated version to produce different outputs. In this case, the input 0 will be added as a new test case of the \texttt{isPositive} function.

\begin{lstlisting}[style=CStyle, caption=isPositive and MUT\_isPositive functions, label=function]
int isPositive(int num){
	if (num >= 0){
		return 1;
	} else {
		return 0;
	}
}

int MUT_isPositive(int num){
	if (num > 0){
		return 1;
	} else {
		return 0;
	}
}

\end{lstlisting}

\begin{lstlisting}[style=CStyle, caption=Holling's approach for test case generation., label=example]
void test () { 
	int numSymbolic; 
	make_symbolic(&numSymbolic, sizeof(numSymbolic), "numSymbolic"); 
 	
 	int original_ret = isPositive(numSymbolic); 
	int transformed_ret = MUT_isPositive(numSymbolic); 
 
	assert(original_ret == transformed_ret); 
} 
 
int main(int argc, char* argv[]) { 
	test (); 
	return 0; 
}
\end{lstlisting}

Similarly to Holling's approach, Riener et al. \cite{riener2011test} proposed to use bounded model checking techniques to search for these counter examples.

Papadakis et al. \cite{papadakis2011automatically, papadakis2010towards} proposed an approach targeting weak mutation testing, in their study they suggest to use symbolic execution techniques along with mutant schemata to automatically generate test cases targeting the killing conditions induced by the different mutants embedded into the same executable.

\subsection{Search-based Test Generation Procedures}

This class of solutions formulate and search for program inputs, under the guidance of a fitness function, that could lead to strong mutations \cite{harman2011strong}. 
The main concern of these methods is the definition of fitness functions that capture the killing conditions of a mutant, and that identifies test inputs that satisfies those conditions.

Ayari et al. \cite{ayari2007automatic} proposed to use an evolutionary approach based on ant colon optimization for automatic test input data generation on mutation testing. The approach takes an existing test case and produces a new test case by slightly modifying its inputs, then the fitness function measures how close is this new test case from covering the mutated statement.

Papadakis et al. \cite{papadakis2011automatically} and then Fraser and Arcuri \cite{fraser2015achieving} proposed a fitness function defined by the distance between the test case and a new corrupted program state induced by the mutant. The approach presented by Fraser and Arcuri \cite{fraser2015achieving} measures the distance according to the mutation operator being applied, for example if the deletion operator changes the program state (i.e., values on the stack are different at the mutation point) the distance is 0, otherwise the given value is 1.

In a similar way, Patrick et al. \cite{patrick2013using} proposed an evolutionary algorithm to improve the inputs produced by random testing according to their ability in killing mutants. 

\endinput

\subsubsection{Symbolic execution test generation} % (fold)

\begin{itemize}

	\item Dynamic symbolic execution approaches: embed the mutant killing conditions within the executable program and guide test generation towards these conditions.

	\item Papadakis et al. \cite{papadakis2011automatically, papadakis2010towards}:
	Embed mutant infection conditions (cause a corruption to the program state) within the schematic functions that are produced by mutant schemata. Basically, we have all mutants encoded in a single executable with their killing conditions. Then, using dynamic symbolic execution we can directly produce test cases that targets those infection conditions.
\end{itemize}


