% !TEX root = MutationTestingSurvey.tex

\section{Automated Augmentation of Test Suites}
\label{sec:testGeneration}

The mutation process relies on the existence of a test suite containing test cases that may or may not kill the mutants.
To kill a mutant we need test cases that reach the mutation point, causes changes, or corruptions, in the program state right after the mutation, in comparison to the non-mutated version of the program, and manifest these corruptions into the program output (e.g., test assertion) with a software failure \cite{papadakis2019mutation}.
In the literature, there exists two groups of approaches for driving automated test generation processes aimed to kill mutants, based on the above mentioned conditions. The first group are techniques based on symbolic procedures and the second group relies on search-based test generation techniques.

Techniques based on symbolic procedures determine the existence of input data that can satisfy the requirements of a test case to kill a mutant \cite{offutt1997automatically}. A way to prove such existence is to use constraint-based methods, in which each test killing requirement represents a constraint in a constraint system, the solution to such system will be a test case that kills the mutant demillo1991.

Recently, Holling et al. \cite{holling2016nequivack} proposed to use a symbolic execution approach to identify new test cases, the idea is to execute symbolically both the original and the mutated function, and then to check if their return values are equivalent or not. Each non-equivalent value proves that a new input, that make the original and the mutated function generate different results, has been found. 

We introduce an example of Holling's approach in Listing \ref{function}. We show the \texttt{isPositive} function that checks if an integer number is positive or not. Also, we present the mutated version of \texttt{isPositive}, that mutates the relational $\geq$ into $>$.

First, the \texttt{isPositive} parameter \texttt{num} needs to be treated as symbolic, this is carried out by the function \texttt{make\_symbolic} which converts concrete variables to symbolic by considering its memory address and size. Then, the original and mutated functions are called using the \texttt{numSymbolic} argument (see Listing \ref{example}), which is done in lines 5 and 6. Finally, the \texttt{assert} function of line 8 verifies if the integer return values of both functions are equal.

In the concrete, if we consider the implementation of \texttt{isPositive} and \texttt{MUTATED\_isPositive}, the symbolic execution engine will detect the case when \texttt{num} is equal to 0, input that will make both the original and mutated version to behave different. In this case, the input 0 will be added as a new test case of the \texttt{isPositive} function.

\begin{lstlisting}[style=CStyle, caption=isPositive and MUTATED\_isPositive functions, label=function]
int isPositive(int num){
	if (num >= 0){
		return 1;
	} else {
		return 0;
	}
}

int MUTATED_isPositive(int num){
	if (num > 0){
		return 1;
	} else {
		return 0;
	}
}

\end{lstlisting}

\begin{lstlisting}[style=CStyle, caption=Example, label=example]
void test () { 
	int numSymbolic; 
	make_symbolic(&numSymbolic, sizeof(numSymbolic), "numSymbolic"); 
 	
 	int original_ret = isPositive(numSymbolic); 
	int transformed_ret = MUTATED_isPositive(numSymbolic); 
 
	assert(original_ret == transformed_ret); 
} 
 
int main(int argc, char* argv[]) { 
	test (); 
	return 0; 
}
\end{lstlisting}


\endinput

\subsubsection{Symbolic execution test generation} % (fold)

These methods turn each of the RIPR conditions into a constraint and build a system that is passed to a constraint solver (critical).

\begin{itemize}
	\item Use of symbolic execution engines (JPF-SE \cite{anand2007jpf} and KLEE \cite{holling2016nequivack} (READ)) to generate mutation-based test cases. 
	The process consists of instrumenting the original program with mutant killing conditions that the symbolic execution is asked to cover (transforms the mutant killing problem to code reachability problem). 
	\item Use of bounded model checking techniques to search for solutions that expose the studied mutants \cite{riener2011test}. (READ)

	\item Dynamic symbolic execution approaches: embed the mutant killing conditions within the executable program and guide test generation towards these conditions.

	\item Papadakis et al. \cite{papadakis2011automatically, papadakis2010towards}:
	Embed mutant infection conditions (cause a corruption to the program state) within the schematic functions that are produced by mutant schemata. Basically, we have all mutants encoded in a single executable with their killing conditions. Then, using dynamic symbolic execution we can directly produce test cases that targets those infection conditions.

	\item Zhang et al. \cite{zhang2010test} and Bardin et al. \cite{papadakis2011automatically,papadakis2010towards} use annotations to embed the mutant infection conditions within the program under test. Also, Jamrozik et al. \cite{jamrozik2013generating} enriched path conditions with constraints to target mutants.

	\item critical: performing weak mutation often results in tests that can strongly kill many mutants, but in general they only kill trivial mutants that fails to reveal faults.
	
	\item critical: there is a need to formulate the mutant propagation condition (propagate the corruption to the program output) on top of the reachability and infection conditions (cause a corruption). This is complex, because involves running two executions, the original program along the mutated one, along all possible execution paths.

	\item idea: Papadakis and Malevris \cite{papadakis2010automatic} used symbolic execution for mutants to automatically derive test suites. By using this approach mutation testing is used for test case generation instead of assessment.

\end{itemize}
% subsection static_constraint_based_test_generation (end)

\subsubsection{Search-based test generation} % (fold)

\begin{itemize}
	\item critical: define a fitness function that is capable of capturing the RIPR conditions and effectively identify test inputs that satisfy these conditions
	\item use hill climbing and genetic algorithms (main concern: definition of fitness function) 
\end{itemize}
% subsection search_based_test_generation (end)

