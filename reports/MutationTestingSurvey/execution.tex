% !TEX root = MutationTestingSurvey.tex

\subsection{Run-time Scalability}
\label{sec:opt:execution}

In the mutation testing process, the execution of mutants is the major source of scalability problems (i.e., it requires a lot of time to be completed). Indeed, with $n$ mutants for a program under test and a test suite of $m$ test cases, $n \times m$ executions are required to apply mutation testing.

%For example, consider the ESAIL SVF test suite that requires approximately 10 hours to run for the original program, if we produce 100,000 mutants, it means that we would require 1,000,000 hours or 114 years to cover all mutant executions.
%Fabrizio: I am not sure which formatting we should use for ESA. Let's try to follow the SI System
This might make mutation testing infeasible. For example, a test suite that requires 10 hours to be executed against software under test, would require 1\,000\,000 hours or 114 years be executed against 100\,000 mutants; for a large space system with 10\,000 lines of code, 100\,000 mutants can be easily generated  with 10 mutants generated for each line of code, on average.

To cope with the run-time cost of mutation testing, several solutions had been proposed in the literature, they are summarized in the following paragraphs.

Some solutions rely on code coverage. Mutants that belong to code locations that are not exercised by any test case should not be executed because there is no chance of being killed. Code coverage collected during the execution of the test suite against the original software can be used to determine if a code location is exercised; this approach has been implement by the Proteum tool \cite{delamaro1996proteum}.
Similarly, mutants that have been already killed by a test case should not be executed against other test cases.

%Fabrizio: you mention "killing condition" did we introduce the concept before?
Other solutions concern the prioritization of test cases. Just et al. \cite{just2012using} and Zhang et al. \cite{zhang2013faster} proposed to sort test cases to kill mutants as early as possible, e.g., by executing first the test cases with a shorter runtime~\cite{just2012using}. 

%Papadakis and Malevris \cite{papadakis2011automatically} gave a step further in this research line, and proposed that a way to prioritise the  different mutants is by assessing in advance which of the mutants are actually modifying the variables that check the killing condition of the mutant, i.e., the final assertion of a test case, and prioritise them over mutants that do not modify variables related to the killing condition.
Papadakis and Malevris \cite{papadakis2011automatically} rely on data-flow analysis to determine which mutants modify variables that reach the killing condition of the mutant (e.g., the final assertion of a test case). These mutants are prioritized over mutants that do not modify variables reaching a killing condition.


The use of weak and firm mutation over strong mutation may speed up mutation testing as well.
Unlike strong mutation, 
%i.e., the mutant and the original program must show an observable difference (e.g., the result of an assertion), 
in weak mutation \cite{ammann2016introduction}, the mutant is killed if the program state is modified immediately after the mutation; the advantage of weak mutation is that it does not require a complete execution to determine if the mutant has been killed. Similarly to weak mutation, in firm mutation \cite{ammann2016introduction}, the assessment of the killing condition is placed in between weak and strong mutation; typically by checking if the result generated by a mutated function (e.g., the return value) differs from the result of the original function. The main drawback of both the two approaches is that they sacrifice test effectiveness; more precisely, they cannot ensure that the difference in the behaviour of the software is reflected in a test failure.

%Fabrizio: the following is a conclusion that makes sense to evaluate the two approaches in terms of test assessment effectivenes, however in this chapter we are discussing speed-up
%In a nutshell, weak mutation is considered less effective than firm mutation, and firm mutation is considered less effective than strong mutation.

Sometimes mutation operators introduce code changes that prevent the termination of test cases (e.g., infinite loops), which requires the intervention of human operators and, consequently, a delay in the completion of the mutation testing process.
For this reason, several mutation tools rely on time thresholds to force the termination of test case executions. 
%Fabrizio: "Usually" should be followed at least by a citation
Usually the execution is terminated when the execution time of a test case against a mutated program takes more than three times the execution time required for the original program.

King and Offutt \cite{king1991fortran} presented split-stream execution, a technique that takes advantage of the fact that a program and its mutants share most of the execution parts. Instead of having one executable per mutant it could be possible to generate a modified version of the SUT that creates multiple processes (one for each mutant) only when the mutated code is reached \cite{tokumoto2016muvm}, thus saving time and resources. 

An orthogonal solution is to reduce the number of test cases that are executed during mutation testing.
Usaola et al. \cite{usaola2012reduction} proposed a greedy algorithm that selects iteratively the test cases that kill the most mutants that were not killed by the previously selected test cases. In this direction, Shi et al. \cite{shi2014balancing} assessed the effects of reducing the size of test suites, and confirmed empirically on an experiment guided on 18 projects with a total of 261\,235 test cases, that is actually possible to maintain the mutation score and reduce test suite size without loss of fault detection.

Other approaches involve the use of compiler optimisations \cite{papadakis2015trivial,kintis2017detecting} as a way to identify equivalent and redundant mutants and, consequently, speed up the mutant execution phase. Papadakis et al. \cite{papadakis2015trivial, kintis2017detecting} rely on compiler optimisations to compile mutants and original programs; if the executable code of the original program and one of its mutants match, then the mutant is said to be equivalent and discarded. The same solution can be used to determine if one or more mutants are redundant with each other. The number of compiled mutants gets naturally reduced. Recent empirical studies \cite{kintis2017detecting}, shows that these compiler optimisations can reduce the total number of mutants by 11\% and 28\% for Java and C programming language, respectively.
