% !TEX root = MutationTestingSurvey.tex

\section{Mutation Execution}\label{sec:execution}

If we have $n$ mutants and a test suite of $m$ tests, we have to perform $n \times m$ program executions at maximum.
The main issue remains the scalability of the amount of runnings needed to cover all mutants.

\begin{itemize}
	\item execute only mutants that are reachable by test cases
	\oscar{easy to reimplement}
	\item is possible to record with one execution all the mutants that can be infected by a test
	\item instead of executing every mutant with every test, it is possible to execute all mutants at once, by monitoring the coverage of the infection conditions
	\item When mutation testing targets strong mutation and the case of test suites take a long execution time, we can reduce the execution time by checking if every mutant achieve weak mutation.
	\oscar{How easy it is to determine if we have weak mutation in C programs? I think that one of the solutions is linked to split stream.} 
	If weak mutation is not achieved, i.e., if the program state is not infected, there is no point to execute the test case till the end. We can simply report it as not killed and save time.
	\item criticality: since determining whether a test execution can terminate or not is an undecidable problem, heuristic solutions are needed. Such as establishing time thresholds for running executions.
	\oscar{but if we face this problem, isn't it enough to check if a test execution is taking twice the expected time? I mean, if the test case does not fail in 3 times the original execution time we can report the mutant as not killed. But the solution to this problem might be to add a timeout inside the test suite.}
	\item take advantage of common executions parts (between the original program and mutants). Called as Split-Stream execution
\end{itemize} 

Strong, weak and firm mutation
\begin{itemize}
	\item Strong mutation:
	\item Weak mutation: the mutant is killed if any mutated component changes its state (variable reference, variable assignment, arithmetic expression, relational expression, boolean expression). Advantages: weak mutation does not need a complete execution. Cons: sacrifices test effectiveness with test effort.
	\item Firm mutation: the killing process occurs between weak and strong mutation
\end{itemize} 

Runtime optimization techniques
\begin{itemize}
	\item Interpreter based technique: results are analysed from the source code
	\item Compiler based technique: results are analysed from the execution of binary code 
	\oscar{how much gain can it give?}
	\item Mutant Schema Generation: creates a metaprogram, there is research on mutating bytecode
	\oscar{Does MUSIC implement it? We can implement it as a postprocessing. We compare files generated by MUSIC. We identify the changed lines (mutants). Then we generate a single file where we have options for each changed line.}
\end{itemize}

