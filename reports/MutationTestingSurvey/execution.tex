% !TEX root = MutationTestingSurvey.tex

\subsection{Run-time Scalability}
\label{sec:opt:execution}

In the mutation testing process, running the mutants is considered to be the most expensive phase, consider having for a program under test $n$ mutants, and a test suite consisting of $m$ tests, this means that we have to perform at maximum $n \times m$ executions.
For example, consider the ESAIL SVF test suite that requires approximately 10 hours to run for the original program, if we produce 100,000 mutants, it means that we would require 1,000,000 hours or 114 years to cover all mutant executions.
To cope with the high cost of mutation testing research has make some advances in this area. For example, mutants that are not exercised by any test case should not be considered, since there is no chance of being killed, this approach has been implement in the Proteum mutation tool \cite{delamaro1996proteum}. In the same way, mutants that have been already killed by a test case should not be executed again with other test cases, since this would only increase the overhead of the technique. Similarly, Just et al. \cite{just2012using} and Zhang et al. \cite{zhang2013faster} proposed prioritizing test cases, that is, ordering test cases in a way that mutants are killed as early as possible, e.g., Just et al. \cite{just2012using} proposed to execute first the test cases with a shorter runtime. Papadakis and Malevris \cite{papadakis2011automatically} gave a step further in this research line, and proposed that a way to prioritise the different mutants is by assessing in advance which of the mutants are actually modifying the variables that check the killing condition of the mutant, i.e., the final assertion of a test case, and prioritise them over mutants that do not modify variables related to the killing condition.

To decrease the run-time cost of mutation testing, two additional types of killing conditions can be considered: weak and firm mutation. Unlike strong mutation, i.e., the mutant and the original program must show an observable difference (e.g., the result of an assertion), in weak mutation \cite{ammann2016introduction} instead, the mutant is considered killed if the program state is modified immediately after the mutation, the advantage of weak mutation is that a complete execution to determine the killing condition is not required, such as strong mutation, the main drawback is that sacrifices test effectiveness with test effort. Similarly to weak mutation, in firm mutation \cite{ammann2016introduction}, the assessment of the killing condition is placed in between weak and strong mutation. In a nutshell, weak mutation is considered less effective than firm mutation, and firm mutation is considered less effective than strong mutation.

To further avoid unnecessary test runtime, several mutation tools include time threshold for running executions, in general if a test case employs three times during mutation execution with respect the original program, the execution is terminated.

King and Offutt \cite{king1991fortran} presented split-stream execution, a technique that takes advantage of the fact that a program and its mutants share most of the execution parts, so instead of having one executable per mutant it could be possible to generate a modified version of the SUT that creates multiple processes (one for each mutant) only when the mutated code is reached \cite{tokumoto2016muvm}, in this way saving time and resources. 

% \todoinline{How easy it is to determine if we have weak mutation in C programs? I think that one of the solutions is linked to split stream. If weak mutation is not achieved, i.e., if the program state is not infected, there is no point to execute the test case till the end. We can simply report it as not killed and save time.}

An orthogonal solution is to reduce the test cases conforming a test suite to decrease the run-time cost of the mutation process. For instance, it is possible to remove redundant test cases, e.g., test cases that do not alter mutation score in case of test case deletion. Shi et al. \cite{shi2014balancing} assessed the effects of reducing the size of test suites, and confirmed empirically on an experiment guided on 18 projects with a total of 261,235 tests, that is actually possible to maintain the mutation score and reduce test suite size without loss of fault detection.
