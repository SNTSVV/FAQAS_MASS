% !TEX root = MutationTestingSurvey.tex

\chapter{Mutation Testing Trends}
\label{chapter:trends}


%\section{Mutation Testing Trends}

This chapter provides an introductory overview on the use of mutation testing beyond test assessment.

Since it's definition in the early 1970s, mutation testing has been used 
%Fabrizio: the sentence below means "test assessment" so is our of the scope of this chapter
%as an indicator of test cases effectiveness \cite{DeMillo78} and 
as baseline methodology for assessing software testing techniques \cite{chekam2017empirical}.


Nowadays, researchers are shifting their interest to the exploration of mutants' behaviors \cite{papadakis2019mutation}. 
More precisely, there is interest into studying the functional and non-functional characteristics that each mutant can introduce into the software under test.
Researchers have exploited this concept to develop methods that automatically \INDEX{improve fault detection}~\cite{zhang2016isomorphic}, \INDEX{localize faults} \cite{papadakis2015metallaxis}, \INDEX{repair software}~\cite{le2011genprog}, \INDEX{improve security properties}~\cite{loise2017towards} and \INDEX{reduce memory consumption}~\cite{langdon2017genetic}.
For example, Zhang et al. \cite{zhang2016isomorphic} used mutants to improve the fault detection ability of regression test suites. The approach mutates both the old and new version of the program under analysis. For every mutation applied, the approach executes the old and the new version against the same test suite, if there are differences between the output of the two executions then a problem has been found.

\REVTWO{C45}{Unfortunately, there has not been efforts in the literature for code quality improvement based on mutation testing.}

However,
% Despite being the main objective of mutation testing assess the quality of existing test suites. 
the mutation testing approach has been used also in literature as a way to improve code quality of non-functional properties,
in fact Arcaini et al.~\cite{arcaini2017novel,arcaini2015rehabilitating} and then Lopez et al.~\cite{lopez2018source} proposed the idea of taking advantage of \INDEX{equivalent mutants} for improving the quality of the artefact under test.
More precisely, to improve non-functional quality properties such as readability and efficiency.

The authors proposed the following procedure for detecting mutants with improved readability. 
First, to generate a mutant $M$ for a program $P$. Second, to check the equivalence between the generated mutant $M$ and $P$. Third, to compare the code readability quality $q(M)$ and $q(P)$ between $M$ and $P$. Finally, if $M$ and $P$ are equivalent and $q(M) > q(P)$ a subject with better code readability has been identified. An example is presented in Listings~\ref{equivalent1} and~\ref{equivalent2}.
%We introduced an example in the following:
Listing~\ref{equivalent1} shows three statements that perform assignments on variables \texttt{x}, \texttt{y} and \texttt{z}. By applying the \textit{statement reordering operator} we can generate the mutant shown Listing~\ref{equivalent2}. The mutated version of Listing~\ref{equivalent2} has reordered statements 2 and 3, this version of Listing~\ref{equivalent1} is an equivalent mutant since its changes do not affect the execution of the code (i.e., both statements are independent). 
Particularly, the code readability quality has been improved in Listing~\ref{equivalent2} because the distance between the definition and use of the variable \texttt{x} is shorter than in the original version. 
Since the mutant fulfill both requirements of equivalence and improved code readability quality, hence the mutant of Listing~\ref{equivalent2} can be used as replacement of the original code.

\input{listings/equivalent_code}

%\DONE{It would be nice to have a more detailed description of model based mutation testing, not sure what is feasible.}

Beyond typical code-drive mutation testing process, the mutation concept has also been applied to model artifacts, this line of research is called \INDEX{model-based mutation testing}. The objective of these techniques is to identify faults related to missing functionalities and misinterpreted specifications through the generation of effective test cases \cite{devroey2016featured,belli2016model}.
Model-based mutation testing takes a model and mutates it according to different fault models (i.e., mutation operators). Then, each mutant is compared to the original model, this is done via conformance checks through model-checking or SMT-solvers. If a mutant does not conform to the original model, then new test cases are generated by considering the the inputs that exercise behaviours that differ for the original and mutated models\cite{8411732}.

In a similar fashion, mutation testing has also been applied to relational database schemas \cite{wright2013efficient} to test the data that will be accepted and rejected by the database management system.

%\DONE{We may write what is the objective of mutating DB schema}

\index{Testing security policies}
Mutation testing has been also applied to security testing, specifically to test security policies. For example, Mouelhi et al. \cite{mouelhiv2008generic} proposed a meta-model that captures security policy rules, then they mutate the model by applying a set of operators that will simulate faults in the instantiations of the model. 

On a different perspective, Patrick and Jia \cite{patrick2015kernel} proposed a technique based on mutation testing to support \INDEX{adaptive random testing}.
%\DONE{Is this ok?}
Adaptive random testing is an approach to select test inputs to maximize the exploration of the input space.
%seeks to distribute test cases more evenly within the input space). 
The proposed technique improves the fault revelation ability of adaptive random testing by guiding the test input selection process towards the generation of test cases that kill mutants.

Mutation testing has also been used to \INDEX{automatically detect loop invariants} by applying mutations to postconditions clauses \cite{galeotti2015inferring}. It has been used to measure code coverage in time-sensitive systems \cite{pankumhang2015iterative}, to support software verification tasks \cite{groce2015verified}, and to create software clones \cite{roy2009mutation}.  \INDEX{Predictive mutation testing}\cite{zhang2018predictive} makes use of machine learning to predict if a certain mutant will likely be killed by a test suite.



