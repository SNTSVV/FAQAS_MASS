% !TEX root = MutationTestingSurvey.tex

\chapter{Mutation Testing Trends}
\label{chapter:trends}


%\section{Mutation Testing Trends}

This chapter provides an introductory overview on the use of mutation testing beyond test assessment.

Since it's definition in the early 1970s, mutation testing has been used 
%Fabrizio: the sentence below means "test assessment" so is our of the scope of this chapter
%as an indicator of test cases effectiveness \cite{DeMillo78} and 
as baseline methodology for assessing software testing techniques \cite{chekam2017empirical}.


Nowadays, researchers are shifting their interest to the exploration of mutants' behaviors \cite{papadakis2019mutation}. 
More precisely, there is interest into studying the functional and non-functional characteristics that each mutant can introduce into the software under test.
Researchers have exploited this concept to develop methods that automatically \INDEX{improve fault detection}~\cite{zhang2016isomorphic}, \INDEX{localize faults} \cite{papadakis2015metallaxis}, \INDEX{repair software}~\cite{le2011genprog}, \INDEX{improve security properties}~\cite{loise2017towards} and \INDEX{reduce memory consumption}~\cite{langdon2017genetic}.
For example, Zhang et al. \cite{zhang2016isomorphic} used mutants to improve the fault detection ability of regression test suites. The approach mutates both the old and new version of the program under analysis. For every mutation applied, the approach executes the old and the new version against the same test suite, if there are differences between the output of the two executions then a problem has been found.

\MREVISION{C45}{Unfortunately, there has not been efforts in the literature for code quality improvement based on mutation testing.}

However,
% Despite being the main objective of mutation testing assess the quality of existing test suites. 
the mutation testing approach has been used also in literature as a way to improve code quality of non-functional properties,
in fact Arcaini et al.~\cite{arcaini2017novel,arcaini2015rehabilitating} and then Lopez et al.~\cite{lopez2018source} proposed the idea of taking advantage of \INDEX{equivalent mutants} for improving the quality of the artefact under test.
More precisely, to improve non-functional quality properties such as readability and efficiency.

\input{listings/equivalent_code}

In the case of code readability, for example, the mutation operator that swaps two statements in a program may produce equivalent mutants given that both statements are independent, and casually improve qualities such as readability and efficiency of compiling. 

Listing~\ref{equivalent1} and~\ref{equivalent2} introduce this case. The mutant of Listing~\ref{equivalent2} has been produced through of the \textit{statement reordering operator} on the code excerpt from Listing~\ref{equivalent1}.
Particularly, the equivalent mutant shown in Listing~\ref{equivalent2} has better readability than the original code, because the distance between the definition and use of the variable \texttt{x} is shorter than in the original version.

%\DONE{It would be nice to have a more detailed description of model based mutation testing, not sure what is feasible.}

Beyond typical code-drive mutation testing process, the mutation concept has also been applied to model artifacts, this line of research is called \INDEX{model-based mutation testing}. The objective of these techniques is to identify faults related to missing functionalities and misinterpreted specifications through the generation of effective test cases \cite{devroey2016featured,belli2016model}.
Model-based mutation testing takes a model and mutates it according to different fault models (i.e., mutation operators). Then, each mutant is compared to the original model, this is done via conformance checks through model-checking or SMT-solvers. If a mutant does not conform to the original model, then new test cases are generated by considering the the inputs that exercise behaviours that differ for the original and mutated models\cite{8411732}.

In a similar fashion, mutation testing has also been applied to relational database schemas \cite{wright2013efficient} to test the data that will be accepted and rejected by the database management system.

%\DONE{We may write what is the objective of mutating DB schema}

\index{Testing security policies}
Mutation testing has been also applied to security testing, specifically to test security policies. For example, Mouelhi et al. \cite{mouelhiv2008generic} proposed a meta-model that captures security policy rules, then they mutate the model by applying a set of operators that will simulate faults in the instantiations of the model. 

On a different perspective, Patrick and Jia \cite{patrick2015kernel} proposed a technique based on mutation testing to support \INDEX{adaptive random testing}.
%\DONE{Is this ok?}
Adaptive random testing is an approach to select test inputs to maximize the exploration of the input space.
%seeks to distribute test cases more evenly within the input space). 
The proposed technique improves the fault revelation ability of adaptive random testing by guiding the test input selection process towards the generation of test cases that kill mutants.

Mutation testing has also been used to \INDEX{automatically detect loop invariants} by applying mutations to postconditions clauses \cite{galeotti2015inferring}. It has been used to measure code coverage in time-sensitive systems \cite{pankumhang2015iterative}, to support software verification tasks \cite{groce2015verified}, and to create software clones \cite{roy2009mutation}.  \INDEX{Predictive mutation testing}\cite{zhang2018predictive} makes use of machine learning to predict if a certain mutant will likely be killed by a test suite.



