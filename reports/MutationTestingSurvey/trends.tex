% !TEX root = MutationTestingSurvey.tex

\chapter{Mutation Testing Trends}
\label{chapter:trends}


%\section{Mutation Testing Trends}

This chapter provides an introductory overview on the use of mutation testing beyond test assessment.

Since it's definition in the early 1970s, mutation testing has been used 
%Fabrizio: the sentence below means "test assessment" so is our of the scope of this chapter
%as an indicator of test cases effectiveness \cite{DeMillo78} and 
as baseline methodology for assessing software testing techniques \cite{chekam2017empirical}.


Nowadays, researchers are shifting their interest to the exploration of mutants' behaviors \cite{papadakis2019mutation}. 
More precisely, there is interest into studying the functional and non-functional characteristics that each mutant can introduce into the software under test.
Researchers have exploited this concept to develop methods that automatically \INDEX{improve fault detection}~\cite{zhang2016isomorphic}, \INDEX{localize faults} \cite{papadakis2015metallaxis}, \INDEX{repair software}~\cite{le2011genprog}, \INDEX{improve security properties}~\cite{loise2017towards} and \INDEX{reduce memory consumption}~\cite{langdon2017genetic}.
For example, Zhang et al. \cite{zhang2016isomorphic} used mutants to improve the fault detection ability of regression test suites. The approach mutates both the old and new version of the program under analysis. For every mutation applied, the approach executes the old and the new version against the same test suite, if there are differences between the output of the two executions then a problem has been found.

\REVTWO{C45}{Unfortunately, to the best of our knowledge, the literature lacks approaches that rely on mutation testing to \INDEX{evaluate non-functional properties} of the software such as code readability or maintainability. The most related approaches are that of
%
%However,
%% Despite being the main objective of mutation testing assess the quality of existing test suites. 
%the mutation testing approach has been used also in literature as a way to improve code quality of non-functional properties,
%in fact 
Arcaini et al.~\cite{arcaini2017novel,arcaini2015rehabilitating} and then Lopez et al.~\cite{lopez2018source} who proposed the idea of taking advantage of \INDEX{equivalent mutants} for \INDEX{improving non-functional properties} such as readability and efficiency.
The authors proposed the following procedure for detecting mutants with improved readability. 
First, they generate a mutant $M$ for a program $P$. Second, they check the equivalence between the generated mutant $M$ and $P$. 
Third, they compare the code readability quality $q(M)$ and $q(P)$ between $M$ and $P$. 
Finally, they identify a subject with better code readability when $M$ and $P$ are equivalent and $q(M) > q(P)$. 
Authors assume to have a function to estimate automatically a quality attribute. For example, in their work, readability is measured as the length of the def-use path between the first definition of a variable and its use. The approach aims to minimize such distance to improve readability. An example is presented in Listings~\ref{equivalent1} and~\ref{equivalent2}.
%We introduced an example in the following:
Listing~\ref{equivalent1} shows three statements that perform assignments on variables \texttt{x}, \texttt{y} and \texttt{z}. By applying the \textit{statement reordering operator} we can generate the mutant shown Listing~\ref{equivalent2}. The mutated version of Listing~\ref{equivalent2} has reordered statements 2 and 3, this version of Listing~\ref{equivalent1} is an equivalent mutant since its changes do not affect the execution of the code (i.e., both statements are independent). 
Particularly, the code readability quality has been improved in Listing~\ref{equivalent2} because the distance between the definition and use of the variable \texttt{x} is shorter than in the original version. 
Since the mutant fulfills both requirements of equivalence and improved code readability quality, hence the mutant of Listing~\ref{equivalent2} can be used as replacement of the original code.}

\input{listings/equivalent_code}

%\DONE{It would be nice to have a more detailed description of model based mutation testing, not sure what is feasible.}

Beyond typical code-drive mutation testing process, the mutation concept has also been applied to model artifacts, this line of research is called \INDEX{model-based mutation testing}. The objective of these techniques is to identify faults related to missing functionalities and misinterpreted specifications through the generation of effective test cases \cite{devroey2016featured,belli2016model}.
Model-based mutation testing takes a model and mutates it according to different fault models (i.e., mutation operators). Then, each mutant is compared to the original model, this is done via conformance checks through model-checking or SMT-solvers. If a mutant does not conform to the original model, then new test cases are generated by considering the the inputs that exercise behaviours that differ for the original and mutated models\cite{8411732}.
\REVTWO{C43}{With space software being often model-based~\cite{binh2012mutation}, \INDEX{model-based mutation testing} represents a valuable solution for test cases generation.}

In a similar fashion, mutation testing has also been applied to relational database schemas \cite{wright2013efficient} to test the data that will be accepted and rejected by the database management system.

%\DONE{We may write what is the objective of mutating DB schema}

\index{Testing security policies}
Mutation testing has been also applied to security testing, specifically to test security policies. For example, Mouelhi et al. \cite{mouelhiv2008generic} proposed a meta-model that captures security policy rules, then they mutate the model by applying a set of operators that will simulate faults in the instantiations of the model. 

On a different perspective, Patrick and Jia \cite{patrick2015kernel} proposed a technique based on mutation testing to support \INDEX{adaptive random testing}.
%\DONE{Is this ok?}
Adaptive random testing is an approach to select test inputs to maximize the exploration of the input space.
%seeks to distribute test cases more evenly within the input space). 
The proposed technique improves the fault revelation ability of adaptive random testing by guiding the test input selection process towards the generation of test cases that kill mutants.

Mutation testing has also been used to \INDEX{automatically detect loop invariants} by applying mutations to postconditions clauses \cite{galeotti2015inferring}. It has been used to measure code coverage in time-sensitive systems \cite{pankumhang2015iterative}, to support software verification tasks \cite{groce2015verified}, and to create software clones \cite{roy2009mutation}.  \INDEX{Predictive mutation testing}\cite{zhang2018predictive} makes use of machine learning to predict if a certain mutant will likely be killed by a test suite.

\REVTWO{C44}{There is a growing interest in code-driven mutation testing. Recent surveys~\cite{papadakis2019mutation} report that there have been more than 500 scientific publications about mutation testing in top software engineering conferences and journals in the last 10 years.} 
%\TODO{PLEASE CHECK if the following is what you meant.}
{This large set of publications focus mostly on (i) the identification of new solutions to the open problems of mutation testing (i.e., scalability and the identification of equivalent/redundant mutants), (2) applying the mutation testing approach to new languages and artefacts, and (3) using of mutation as a means to support other tasks (e.g., software repair~\cite{le2011genprog}).}
Concerning data-driven mutation testing, it is a new idea formalized in this book. With the growing spread of cyber-physical systems, which rely on the analysis on different kinds of environmental data, we expect it to be further developed in the future.

