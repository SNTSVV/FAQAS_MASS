% !TEX root = MutationTestingSurvey.tex

\subsection{Equivalent Mutants}
\label{sec:opt:equivalent}

Equivalent mutants are mutants that behave as the original program, they are semantically equivalent to the original version despite being syntactically different. Equivalent mutants are an actual problem that can lead mutation testing to be infeasible, Schuler and Zeller \cite{schuler2013covering} showed that 45\% of not killed mutants are equivalent, and that manually checking if a mutant is equivalent can take on average up to 15 minutes. Even though, the process of identifying equivalent mutants has been defined as an undecidable problem \cite{madeyski2013overcoming}, the research has cope with heuristics to tackle this issue.

According to the literature \cite{madeyski2013overcoming}, the equivalent mutant heuristics can be classified in two different groups: (1) detecting equivalent mutant techniques, and (2) reducing equivalent mutant techniques.

\subsubsection{Detecting Equivalent Mutant Techniques}

The first group aims to detect and discard the equivalent mutants during the mutation process. In this direction, Papadakis et al. \cite{papadakis2015trivial, kintis2017detecting,papadakis2019mutation} has developed the Trivial Compiler Optimisation technique, the approach relies on the idea that compiler optimisations transforms mutants to the optimised version, thus when the original program can be transformed by an optimisation to one of its mutants, then the mutant is defined equivalent.
Recent studies \cite{papadakis2015trivial} show that the Trivial Compiler Optimisation is able to detect approximately up to 30\% of the equivalent mutants.

A different approach for detecting equivalent mutants is to formulate the problem as a constraint satisfaction problem. The main idea is to analyze the path condition of a mutant, in which the mutant is defined equivalent if and only if the input constraint is unsatisfiable. Offutt et al. \cite{offutt1996detecting,offutt1997automatically} carried out an experimental evaluation on 11 Fortran subject programs and detected 47\% of the existing equivalent mutants by applying this heuristic.
Similarly, Holling et al. \cite{holling2016nequivack,papadakis2012mutation} presented an approach for identifying non-equivalent mutants and improving the confidence of the mutation score. By using static analysis and symbolic execution they defined a six-steps procedure to determine which mutants are \textit{non-equivalent}. \textit{Non-equivalent} mutants are identified every time they find a counter-example input for which the outputs of a pair of functions (the original function and the mutant one) is different. In the case no counter-example is found, then the mutant is classified as \textit{unknown}. 
In like manner, Riener et al. \cite{riener2011test} proposed the Symbolic Bounded Model Checking (SymBMC) procedure for the automated generation of test cases from a set of mutants. The approach examines the original program and its mutants on the same input and seeks for executions resulting in different observable output for the program and mutants, if the procedure finds a failing execution, the input data is saved as an effective new test case. Every time a new test case is found, the mutant is defined as non-equivalent, in a similar way to Holling's approach \cite{holling2016nequivack}.

Other approaches consider the use of software clones (i.e., similar code fragments) to detect equivalent mutants \cite{kintis2013identifying}, in this work Kintis proposed that mirrored mutants (i.e., mutants that belong to the same software clone) present the same behavior with respect to each other. So, for a set of mirrored mutants, is enough to prove equivalence of one mutant, instead of trying to detect equivalence for the whole set.

With a different approach, Adamopoulos et al. \cite{adamopoulos2004overcome} introduced a co-evolutionary technique for detecting equivalent mutants. The technique defines a fitness function that sets a poor fitness value to an equivalent mutant. Through the fitness function equivalent mutants are removed during the co-evolutionary process, and only mutants that are hard to kill and test cases that are good at detecting mutants are kept for future iterations of the algorithm. On the other hand, Maldonado et al. \cite{maldonado2005bayesian} developed a Bayesian Learning-Based technique for helping tester to detect equivalent mutants using an inference algorithm.

% 	\item Margrave's change-impact analysis \cite{martin2007fault} (READ)
% 	\item Using Lesar model-checker for eliminating equivalent mutants \cite{du2008towards} (READ)

% \textbf{Avoiding equivalent mutant generation techniques}

% \begin{itemize}
% 	\item \textbf{Selective mutation} \cite{mresa1999efficiency}:
% 	Randomly selecting 10\%, 20\%, 30\%, 40\%, 50\% and 60\% of the mutants results in a fault loss of approximately 26\%, 16\%, 13\%, 10\%, 7\% and 6\% respectively \cite{papadakis2010empirical}.

\subsubsection{Reducing Equivalent Mutant Techniques}

The second group of techniques aims to reduce the amount equivalent mutants produced during mutation process.
In this direction, Gr\"{u}n et al. \cite{grun2009impact} proposed that mutants that do not alter the dynamic control-flow with respect to the original program, should be avoided since they have a greater chance of being equivalent. To measure the dynamic control-flow difference (i.e., the impact), they defined the impact as the number of classes with different statement coverage. On the empirical evaluation performed on JAXEN (12,449 LOC), by analyzing the mutants that were covered by the test bench but not killed, they performed several experiments with two main results. 
The first result was about the relation between impact on control-flow and likelihood of the mutant of being non-equivalent, the experimental results were obtained by randomly selecting 20 mutants, they discovered that the 60\% of the mutants with control-flow impact were classified as non-equivalent, and that the 60\% of the mutants without control-flow impact were classified as equivalent. 
The second result was about the relation between the impact on control-flow degree and likelihood of the mutant of being non-equivalent, the results were obtained by analyzing two specific subsets (e.g., (a) subset with the 20 mutants with highest impact, and (b) subset with the 20 mutants with lower impact), from the first subset with higher impact, 90\% of the mutants were non-equivalent, while on the second subset 55\% were equivalent mutants. The conclusion is that testers can effectively focus on mutations with higher impact, at the expense of loosing mutations that could reveal another type of faults.

In the same research line, Schuler et al. \cite{schuler2009efficient} demonstrated that mutants that violate dynamic invariants (i.e., invariants derived from data collected using dynamic analysis) are less likely to be equivalent and should be preferred over those that do not alter invariants with respect to the original program version. In an empirical evaluation performed on JAXEN, they analyzed two subset of mutants (e.g., (a) 12 random mutants that do not violate invariants, and (b) 12 mutants with highest score of invariants violated during execution), the results indicate that from the violating mutants 83\% were non-equivalent, while from the non-violating mutants only 33\% were non-equivalent.

A different perspective is to focus in code coverage of mutants, for example, Schuler et al. \cite{schuler2010covering,schuler2013covering} discovered that mutants that change code and data coverage with respect to the original program, has a likelihood of 68\%-79\% to be non-equivalent.
On an empirical evaluation performed on 140 mutations from seven open-source projects, the authors discovered (1) that operators that modify the control-flow such as \textit{negate jump condition} or \textit{omit method call} produce less equivalent mutants (30\%) than operators that only change data (57\%), and (2) that from several metrics based on differences in statement (i.e., number of methods that have at least one statement that is executed at a different frequency between mutated and original program) and data (i.e., number of methods that have at least one different return value between mutated and original program) coverage, the authors discovered that by measuring both impact on data and code coverage is possible to obtain few false negative results (61\%) when assessing if a mutant is equivalent or not, in comparison with measuring data and code coverage independently (56\% and 67\% ,respectively).

Program slicing has been presented as a possible mechanism for reducing equivalent mutants \cite{voas1997software, hierons1999using, harman2001relationship}: in particular, Harman et al. \cite{harman2001relationship} presented a technique for reducing equivalent mutation generation using program dependence analysis. The idea is to avoid mutants that fail to propagate corrupted data into the inspection set at the probe point, a mutant that fails to propagate specific data means that no semantic change is being introduced on the software behavior. To carry on this analysis, the authors used a method called \textit{JR-dependence}, the method allows to relate variable and node pairs rather than simply considering nodes. With \textit{JR-dependence} is possible to know the set of variables that can and cannot be used to kill a mutant, which is beneficial for mutation testing. 
Consequently, Offutt et al. \cite{offutt2006class} used the guidelines by Harman et al. \cite{harman2001relationship} to eliminate equivalent mutants by applying the optimizations directly in the implementation of object oriented operators developed on the MuJava mutation testing tool. 

On the other hand, Kintis et al. \cite{kintis2014using,kintis2015medic} discovered that through static data-flow analysis is possible to reveal code locations that are sensitive to produce equivalent mutants together with the mutation operators being applied. The first pattern is called \textit{Use-Def} Problematic Pattern and seeks for uses of variables that reach a definition and can be mutated by a mutation operator that produces in-place changes (e.g., $\{x = (m + x)/2\}$ mutate to $\{x = (m + x++)/2\}$), specifically this pattern can be applied on definitions at the same line, basic block and between different basic blocks. The second pattern is called \textit{Def-Def} Problematic Pattern and seeks for subsequent definitions of a certain variable, in other words, if a definition reach another definition of the same variable without a prior use of the variable, then any mutation to the first definition cannot be revealed since its being redefined. On the experimental evaluation guided on 6 real-world programs, the technique was able to automatically detect 58 out of 84 equivalent mutants, leaving only a 30\% of mutants to be analyzed manually.

Research has proved that higher order mutation testing can be helpful in reducing equivalent mutants \cite{jia2009higher,kintis2010evaluating,offutt1992investigations,papadakis2010empirical}, since two or more mutations are applied simultaneously, the chances of producing equivalent mutants decreases consistently. For instance, Papadakis and Malevris \cite{papadakis2010empirical}, worked on a approach for higher order mutants for the C programming language that lead to a reduction of approximately 80-90\% of the generated equivalent mutants, with a fault detection ability loss only of 11-15\%. 
% For instance, Offutt demonstrated that the set of test data developed for first order mutants (FOMs) actually killed a higher percentage of mutants when applied to second order mutants (SOMs) \cite{offutt1992investigations}. 
% Jia and Harman identified six different types of HOMs \cite{jia2009higher} and presented a categorization of HOMs. They introduced the concept of subsuming and strongly subsuming HOMs.
% Polo et al. \cite{polo2009decreasing} studied three strategies to combine FOMs and generate mutants, and found that they can achieve significant cost reductions without losing any effectiveness (they reduced the number of mutants in a approximately 50\%, without much decrease in the quality of the test suite).
%Instead, Kintis et al. \cite{kintis2010evaluating} developed a solution for the Java language, they state that SOMs achieve higher collateral coverage for strong mutation as compared with third or higher order mutants. With their approach they obtained a mutant reduction of between 65-87\% and a loss of test effectiveness from 1.75-4.2\%.
% Mateo et al. \cite{mateo2012validating,madeyski2013overcoming} found that second order mutants (SOM) are significantly more efficient that first order mutants (FOM).

\endinput

\begin{table*}[ht]
\centering
\scriptsize
\begin{tabular}{lllllllp{4cm}}
\toprule
Author(s)          & Year   & Language & \begin{tabular}[c]{@{}l@{}}Largest\\Subject\end{tabular} & \begin{tabular}[c]{@{}l@{}}\#Eq. \\ Mutants\end{tabular} & \begin{tabular}[c]{@{}l@{}}Available \\ Tool\end{tabular} & Category                                                 & Findings                                                                                      \\
\midrule
Baldwin \& Sayward \cite{baldwin1979heuristics} & 1979   &          &                                                           &                                                          &                                                           & Detect                                                   & Compiler optimization can be used to detect equivalent mutants                                \\
Acree  \cite{acree1980mutation}       & 1980   & Fortran  &                                                           & 25                                                       &                                                           & Detect                                                   & Human make mistakes when they identify equivalent mutants                                     \\
Offutt \& Craft \cite{offutt1994using}   & 1994   & Fortran  & 52                                                        & 255                                                      &                                                           & Detect                                                   & Compiler optimisation can detect on average 45\% of equivalent mutants                        \\
Offutt \& Pan \cite{offutt1996detecting,offutt1997automatically}     & 1996-7 & Fortran  & 29                                                        & 695                                                      & Yes                                                       & Detect                                                   & Constraint-based testing can detect on average 47\% of equivalent mutants                     \\
Voas \& McGraw \cite{voas1997software}    & 1997   &          &                                                           &                                                          &                                                           & Detect                                                   & Slicing may be helpful in detecting equivalent mutants                                        \\
Hierons et al. \cite{hierons1999using}      & 1999   &          &                                                           &                                                          &                                                           & \begin{tabular}[c]{@{}l@{}}Detect/\\ Reduce\end{tabular} & Program slicing can be used to detect and assist the identification of equivalent mutants     \\
Harman et al.  \cite{harman2001relationship}    & 2001   &          &                                                           &                                                          &                                                           & \begin{tabular}[c]{@{}l@{}}Detect/\\ Reduce\end{tabular} & Dependence analysis can be used to detect and assist the identification of equivalent mutants \\
Adamopoulos et al  & 2004 \cite{adamopoulos2004overcome}  &          &                                                           &                                                          &                                                           & Reduce                                                   & Co-evolution can help in reducing the effects of equivalent mutants                           \\
Grun et al. \cite{grun2009impact}       & 2009   & Java     & 12,449                                                     & 8                                                        & Yes                                                       & Reduce                                                   & Coverage Impact can be used to classify killable mutants                                      \\
Schuler et al. \cite{schuler2009efficient}    & 2009   & Java     & 94,902                                                     & 10                                                       & Yes                                                       & Reduce                                                   & Invariants violations can be used to classify killable mutants                                \\
Schuler \& Zeller \cite{schuler2010covering,schuler2013covering} & 2010-2 & Java     & 94,902                                                     & 63                                                       & Yes                                                       & Reduce                                                   & Coverage impact can be used to classify killable mutants                                      \\
Nica \& Wotawa \cite{nica2012using}    & 2012   & Java     & 380                                                       & 1,424                                                     &                                                           & Detect                                                   & Constraint-based testing can detect equivalent mutants                                        \\
Kintis et al. \cite{kintis2012isolating,kintis2015employing}     & 2012-4 & Java     & 94,902                                                     & 89                                                       &                                                           & Reduce                                                   & Higher order mutants can be used to classify killable mutants                                 \\
Kintis \& Malevris \cite{kintis2014using} & 2014   & Java     & 25,909                                                     & 84                                                       &                                                           & Detect                                                   & Data-flow patterns can detect 69\% of the equivalent mutants introduced by the AOIS operator  \\
Papadakis et al. \cite{papadakis2014mitigating}    & 2014   & C        & 513                                                       & 5,589                                                     &                                                           & Reduce                                                   & Coverage impact can be used to classify killable mutants                                      \\
Papadakis et al. \cite{papadakis2015trivial}    & 2014   & C        & 362,769                                                    & 9,551                                                     & Yes                                                       & Detect                                                   & Compilers can be used to effectively automate the mutant equivalence detection               \\
\bottomrule
\end{tabular}
\end{table*}

