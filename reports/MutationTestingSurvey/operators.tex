% !TEX root = MutationTestingSurvey.tex

\section{Mutation Operators}
\label{sec:operators}

Mutation testing introduces small syntactical changes into the code of a program (source code, intermediate representation, or executable code) through a set of mutation operators.
Mutation operators have two goals, (1) induce simple syntax changes based on errors that programmers typically make, and (2) force common testing goals (e.g., code coverage testing).
%FABRIZIO: not clear what you mean with "force common testing goals (e.g., code coverage testing)."

Table XX provides an overview of existing mutation operators that can be applied to space software.
We selected operators for programming languages likely adopted in the context of space and embedded systems. These include operators dedicated to the C and C++ programming language, operators targeting Low-Level Intermediate Representation (LLVM-IR), operators dedicated to the ADA programming language, operators for the SQL and Simulink languages, operators that can be applied to any Object Oriented programming language but for which an implementation dedicated to C++ is not available. The last six columns of Table XX indicate the programming language targeted by the operator; when an operator support one of the specified programming languages we report a reference to the tool implementing the operator or, in case an implementation is not available, the paper in which the operator has been described.

The operators appearing in Table XX are organized in XX categories: ADA tasks, arithmetic, bitwise, casts, constants, control-flow, coverage, deletion, ADA expressions, floating points, function calls, logical, memory operations, object-oriented, ADA operands, relational, variable references, shift, SQL, statements, strings, structures and system-level operators. In the following, we provide an overview of each category:
\begin{itemize}
\item Category \emph{arithmetic} includes operators that performs mutations on arithmetic expressions and assignments, usually these mutations replaces an element by an operator $op \in \{+, -, *, /, \%\}$. 
\item Category \emph{bitwise} includes operators that performs bitwise mutations on expressions and assignments, these mutations aims for replacing an element of an expression by an operator $op \in \{\mid, \&, \^{}, \sim\}$. 
\item Category \emph{casts} includes operators that work by mutating casting expressions.
\item Category \emph{constants} includes operators that mutate constants in the code. 
\item Category \emph{control-flow} includes operators that modify and alter the execution flow of the running application.
%Fabrizio
\item Category \emph{coverage} includes operators that mutate the code in such a way that the static structure of the code (e.g., branches) is likely covered during execution.
\item Category \emph{deletion} includes operators that mutate the code by deleting statements, operators, constants and variables.  
\item Category \emph{floating points} includes operators working on floating point comparison (FPC).
\item Category \emph{function calls} includes operators that mutate function calls and their components (e.g., signature and parameters).
\item Category \emph{logical} includes operators that performs logical mutations on expressions and assignments; these mutations replace an element of an expression by an operator $op \in \{\&\&, \|, !\}$.
\item Category \emph{memory operations} includes operators seeking memory issues such as buffer overflow vulnerabilities, uninitialized memory access, NULL pointer dereferencing, and memory leaks caused by faulty heap management.
\item Category \emph{object-oriented} includes operators related to object oriented programming languages. These mutation operators aim to simulate problems concerning encapsulation, inheritance, method overloading, object and member replacement, polymorphism and language-specific features (e.g., Java and C++).
\item Category \emph{relational} includes a set of operators that perform relational mutations on expressions and assignments; usually these mutations replace an element by an operator $op \in \{<, <=, ==, !=, >, >=\}$.
\item Category \emph{variable references} includes operators mutating different types of variable references in the code (e.g., scalars, arrays and pointers).
\item Category \emph{shift} includes operators that performs shift mutations on expressions and assignments; usually, these mutations replace an element by an operator $op \in \{<<, <<<, >>, >>>\}$.
\item Category SQL includes operators that modify SQL clauses, SQL \texttt{NULL} operators, and SQL \texttt{WHERE} operators.
\item Category \emph{statements} includes operators performing syntactical changes at a statement-level granularity.
\item Category \emph{strings} includes operators that performs mutations on variables of string type.
\item Category \emph{structures} includes operators that mutate C/C++ structures.
%Fabrizio: "vulnerability" is a term relates to security, we should not use it except of these system-level class concerns only security
%Category \emph{system-level} includes operators that performs mutations at a system-level; usually, these mutations seek vulnerabilities on the different system functionalities. 
\item Category \emph{system-level} includes operators that performs mutations at a system-level; usually, these mutation operators aim to cause faults concerning the integration of system components or the configuration of the system itself. 
\item Category \emph{ADA expressions} includes operators that work by modifying expressions in the ADA programming language. 
\item Category \emph{ADA operands} includes operators that perform mutations by replacing operands in ADA expressions (e.g., variables, constants, records, arrays, pointers).
\item Category \emph{ADA tasks} includes operators that mutate ADA code at the granularity of tasks and aim to trigger problems related to concurrency in the program.
\end{itemize}
% SQL operators: SQL clauses, SQL NULL operators, SQL replacement operators, SQL WHERE operators
% object oriented: encapsulation, inheritance, method overloading, object and member replacement, polymorphism, language-specific features.

With a vast set of operators available in the literature, multiple studies for the identification of most efficient operators have been conducted~\cite{rothermel1996experimental}. The study conducted by Offutt et al.~\cite{rothermel1996experimental} identified the \emph{sufficient} set of operators, the set is composed by the absolute value insertion (ABS), arithmetic operator replacement (AOR), logical connector replacement (LCR), relational operator replacement (ROR) and unary operator insertion (UOI) operator. 
The sufficient set was then updated by Andrews et al.~\cite{andrews2005mutation} with the deletion statement operator (SDL), the operator was included because it ensures that every pointer-manipulation and field-assignment statement is properly tested, and avoids vulnerabilities that might not be checked by the rest of the sufficient operators. However, recent research has proven that the SDL operator is the most effective for fault detection~\cite{delamaro2014designing}.








