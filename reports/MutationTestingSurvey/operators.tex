% !TEX root = MutationTestingSurvey.tex

\subsection{Mutation Operators}
\label{sec:operators}

Mutation testing introduces small syntactical changes into the code of a program \MREVISION{C8}{(source code, intermediate representation, or executable code)} through a set of mutation operators.
The goal of the mutation operators is to simulate artificial faults by systematically introducing  simple syntax changes \MREVISION{C9}{based on errors that programmers typically make. 
Each of these operators model a specific type of fault. For example the use of a wrong variable is a fault, and the \emph{variable references} category of operators, introduced later in this section, model this type of fault.}

%Mutation operators have two goals, (1) induce simple syntax changes based on errors that programmers typically make, and (2) force common testing goals (e.g., code coverage testing).
%FABRIZIO: not clear what you mean with "force common testing goals (e.g., code coverage testing)."

Table~\ref{table:codeoperators} provides an overview of existing mutation operators that can be applied in \MREVISION{C10}{the context of space software and embedded systems.}
We selected operators for programming languages likely adopted in the context of space and embedded systems. These include operators dedicated to the C and C++ programming language, operators targeting Low-Level Intermediate Representation (LLVM-IR), operators dedicated to the ADA programming language, operators for the SQL and Simulink languages, operators that can be applied to any Object Oriented programming language but for which an implementation dedicated to C++ is not available.

The operators appearing in Table~\ref{table:codeoperators} are organized in 26 categories: ADA tasks, arithmetic, bitwise, casts, constants, control-flow, coverage, deletion, ADA expressions, floating points, function calls, logical, memory operations, object-oriented, ADA operands, relational, variable references, shift, SQL, statements, strings, structures, higher-order, system-configuration and system-level operators. \MREVISION{C11.d}{For each operator, we provide the name consistently used in the literature. The name of an operator is usually an acronym for the change performed in the source code (e.g., \emph{SDL} stands for \emph{statement deletion operator}).} In the following, we provide an overview of each category:
\begin{itemize}
\item Category \emph{arithmetic} includes operators that performs mutations on arithmetic expressions and assignments, usually these mutations replaces an element by an operator $op \in \{+, -, *, /, \%\}$. 
\item Category \emph{bitwise} includes operators that performs bitwise mutations on expressions and assignments, these mutations aims for replacing an element of an expression by an operator $op \in \{\mid, \&, \^{}, \sim\}$. 
\item Category \emph{casts} includes operators that work by mutating casting expressions.
\item Category \emph{constants} includes operators that mutate constants in the code. 
\item Category \emph{control-flow} includes operators that modify and alter the execution flow of the running application.
%Fabrizio
\item Category \emph{coverage} includes operators that mutate the code in such a way that the static structure of the code (e.g., branches) is likely covered during execution.
\item Category \emph{deletion} includes operators that mutate the code by deleting statements, operators, constants and variables.  
\item Category \emph{floating points} includes operators working on floating point comparison (FPC).
\item Category \emph{function calls} includes operators that mutate function calls and their components (e.g., signature and parameters).
\item Category \emph{logical} includes operators that performs logical mutations on expressions and assignments; these mutations replace an element of an expression by an operator $op \in \{\&\&, \|, !\}$.
\item Category \emph{memory operations} includes operators seeking memory issues such as buffer overflow vulnerabilities, uninitialized memory access, NULL pointer dereferencing, and memory leaks caused by faulty heap management.
\item Category \emph{object-oriented} includes operators related to object oriented programming languages. These mutation operators aim to simulate problems concerning encapsulation, inheritance, method overloading, object and member replacement, polymorphism and language-specific features (e.g., Java and C++).
\item Category \emph{relational} includes a set of operators that perform relational mutations on expressions and assignments; usually these mutations replace an element by an operator $op \in \{<, <=, ==, !=, >, >=\}$.
\item Category \emph{variable references} includes operators mutating different types of variable references in the code (e.g., scalars, arrays and pointers).
\item Category \emph{shift} includes operators that performs shift mutations on expressions and assignments; usually, these mutations replace an element by an operator $op \in \{<<, <<<, >>, >>>\}$.
\item Category SQL includes operators that modify SQL clauses, SQL \texttt{NULL} operators, and SQL \texttt{WHERE} operators.
\item Category \emph{statements} includes operators performing syntactical changes at a statement-level granularity.
\item Category \emph{strings} includes operators that performs mutations on variables of string type.
\item Category \emph{structures} includes operators that mutate C/C++ structures.
\item Category \emph{higher-order} includes operators for generating second- and higher-order mutants. \MREVISION{C11.c}{These strategies combine first order mutants to simulate more complex faults, motivated by a desire to capture subtle faults~\cite{jia2009higher}. Usually, each operator of this category introduce a strategy on how to combine first order operators to form a higher-order one. For example, the \emph{RMix} operator combines any two randomly selected first order operator to generate a higher-order mutant.} 
%Fabrizio: "vulnerability" is a term relates to security, we should not use it except of these system-level class concerns only security
%Category \emph{system-level} includes operators that performs mutations at a system-level; usually, these mutations seek vulnerabilities on the different system functionalities. 
\item Category \emph{system-configuration} includes operators that perform mutations at a system-configuration level; usually, these mutation operators aim to cause faults concerning the configuration of the system itself.
\item Category \emph{system-level} includes operators that performs mutations at a system-level; usually, these mutation operators aim to cause faults concerning the integration of system components. 
\item Category \emph{ADA expressions} includes operators that work by modifying expressions in the ADA programming language. 
\item Category \emph{ADA operands} includes operators that perform mutations by replacing operands in ADA expressions (e.g., variables, constants, records, arrays, pointers).
\item Category \emph{ADA tasks} includes operators that mutate ADA code at the granularity of tasks and aim to trigger problems related to concurrency in the program.
\end{itemize}
% SQL operators: SQL clauses, SQL NULL operators, SQL replacement operators, SQL WHERE operators
% object oriented: encapsulation, inheritance, method overloading, object and member replacement, polymorphism, language-specific features.

With a vast set of operators available in the literature, multiple studies for the identification of most efficient operators have been conducted~\cite{rothermel1996experimental}. The study conducted by Offutt et al.~\cite{rothermel1996experimental} identified the \INDEX{sufficient set of operators}, the set is composed by the absolute value insertion (ABS), arithmetic operator replacement (AOR), logical connector replacement (LCR), relational operator replacement (ROR) and unary operator insertion (UOI) operator. 
%\DONE{Is "deletion statement" or "statement deletion" ? OSCAR: Statement deletion}
The sufficient set was then updated by Andrews et al.~\cite{andrews2005mutation} with the statement deletion operator (SDL), the operator was included because it ensures that every pointer-manipulation and field-assignment statement is properly tested, and avoids vulnerabilities that might not be checked by the rest of the sufficient operators. However, recent research has proven that the SDL operator is the most effective for fault detection~\cite{delamaro2014designing}. \MREVISION{C11.a}{In Section~\ref{sec:opt:execution}, we provide references to research work~\cite{gopinath2015hard,zhang2013operator} showing that a random subset of the generated mutants is sufficient to evaluate the quality of a test suite.}

\newcommand{\OffuttADA}{\cite{offutt1996mutation}}
\newcommand{\MUSIC}{\cite{phan2018music}}
\newcommand{\Sciror}{\cite{hariri2018srciror}}
\newcommand{\Mull}{\cite{denisov2018mull}}
\newcommand{\Accmut}{\cite{wang2017faster}}
\newcommand{\Major}{\cite{just2014major}}
\newcommand{\MuJava}{\cite{ma2006mujava}}
\newcommand{\TuyaSQL}{\cite{tuya2007mutating}}
\newcommand{\BinhSimulink}{\cite{binh2012mutation}}
\newcommand{\Proteum}{\cite{delamaro2001interface}}
\newcommand{\Shahriar}{\cite{shahriar2008mutation}} % not a tool 
\newcommand{\SMT}{\cite{dan2012semantic}}
\newcommand{\MUSICShahriar}{\cite{shahriar2008music}}
\newcommand{\MuCPP}{\cite{delgado2017assessment}}
\newcommand{\jMINT}{\cite{grechanik2016mutation}}
\newcommand{\ILMutator}{\cite{derezinska2011object}}
\newcommand{\SQLChan}{\cite{chan2005fault}}
\newcommand{\BacterioSystem}{\cite{mateo2012validating}}
\newcommand{\Milu}{\cite{jia2008milu}}
\newcommand{\Judy}{\cite{madeyski2010judy}}


The last six columns of Table~\ref{table:codeoperators} indicate the programming language targeted by the operator; when an operator supports one of the specified programming languages we report a reference to the tool implementing the operator or, in case an implementation is not available, the paper in which the operator has been described. 
Table~\ref{table:codeMutation:references} provides the names of the tools and approaches referenced in Table~\ref{table:codeoperators}, along with a URL for the download of the tool, if available.

\input{tables/code_operators_references}

\input{tables/code_operators}

\MREVISION{C11.b}{Table~\ref{table:codeoperatorssummary} shows a summary of the number of operators we collected for each category and the context where they can be applied. The table also provides a strategy to prioritize the mutation operators for space-context software. In particular, in the last column \textit{Relevance for FAQAS} we prioritized the categories according to the effectiveness and ease of implementation. 
Based on this criterion, we selected \INDEX{deletion operators} as the most relevant, since according to the literature they form a cost-effective alternative to other operators in terms of amount of mutants produced and equivalent mutants~\cite{delamaro2014designing}. 
Following the same criterion, we then selected the \INDEX{sufficient set of operators}, because most of the mutation tools already implement them, and because they are proven to be fault-detection effective~\cite{offutt1996experimental,andrews2005mutation,siami2008sufficient}.
}

\input{tables/code_operators_summary}

