% !TEX root = MAIN.tex

\chapter{SEMUS - Operations Manual}
\label{chapter:semus:operations}

\section{Set-up and Initialization}
\label{sec:install:semus}

\SEMUS depends directly on \SEMU for test inputs generation, and \MASS for mutant generation.

For this reason, we provide a Dockerfile containing all the commands necessary to download, install and prepare a full installation of \SEMU and MASS. The Dockerfile can be found at \texttt{\SEMUS/Dockerfile}. The installation will take place the first time the Docker image is created through the Bash script \texttt{cd\_semu\_docker.sh}, no further installation is required for now.

\subsection{Dependencies}

%\TODO{should we add the LLVM version?}
%\OSCAR{llvm is installed automatically in the previous step, only clang3.8 is necessary}

\begin{itemize}
	\item Linux packages: 
\begin{itemize}	
	\item \texttt{docker-ce} 
	\item \texttt{docker-ce-cli} 
	\item \texttt{containerd.io}
	\end{itemize}
\end{itemize}


\section{Getting started}

\subsection{Initialization of the \SEMUS workspace}
\label{sec:semus:initialization}

\DONE{Following is not clear. It seems that the end-user has a folder case\_studies/ASN to copy stuff from; however, you do not explain how to retrieve that folder. I would call it TEMPLATES rather than ASN, no?}
\TODO{I added a text explaining that we provide ASN and MLFS along SEMuS, and that scripts shall be copied from ASN. However, I agree with you that we should add a templates folder inside the repository.}

\SEMUS needs a dedicated folder structure for running the test generation on a case study. 
For this reason, the engineer shall create the following directory structure under the folder \texttt{case\_studies}, assuming the name of the case study is stored in the variable \texttt{\$SUT}:

\begin{itemize}
	\item \texttt{case\_studies/\$SUT/:}
	\begin{itemize}
		\item \texttt{scripts/}
		\item \texttt{util\_codes/}
		\item \texttt{WORKSPACE/}
	\end{itemize}
\end{itemize}

The \SEMUS repository we provide, contains already the configured files and the source code of two open-source case studies, the ASN.1 and MLFS.
After the creation of the folder structure, the engineer shall copy the scripts for (1) creating the mutants, (2) running the toolset, (3) configuring \SEMUS. The scripts shall be copied from the ASN case study folder. The commands for copying these files are provided below:

\begin{lstlisting}[language=bash]
  $ cd case_studies/ASN/scripts
  $ cp create_mutants.sh run.sh docker_run.sh faqas_semus_config.sh ../../$SUT/scripts
\end{lstlisting}

At this step, the engineer shall also provide a compilation database file of the SUT, to be placed inside \texttt{\$SUT/scripts} with the name \texttt{compile\_commands.json}. Note that the paths defined within the database file must be full paths. The compilation database file provides the necessary compilation commands of each source for the source mutation and the test generation steps of the methodology.

Next, the engineer shall copy the scripts necessary for generating the test templates for guiding the test generation. This can be done through the following commands:

\begin{lstlisting}[language=bash]
  $ cd case_studies/ASN/util_codes
  $ cp generate_direct.py generate_template_config.json ../../$SUT/util_codes
\end{lstlisting}

Last, the engineer shall place inside the folder \texttt{case\_studies/\$SUT/WORKSPACE/DOWNLOADED} (1) the SUT source code, and (2) the list of live mutants (provided by \MASS output).

\subsection{\SEMUS Configuration}

There is one Bash script, and one JSON file that should be edited by the engineer to configure \SEMUS. The Bash script enables \SEMUS to correctly identify the SUT paths (e.g., source code folder), the SUT compilation commands, output folder, and the configuration of \SEMUS itself (e.g., configuration of the heuristics, maximum memory, test generation timeout). Instead, the JSON file indicates for each function under test, the values that should be printed out, so \SEMUS can determine if a mutant has been killed.

\input{tables/to_conf_semus}

Table~\ref{table:to_conf_semus} provides a summary of the Bash \SEMUS configuration file and a brief description. A detailed description of the SEMuS configuration file follows in Section~\ref{sec:semus_config}.

\input{tables/ttg_semus}

Table~\ref{table:ttg_semus} provides a summary of the JSON \SEMUS configuration file and a brief description. A detailed description of the JSON configuration file follows in Section~\ref{sec:json_config}.


\subsubsection{Edit faqas\_semus\_config.sh}
\label{sec:semus_config}

Within file \texttt{faqas\_semus\_config.sh} there are multiple environment variables that must be set; they are shown in Listing~\ref{listing:SEMUS:conf}.

\begin{lstlisting}[language=bash,label=listing:SEMUS:conf,caption=faqas\_semus\_conf.sh file.]

# Root folder of the case study
FAQAS_SEMU_CASE_STUDY_TOPDIR=

# SEMuS workspace for the case study
FAQAS_SEMU_CASE_STUDY_WORKSPACE=

# SEMuS output folder, to be placed inside the workspace
FAQAS_SEMU_OUTPUT_TOPDIR=

# Root folder for storing the generated mutants
FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR=

# Root folder of the case study source code
FAQAS_SEMU_REPO_ROOTDIR=

# Full path of the source file under analysis
FAQAS_SEMU_ORIGINAL_SOURCE_FILE=

# Relative path of the source file under analysis
FAQAS_SEMU_COMPILE_COMMAND_SPECIFIED_SOURCE_FILE=

# Folder for storing the generated mutants for the specified source file
FAQAS_SEMU_GENERATED_MUTANTS_DIR=

# Bash function for building the source file under analysis, to be specified in string format
FAQAS_SEMU_BUILD_CODE_FUNC_STR='FAQAS_SEMU_BUILD_CODE_FUNC() { }'

# Bash function for building the source file to LLVM bitcode
FAQAS_SEMU_BUILD_LLVM_BC() { }

# Root folder for the meta mutant
FAQAS_SEMU_META_MU_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/meta_mu_topdir

# Path of the source file (i.e., C file) of the meta mutant
FAQAS_SEMU_GENERATED_META_MU_SRC_FILE=

# Path of the source file (i.e., LLVM bitcode file) of the meta mutant
FAQAS_SEMU_GENERATED_META_MU_BC_FILE=

# Folder for storing intermediate files for the generated inputs 
FAQAS_SEMU_GENERATED_META_MU_MAKE_SYM_TOP_DIR=

# Folder for storing the generated inputs 
FAQAS_SEMU_GENERATED_TESTS_TOPDIR=

# Timeout in seconds for the test generation process
FAQAS_SEMU_TEST_GEN_TIMEOUT=

# Configuration array for SEMu heuristics. The accepted values of 'PSS' are 'RND' for random and 'MDO' for minimum distance to output
FAQAS_SEMU_HEURISTICS_CONFIG='{
        "PL": 
        "CW": 
        "MPD": 
        "PP": 
        "NTPM": 
        "PSS": 
}'

# Maximum test generation memory in MB
FAQAS_SEMU_TEST_GEN_MAX_MEMORY=

# Parameter to stop test generation when the memory limit is reached
FAQAS_SEMU_STOP_TG_ON_MEMORY_LIMIT=

# Parameter to stop forking states when the memory limit is reached
FAQAS_SEMU_TG_MAX_MEMORY_INHIBIT=

\end{lstlisting}

Listing~\ref{listing:ASN:conf} provides an example of faqas\_semus\_conf.sh file configured for the ASN case study.

\begin{lstlisting}[language=bash,label=listing:ASN:conf,caption=faqas\_semus\_conf.sh file for ASN case study.]

FAQAS_SEMU_CASE_STUDY_TOPDIR=../

FAQAS_SEMU_CASE_STUDY_WORKSPACE=$FAQAS_SEMU_CASE_STUDY_TOPDIR/WORKSPACE

FAQAS_SEMU_OUTPUT_TOPDIR=$FAQAS_SEMU_CASE_STUDY_WORKSPACE/OUTPUT

FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/mutants_generation

FAQAS_SEMU_REPO_ROOTDIR=$FAQAS_SEMU_CASE_STUDY_WORKSPACE/DOWNLOADED/casestudy

FAQAS_SEMU_ORIGINAL_SOURCE_FILE=$FAQAS_SEMU_REPO_ROOTDIR/test.c

FAQAS_SEMU_COMPILE_COMMAND_SPECIFIED_SOURCE_FILE=./test.c

FAQAS_SEMU_GENERATED_MUTANTS_DIR=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/test

FAQAS_SEMU_BUILD_CODE_FUNC_STR='
FAQAS_SEMU_BUILD_CODE_FUNC()
{
    local in_file=$1
    local out_file=$2
    local repo_root_dir=$3
    local compiler=$4
    local flags="$5"
    # compile
    $compiler $flags -g -Wall -Werror -Wextra -Wuninitialized -Wcast-qual -Wshadow -Wundef -fdiagnostics-show-option -D_DEBUG -I $repo_root_dir -O0 $in_file -o $out_file $flags
    return $?
}
'

FAQAS_SEMU_BUILD_LLVM_BC()
{
    local in_file=$1
    local out_bc=$2
    eval "$FAQAS_SEMU_BUILD_CODE_FUNC_STR"
    FAQAS_SEMU_BUILD_CODE_FUNC $in_file $out_bc $FAQAS_SEMU_REPO_ROOTDIR clang '-c -emit-llvm'
    return $?
}

FAQAS_SEMU_META_MU_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/meta_mu_topdir

FAQAS_SEMU_GENERATED_META_MU_SRC_FILE=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/test.MetaMu.c

FAQAS_SEMU_GENERATED_META_MU_BC_FILE=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/test.MetaMu.bc

FAQAS_SEMU_GENERATED_META_MU_MAKE_SYM_TOP_DIR=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/"MakeSym-TestGen-Input"

FAQAS_SEMU_GENERATED_TESTS_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/test_generation

# timeout in seconds
FAQAS_SEMU_TEST_GEN_TIMEOUT=7200

# This is the config for SEMU heuristics. The accepted values of 'PSS' are 'RND' for random and 'MDO' for minimum distance to output
FAQAS_SEMU_HEURISTICS_CONFIG='{
        "PL": "0",
        "CW": "4294967295",
        "MPD": "0",
        "PP": "1.0",
        "NTPM": "5",
        "PSS": "RND"
}'

# max Test Generation memory in MB
FAQAS_SEMU_TEST_GEN_MAX_MEMORY=2000

# Set to 'ON' to stop test generation when the memory limit is reached
FAQAS_SEMU_STOP_TG_ON_MEMORY_LIMIT='OFF'

# Set this to 'ON' so thae the states the sate fork is disabled when the memory limit is reached, to avoid going much over it
FAQAS_SEMU_TG_MAX_MEMORY_INHIBIT="ON"
\end{lstlisting}


\subsubsection{Edit generate\_template\_config.json}
\label{sec:json_config}

Within file \texttt{generate\_template\_config.json} there are multiple variables that must be set; they are shown in Listing~\ref{listing:json:conf}.

\begin{lstlisting}[language=bash,label=listing:json:conf,caption=generate\_template\_config.json file.]
{
    # Specify a type as key and the type conversion template as value, 
    # Where the placeholder for the expression to convert should be specified as the string '{}'
    # e.g. "TYPES_TO_INTCONVERT": {"flag": "(int){}"},
    "TYPES_TO_INTCONVERT": {},

    # Specify a type as key and the object printing code as value.
    # Where the placeholder for the object to print must be specified as the string '{}'
    # Do not forget to escape the backslashes and double quoted in printf fmt.
    # e.g. "TYPES_TO_PRINTCODE": {"struct XY *": "printf(\"FAQAS-SEMU-TEST_OUTPUT: X=%d, Y=%s\\n\", {}->x, {}->y)"}
    "TYPES_TO_PRINTCODE": {},

    # Specify the names of function arguments that are used as function output (passed by reference for output only)
    # e.g. "OUT_ARGS_NAMES": ["pErrCode"],
    "OUT_ARGS_NAMES": [],

    # Specify the names of function arguments that are used both as function input and output (passed by reference)
    # e.g. "IN_OUT_ARGS_NAMES": ["inoutArg"],
    "IN_OUT_ARGS_NAMES": [],

    # Specify a type as key and the pre 'klee_make_symbolic' statement initialization code as value,
    # The placeholder for the object to initialize must be specified as the string '{}'
    # e.g. "TYPE_TO_INITIALIZATIONCODE": {"struct head": "{}.next = malloc(sizeof(struct head));\n{}.next->next = NULL;"}
    "TYPE_TO_INITIALIZATIONCODE": {},

    # Specify how to make an object symbolic (specialy useful for objects that are initialized, like pointers).
    # The object type is the dict key and a dict of field accesses and their type is the dict value.
    # The placeholder for the object to make symbolic must be specified as the string '{}'
    # e.g. "TYPE_TO_SYMBOLIC_FIELDS_ACCESS": {"struct head": {"{}.data": "char [3]", "{}.next->data": "char [3]"}}
    "TYPE_TO_SYMBOLIC_FIELDS_ACCESS": {},

    # Specify the underlying type for a void pointer (the data type pointed by the void pointer).
    # for instance, if the function is to be called with an `int` array for a void pointer parameter,
    # set `VOID_ARG_SUBSTITUTE_TYPE` to "int".
    # Set the value to the empty string ("") to let the user specify at runtime on case by case
    # Set the value to `null` (JSON equivalent to None) to let the user change the types `void` 
    # directly in the generated templates
    # e.g. VOID_ARG_SUBSTITUTE_TYPE: "char"
    VOID_ARG_SUBSTITUTE_TYPE: "",

    # Specify, for pointer parameters, the number of elements it points to (must be > 0)
    # This will give the flexibility to set the number of elements the pointer points to.
    # The default value is `1`, for non specified types.
    # e.g. ARG_TYPE_TO_ITS_POINTER_ELEM_NUM: {"int *": 2, "char *": 6}
    # This let and array of 2 for int pointer and array of 6 for char pointer, 
    # and an array of 1 for unsigned pointer
    ARG_TYPE_TO_ITS_POINTER_ELEM_NUM: {}
}
\end{lstlisting}

Listing~\ref{listing:ASN:jsonconf} provides an example of generate\_template\_config.json file configured for the ASN case study.

\begin{lstlisting}[language=bash,label=listing:ASN:jsonconf,caption=generate\_template\_config.json file for ASN case study.]
{
    "TYPES_TO_INTCONVERT": {"flag": "(int){}"},
    "TYPES_TO_PRINTCODE": {},
    "OUT_ARGS_NAMES": ["pErrCode"],
    "IN_OUT_ARGS_NAMES": [],
    "TYPE_TO_INITIALIZATIONCODE": {},
    "TYPE_TO_SYMBOLIC_FIELDS_ACCESS": {},
    "VOID_ARG_SUBSTITUTE_TYPE": "",
    "ARG_TYPE_TO_ITS_POINTER_ELEM_NUM": {}
}
\end{lstlisting}

\subsection{Running \SEMUS}
\label{sec:semuslaunch}

To run \SEMUS, it is necessary to generate the test templates as first step; this can be achieved through the following command:
%there is a dedicated Bash script for doing so:

\begin{lstlisting}[language=bash]
 $ case_studies/$SUT/util_codes/generate_direct.py ../WORKSPACE/DOWNLOADED/casestudy/test.c direct \
                    " -I../WORKSPACE/DOWNLOADED/casestudy/" -c generate_template_config.json

\end{lstlisting}

The previous command will generate inside the directory \texttt{case\_studies/\$SUT/util\_codes} one folder for each source under analysis, and inside of these folders, one template for each function under test.

The test generation process can be started with the command shown in Listing~\ref{listing:semus_launch}. 

Note the following:
\begin{itemize}
	\item the first time the command is invoked, Docker will install all the dependencies of \SEMUS (i.e., \SEMU and \MASS).
	\item the environment variable \texttt{ENV\_FAQAS\_SEMU\_SRC\_FILE} has to be set before invoking; this variable indicates the source file for which the test generation will be targeted
\end{itemize}

\begin{lstlisting}[language={}, label=listing:semus_launch]
ENV_FAQAS_SEMU_SRC_FILE=test.c ./docker_run.sh [<starting-step>] [<mutants-list-file> <output-dir-for-pre-semu-and-semu>]
\end{lstlisting}

Where:
\begin{itemize}
	\item starting-step: is the step of the pipeline from which to start, possible values are \texttt{\{mutation, compile, presemu, semu, unittests\}}
	\begin{itemize}
		\item mutation: the process starts from the mutant generation step
		\item compile: the process starts from the mutant compilation step
		\item presemu: the process starts from the preparation of the meta mutant step (i.e., Pre-SEMu)
		\item semu: the process starts from the test generation step itself
		\item unittests: the process starts from the conversion of KLEE tests to unit tests step
	\end{itemize}
	\item mutants-list-file: is the file containing the list of mutants to use during the phases pre-semu and semu.
	\item output-dir-for-pre-semu-and-semu: directory to store the output of pre-semu and semu phases, when the mutants list is specified.
\end{itemize}

An example for launching the test generation from the mutation generation step follows:

\begin{lstlisting}[language=bash]
 $ ENV_FAQAS_SEMU_SRC_FILE=test.c scripts/docker_run.sh mutation WORKSPACE/DOWNLOADED/live_mutants WORKSPACE/OUTPUT/live_mutants_output
\end{lstlisting}

\subsection{\SEMUS results}

\SEMUS results can be found at the folder \texttt{case\_studies/\$SUT/WORKSPACE/OUTPUT}:

\begin{itemize}
	\item \texttt{mutants\_generation}: this folder contains the mutant sources generated by \MASS
	\item \texttt{live\_mutants\_output/mutants\_generation}: this folder stores the source files and the compiled objects of the meta mutant files (e.g., \texttt{*.MetaMu.c} and \texttt{*.MetaMu.bc})
	\item \texttt{live\_mutants\_output/test\_generation}: this folder contains the outputs of \SEMUS concerning the test generation step, this directory contains one folder for each test template. Furthermore, it also contains the following folders:
	\begin{itemize}
		\item \texttt{direct/TEMPLATE/FAQAS\_SEMu-out/semu}: \SEMU output (e.g., KLEE tests files, execution traces)
		\item \texttt{direct/TEMPLATE/FAQAS\_SEMu-out/produced-unittests}: Unit test cases converted from \SEMU output
	\end{itemize}

\end{itemize}



\section{Normal Termination}


Each step of \SEMUS is executed when invoked and a result is generated. There is no software interruption foreseen during the computation and the procedure terminates by returning the result.
If the engineer decides to interrupt \SEMUS execution, it can be done by sending a signal interrupt \texttt{SIGINT} to the running process.

\section{Error Conditions}

There is no error condition handling in the \FAQAS. If all preconditions are met, there should not be any error.

\section{Recover Runs}

%\DONE{Shall we say that an engineer can restart the process form a task if all the precondiions are met?}

If for any reason the execution of \SEMUS is interrupted, an engineer can restart the process from a specific step if all preconditions are met. This is possible since each \SEMUS step work by processing data that is permanently stored by previous steps.
