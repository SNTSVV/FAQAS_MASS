% !TEX root = MAIN.tex

\chapter{\DAMA - Operations Manual}

\section{Set-up and Initialization}

\subsection{Dependencies}

\begin{itemize}
	\item \texttt{Python 3.6.8} or higher
	\item \texttt{GNU bash, version 4.2.46} or higher
\end{itemize}

\subsection{Initialization of the \DAMA workspace}

All the script for the \DAMA pipeline are contained in the \texttt{damat-pipeline} folder.
All \DAMA steps will take place inside this folder, which shall be placed by the engineer in a path of their choosing.

The folder shall contain the following structure and files:

\begin{itemize}
	\item \texttt{DAMAt\_configure.sh}: this script defines the necessary variables for the execution of \DAMA. They shall be set by the user.
	\item \texttt{DAMAt\_probe\_generation.sh}: this script set the variables necessary to generate the data mutation API and execute the python script \texttt{generateDataMutator.py} to generate them.
	\item \texttt{DAMAt\_mutants\_launcher.sh}: this script starts the \DAMA pipeline.
	\item \texttt{generateDataMutator.py}: this is the script that generates the \DAMA mutation API.
	\item \texttt{DDB\_TEMPLATE\_header.c} and \texttt{DDB\_TEMPLATE\_footer.c}: these are templates used to generate the \DAMA API by \texttt{generateDataMutator.py}
	\item \texttt{DAMAt\_compile.sh}: this is a stub of the script used to compile a mutant, which shall be completed by the user.
	\item \texttt{DAMAt\_run\_tests.sh}: this is a stub of the script used to run the tests, which shall be completed by the user.
	\item \texttt{data\_analysis}: a folder containing five python scripts used for the generation of the final results:
	\begin{itemize}
	  \item \texttt{beautify\_results.py}: this script renders the raw results from the execution of the tests in a more readable format.
	  \item \texttt{get\_coverage.py}: this script analizes the results of the fault model coverage.
	  \item \texttt{get\_operator\_coverage.py}: this script analizes the results of the operator coverage.
	  \item \texttt{get\_stats.py}: this script produces statistics from the mutants' execution.
		\item \texttt{get\_final\_results.py}: this script produces a summary of the execution of \DAMA.
	\end{itemize}
	\item \texttt{pipeline\_scripts}: a folder containing the four scripts that make up the \DAMA pipeline:
	\begin{itemize}
		\item \texttt{DAMAt\_obtain\_coverage.sh}: this script obtains fault model coverage data in order to execute only the tests that cover each mutant.
		\item \texttt{get\_mutant\_test\_list.py}: this script produces the list of test against which avery mutant shall be executed.
	  \item \texttt{DAMAt\_compile\_and\_run\_mutants.sh}: this scripts compile each mutant and run it against the SUT test suite.
		\item \texttt{DAMAt\_data\_analysis.sh}: this script executes all the data analysis steps at the end of the execution of the \DAMA pipeline
	\end{itemize}
	\item \texttt{fault\_model.csv}: an example of a \DAMA fault model in csv format.
 	\item \texttt{tests.csv }: an example of list of test cases and nominal times in csv format.
\end{itemize}

\subsection{Writing a list of all test cases}
\label{subsec:test_list}
The user shall provide the list of all the test cases with corresponding nominal time in csv format, using the \texttt{tests.csv } file as an example.
In the first column of the csv file there shall be an identifier for the test case. The second column shall contain the nominal execution time in ms.

\begin{lstlisting}
test_01,11002
test_02,13456
test_03,58347
\end{lstlisting}

This file will be used by the \DAMA pipeline for two purposes:
\begin{enumerate}
	\item the nominal execution time will be used to set a timeout for each test case.
	\item the whole list will be used to generate a list for each mutant containing only the test cases that cover it.
\end{enumerate}

\subsection{Setting the variables for the \DAMA pipeline}

% The user shall then modify three scripts to configure the \DAMA pipeline:
% \begin{itemize}
% 	\item \texttt{DAMAt\_configure.sh}
% 	\item \texttt{DAMAt\_compile.sh}
% 	\item \texttt{DAMAt\_run\_tests.sh}
% \end{itemize}

The user must set the following variables inside the \texttt{DAMAt\_configure.sh} script
\begin{lstlisting}[language=bash]

tests_list=$DAMAt_FOLDER/tests.csv

fault_model=$DAMAt_FOLDER/fault_model.csv

buffer_type="unsigned char"

singleton="TRUE"

padding=0

\end{lstlisting}

The variable \texttt{test\_list} shall be set to the path of the csv containing the test names and execution times.

The variable \texttt{fault\_model} shall be set to the path of the csv containing the fault model of the SUT that the user shall define for the SUT.

The variable \texttt{buffer\_type} shall contain the type of the elements of the buffer that will be targeted by the mutation.

The variable \texttt{singleton} shall be set to \texttt{TRUE} or \texttt{FALSE}. If set to \texttt{TRUE}, the Fault Model will be initialized in a singleton variable, to avoid memory issues.

The variable \texttt{padding} shall be set to an integer number representing the number of bytes to skip at the beginning of the tarrget buffer. Normally it shall be set to \texttt{0}, but it can be used to skip the header of the buffer if needed.

\subsection{Setting up the compilation of the mutants}

The user shall modify \texttt{DAMAt\_compile.sh} to include the commands for the compilation of the mutants.
Every mutant is identified by an integer called "MutationOpt".
To enable the data-driven mutation, the user shall compile the SUT with this macro enabled:

\texttt{-DMUTATIONOPT=<MutationOpt>}.

To use the singleton mode, the user shall compile the SUT with this macro enabled:

 \texttt{ -D\_FAQAS\_SINGLETON\_FM\="TRUE"}.

A way to do it is to include the following lines in the SUT makefile:
\begin{lstlisting}[language=bash]
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DMUTATIONOPT=$ENV{MUTATIONOPT}")
# comment the following line if you do not want to use the singleton option.
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D_FAQAS_SINGLETON_FM=$ENV{_FAQAS_SINGLETON_FM}")
\end{lstlisting}
and then export the corresponding variables in the \texttt{DAMAt\_compile.sh} script as shown in the \texttt{DAMAt\_compile.sh} stub.

The contents of the \texttt{DAMAt\_compile.sh} stub are portrayed in the following.

\begin{lstlisting}[label={lst:compile},language=bash]

#!/bin/bash

mutant_id=$1
singleton=$2

###############################################################################
#enabling extended pattern matching features:
shopt -s
#options for enabling aliases:
shopt -s expand_aliases
###############################################################################


echo "------------------------------------"
echo "------------------------------------"
echo "Mutant opt: "$mutant_id
echo "------------------------------------"
echo "------------------------------------"

# The user shall complete the following section:
###############################################################################
#exporting the operation counter
export MUTATIONOPT=$mutant_id

if [$singleton == "TRUE"]; then
export _FAQAS_SINGLETON_FM=$singleton
fi

# here the user must invoke the compilation of the SUT, we provided a simple example.

compilation_folder="/home/SUT"

pushd $compilation_folder

make install-debug

    if [ $? -eq 0 ]; then
        echo $x " compilation OK"
    else
        echo $x " compilation FAILED"
    fi

popd


\end{lstlisting}

Once completed, the \texttt{DAMAt\_compile.sh} script shall take as input the value of the MutationOpt that refers to the mutant being currently compiled and of the singleton variable, and then compile the SUT accordingly.

\subsection{Setting up the execution of the test suite against the mutants}

The user shall modify \texttt{DAMAt\_run\_tests.sh} stub to include the commands for the execution of the mutants.

Every mutant is identified by an integer called "MutationOpt".
This script shall take as input the mutationOpt and a list of test in the format described in section~\ref{subsec:test_list}.

The user shall complete the stub by substiting the generic execution function with a command or a series of commands that execute a specific test case using the test identifier specified in the csv as input.
The user shall use the \texttt{timeout} command as shown in the example included in the stub to set a timeout.

The output of the the new function shall be \texttt{0} if the test passes, different from \texttt{0} if it fails and \texttt{124} in case of timeout.

The contents of the \texttt{DAMAt\_run\_tests.sh} stub are portrayed in the following.

\begin{lstlisting}[label={lst:run_tests},language=bash]

#!/bin/bash

mutant_id=$1
tests_list=$2
DAMAT_FOLDER=$3
results_dir=$DAMAT_FOLDER/results

mutant_dir=$results_dir/run_"$mutant_id"
execution_log=$mutant_dir/"$mutant_id"_execution.out
coverage_file=$mutant_dir/"$mutant_id"_coverage.csv
results_file=$mutant_dir/main.csv

###############################################################################
#date in milliseconds
start_time=$(($(date +%s%N)/1000000))

mkdir $results_dir
echo "this is the results folder: $results_dir"
mkdir $mutant_dir
echo "this is the folder of this mutant $mutant_dir"
touch $execution_log
echo "this is the logfile of the tests' execution $execution_log"
touch $coverage_file
echo "this is the file with the results $results_file"
touch $results_file
echo "this is the coverage file: $coverage_file"
export FAQAS_COVERAGE_FILE=$coverage_file
export _FAQAS_SINGLETON_FM

###############################################################################

while IFS="," read -r p || [ -n "$p" ];do

    mutant_start_time=$(($(date +%s%N)/1000000))

    # obtaining test number to be executed
    read tst <<< $(awk -F',' '{print $1}' <<< "$p")

    # obtaining corresponding timeout for the test case
    TIMEOUT=$(echo "$p" | awk -F',' '{$2=($2*4)/1000; printf("%.0f\n", $2);}')

    echo "*********************************************************"
    echo "*********************************************************"
    echo "Running mutant $mutant_id against test case "$tst
    echo "*********************************************************"
    echo "*********************************************************"
    echo -n "${mutant_id};COMPILED;${tst};" >> $results_file


###############################################################################
# here the user shall call the execution of the current test case,
# we provided a simple example

  timeout $TIMEOUT bash execute_test_case.sh $tst


###############################################################################
#the exec return code should be 0 if the test case passes, 1 if the test case fails and 124 in case of a timeout
EXEC_RET_CODE=$?


  mutant_end_time=$(($(date +%s%N)/1000000))
  mutant_elapsed="$(($mutant_end_time-$mutant_start_time))"



  if [ $EXEC_RET_CODE -ge 124 ]; then
     echo "Test return code: [$EXEC_RET_CODE]"
     echo "Mutant timeout by $tst"
     echo -ne "TIMEOUT;KILLED_${EXEC_RET_CODE};${mutant_elapsed}\n" >> $results_file

  else
      if [ $EXEC_RET_CODE -eq 0 ]; then
        echo "Test return code: [$EXEC_RET_CODE]"
        echo -ne "PASSED;LIVE;${mutant_elapsed}\n" >> $results_file

      else
        echo "Test return code: [$EXEC_RET_CODE]"
        echo "Mutant killed by $tst"
        echo -ne "FAILED;KILLED;${mutant_elapsed}\n" >> $results_file
      fi
  fi


###############################################################################

	#create a different coverage file for every test

	NEW_COVERAGE_FILE=$mutant_dir/coverage_"$tst".csv
	cp $coverage_file $NEW_COVERAGE_FILE
	>$FAQAS_COVERAGE_FILE

done < $tests_list

rm -rf ~/Obsw/Test/System/testresults/*

end_time=$(($(date +%s%N)/1000000))
elapsed="$(($end_time-$start_time))"

echo "elapsed time $elapsed [ms]"


\end{lstlisting}

\section{Executing \DAMA}

\subsection{Running \DAMA on Single Machine}
\label{sec:dama_singlelaunch}

%\DONE{Add a paragraph that explains that you are going to describe two ways of running MASS}
%
% \DAMA can be executed in two modes, \emph{single machine} and \emph{shared resources mode}. The single machine mode provides the advantage of running \DAMA in an unsupervised mode, executing the methodology on one step. Instead, the shared resources facilities mode gives the possibility of running multiple steps in parallel and executing a higher number of mutants, in a similar time frame, with respect to the single machine mode. In this section we describe the \emph{single machine}, Section \ref{sec:dama_shared} covers the \emph{shared resources mode}.

\DAMA works in six steps:

\begin{enumerate}
	\item The user prepares a fault model specification tailored to the SUT.
	\item \DAMA generates a mutation API with the functions that modify the data according to the provided fault model.
	\item The user manually modifies the SUT by introducing mutation probes (i.e., invocations to the mutation API) into its source code.
	\item \DAMA generates and compiles mutants.
	\item \DAMA executes the test suite againts all the mutants.
	\item \DAMA generates mutation analysis results.
\end{enumerate}

\subsubsection{Step 1}
The engineer is expected to write a fault model in the csv format with the definition of all the mutation operators they want to apply.
An example of fault model is contained in the \texttt{damat-pipeline} folder and in listing~\ref{lst:fault_model}.

\begin{lstlisting}[label={lst:fault_model}]
FaultModel,DataItem,Span,Type,FaultClass,Min,Max,Threshold,Delta,State,Value
fault_model_01,0,1,BIN,BF,3,3,NA,NA,-1,1
fault_model_01,0,1,BIN,BF,4,4,NA,NA,-1,1
fault_model_01,0,1,BIN,BF,5,7,NA,NA,-1,1
fault_model_02,12,2,DOUBLE,VAT,NA,NA,3.6,0.1,NA,NA
fault_model_02,12,2,DOUBLE,FVAT,NA,NA,3.6,0.1,NA,NA
fault_model_02,14,2,DOUBLE,VAT,NA,NA,33.53,0.01,NA,NA
fault_model_02,14,2,DOUBLE,FVAT,NA,NA,33.53,0.01,NA,NA
fault_model_02,14,2,DOUBLE,VBT,NA,NA,24,1,NA,NA
fault_model_02,14,2,DOUBLE,FVBT,NA,NA,24,1,NA,NA
fault_model_03,0,1,HEX,IV,NA,NA,NA,NA,NA,0x51
fault_model_03,0,1,HEX,IV,NA,NA,NA,NA,NA,0x52
fault_model_03,0,1,HEX,IV,NA,NA,NA,NA,NA,0x53
fault_model_03,0,1,HEX,IV,NA,NA,NA,NA,NA,0x54
fault_model_03,0,1,HEX,IV,NA,NA,NA,NA,NA,0x56
\end{lstlisting}

For details on the available mutation operators and how they can be configured see the D2 document.

\subsubsection{Step 2}

In this step \DAMA generates a mutation API with the functions that modify the data according to the provided fault model.

The engineer shall run the following command in the terminal inside the \texttt{damat\_pipeline} folder:

\begin{lstlisting}[language=bash]
bash DAMAt_probe_generation.sh
\end{lstlisting}

This procedure will produce three files:

\begin{enumerate}
	\item \texttt{FAQAS\_dataDrivenMutator.h}: the mutation API.
	\item \texttt{FAQAS\_mutants\_table.csv}: a csv table with the mutationOpt and definition of all the generated mutants.
	\item \texttt{function\_calls.out} function templates for the mutation probes to insert in the SUT.
\end{enumerate}

a copy of the first two files must remain in the damat-pipeline folder for the correct execution of the data analysis section of the pipeline.

\subsubsection{Step 3}
The engineer will manually instrument the SUT by:

\begin{enumerate}
	\item copying the \texttt{FAQAS\_dataDrivenMutator.h} file in the same folder as the file containing the target function that they chose to instrument.
	\item including the mutation API inthe chose file by adding
	\begin{lstlisting}[language=c]
	#include "FAQAS_dataDrivenMutator.h"
	\end{lstlisting}
	\item inserting function calls in the chosen function based on the prototypes contained in \texttt{function\_calls.out}.
\end{enumerate}

An example of a probe is included below, where \texttt{v} is the vector representing the buffer:
\begin{lstlisting}[language=c]
mutate_FM_fault_model_01( &v );
\end{lstlisting}

\subsubsection{Step 4, Step 5 and Step 6}

The other steps of the \DAMA procedure are carried out automally by the pipeline.
The pipeline can be started by running the \texttt{DAMAt\_mutants\_launcher.sh} script with the following command, executed inside the \texttt{damat\_pipeline} folder:

\begin{lstlisting}[language=bash]
bash DAMAt_mutants_launcher.sh
\end{lstlisting}

Before running all the generated mutants, a special mutant (MutationOpt=-2) will be executed to gather coverage information.
All the subsequent mutants will only be executed against tests that cover them to save execution time.
The lists of test cases executed against every mutant can be found in the folder \texttt{.../damat-pipeline/testlists}, which will be automatically generated.

These steps can also be executed separately by manually exporting the relevant variables and then running the pipeline scripts one by one. An example of the necessary commands can be found in the following.

\begin{lstlisting}[label={lst:manual_commands}, language=bash]

# variable to export
export DAMAt_FOLDER=$(pwd)
export tests_list=$DAMAt_FOLDER/tests.csv
export fault_model=$DAMAt_FOLDER/fault_model.csv
export buffer_type="unsigned char"
export padding=2
export singleton="TRUE"
export PIPELINE_FOLDER=$DAMAt_FOLDER/pipeline_scripts
export RESULTS_FOLDER=$DAMAt_FOLDER/results
export TESTS_FOLDER=$DAMAt_FOLDER/testlistsRESULTS_FOLDER=$DAMAt_FOLDER/results
export PIPELINE_FOLDER=$DAMAt_FOLDER/pipeline_scripts
export RESULTS_FOLDER=$DAMAt_FOLDER/results
export TESTS_FOLDER=$DAMAt_FOLDER/testlistsRESULTS_FOLDER=$DAMAt_FOLDER/results

# step 4 and step 5
bash $PIPELINE_FOLDER/DAMAt_obtain_coverage.sh $tests_list $DAMAt_FOLDER $singleton
bash $PIPELINE_FOLDER/DAMAt_compile_and_run_mutants.sh $DAMAt_FOLDER $singleton
# step 6
bash $PIPELINE_FOLDER/DAMAt_data_analysis.sh $DAMAt_FOLDER $tests_list

\end{lstlisting}


\subsection{\DAMA results}

After the execution of \DAMA the results are stored in the \texttt{.../damat-pipeline/results} folder that will be automatically generated.
For every mutant the pipeline will create a subfolder called \texttt{run\_<mutationOpt>} containing:
\begin{itemize}
	\item A \texttt{main.csv} a file with the results of the mutant's execution against the test suite
	\item A \texttt{coverage\_<test case>.csv} file containing the raw operator coverage data for that mutant-test case couple.
	\item A \texttt{readable\_coverage\_<test case>.csv} file containing the readable operator coverage data for that mutant-test case couple.
	\item A \texttt{<mutationOpt>\_exectuion.out} file containing an execution log for the mutant.
\end{itemize}

In addition to that a \texttt{logs} folder shall be created, containing the full compilation and execution logs for every mutant.

The \texttt{.../damat-pipeline/results} folder contains also files relative to the metrics defined to characterize the results of the full execution of \DAMA:

\begin{enumerate}
	\item Fault model coverage is the percentage of fault models covered by the test suite.
	\item Mutation operation coverage is the percentage of data items that have been mutated at least once, considering only those that belong to the data buffers covered by the test suite.
	\item The mutation score (MS) is the percentage of mutants killed by the test suite (i.e., leading to at least one test case failure) among the mutants that target a fault model and for which at least one mutation operation was successfully performed.
\end{enumerate}

These metrics measure the frequency of the following scenarios:
\begin{enumerate}
	\item the message type targeted by a mutant is never exercised.
	\item the message type is covered by the test suite but it is not possible to perform some of the mutation operations.
	\item the mutation is performed but the test suite does not fail.
\end{enumerate}

The file generated by the final steps are:

\begin{itemize}
	\item \texttt{mutation\_sum\_up.csv}: a file containing the previously described three metrics.
	\item \texttt{final\_mutants\_table.csv}: a file containing the definition and status of every mutant.
	\item \texttt{mutation\_score\_by\_data\_item.csv}: a file containing the mutation score by data item.
	\item \texttt{mutation\_score\_by\_fault\_class.csv}: a file containing the mutation score by fault class.
	\item \texttt{mutation\_score\_by\_fault\_model.csv}: a file containing the mutation score by fault model.
	\item \texttt{test\_coverage.csv}: a file containing the mutation score by fault model.
	\item \texttt{readable\_data.csv}: a file containing a more readable version of the execution data.
	\item \texttt{raw\_data.csv} and \texttt{raw\_data\_sorted.csv}: these files contain all the execution data.
	\item \texttt{readable\_operator\_coverage.csv}: a file containing a more readable version of the operator coverage data.
	\item \texttt{operator\_coverage.csv}: a file containing a raw version of the operator coverage data.
	\item \texttt{readable\_FM\_coverage.csv}: a file containing a more readable version of the fault model coverage data.
	\item \texttt{FM\_coverage.csv}: a file containing a raw version of the fault model coverage data.
\end{itemize}

\section{Normal Termination}

%\DONE{"The SUM shall describe how the user can cease or interrupt use of the software and how to determine whether normal termination or cessation has occurred."}

If the engineer decides to interrupt \DAMA execution, it can be done by sending a signal interrupt \texttt{SIGINT} to the running process.

\section{Error Conditions}

%\DONE{Can 't we say anything about each program not returning any error message?}

There is no error condition handling in the \FAQAS. If all preconditions are met, there should not be any error.

\section{Recover Runs}

%\DONE{Shall we say that an engineer can restart the process form a task if all the precondiions are met?}

If for any reason the execution of \DAMA is interrupted, an engineer can restart the process from a specific task if all preconditions are met, manually executing the rest of the steps.
