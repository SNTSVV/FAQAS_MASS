% !TEX root = MAIN.tex

\chapter{\DAMA - Operations Manual}

\section{Set-up and Initialization}

\subsection{Dependencies}

\begin{itemize}
	\item \texttt{Python 3.6.8} or higher
	\item \texttt{GNU bash, version 4.2.46} or higher
\end{itemize}

\section{Getting started}

\subsection{Initialization of the \DAMA workspace}

All the script for the \DAMA pipeline are contained in the \texttt{damat-pipeline} folder.
All \DAMA steps will take place inside this folder, which shall be placed by the engineer in a path of their choosing.

The folder shall contain the following structure and files:

\begin{itemize}
	\item \texttt{DAMAt\_configure.sh}: this script defines the necessary variables for the execution of \DAMA. They shall be set by the user.
	\item \texttt{DAMAt\_probe\_generation.sh}: this script set the variables necessary to generate the data mutation API and execute the python script \texttt{generateDataMutator.py} to generate them.
	\item \texttt{DAMAt\_mutants\_launcher.sh}: this script starts the \DAMA pipeline.
	\item \texttt{generateDataMutator.py}: this is the script that generates the \DAMA mutation API.
	\item \texttt{DDB\_TEMPLATE\_header.c} and \texttt{DDB\_TEMPLATE\_footer.c}: these are templates used to generate the \DAMA API by \texttt{generateDataMutator.py}
	\item \texttt{DAMAt\_compile.sh}: this is a stub of the script used to compile a mutant, which shall be completed by the user.
	\item \texttt{DAMAt\_run\_tests.sh}: this is a stub of the script used to run the tests, which shall be completed by the user.
	\item \texttt{data\_analysis}: a folder containing five python scripts used for the generation of the final results:
	\begin{itemize}
	  \item \texttt{beautify\_results.py}: this script renders the raw results from the execution of the tests in a more readable format.
	  \item \texttt{get\_coverage.py}: this script analizes the results of the fault model coverage.
	  \item \texttt{get\_operator\_coverage.py}: this script analizes the results of the operator coverage.
	  \item \texttt{get\_stats.py}: this script produces statistics from the mutants' execution.
		\item \texttt{get\_final\_results.py}: this script produces a summary of the execution of \DAMA.
	\end{itemize}
	\item \texttt{pipeline\_scripts}: a folder containing the four scripts that make up the \DAMA pipeline:
	\begin{itemize}
		\item \texttt{DAMAt\_obtain\_coverage.sh}: this script obtains fault model coverage data in order to execute only the tests that cover each mutant.
		\item \texttt{get\_mutant\_test\_list.py}: this script produces the list of test against which avery mutant shall be executed.
	  \item \texttt{DAMAt\_compile\_and\_run\_mutants.sh}: this scripts compile each mutant and run it against the SUT test suite.
		\item \texttt{DAMAt\_data\_analysis.sh}: this script executes all the data analysis steps at the end of the execution of the \DAMA pipeline
	\end{itemize}
	\item \texttt{fault\_model.csv}: an example of a \DAMA fault model in csv format.
 	\item \texttt{tests.csv }: an example of list of test cases and nominal times in csv format.
\end{itemize}

\subsection{Writing a list of all test cases}
\label{subsec:test_list}
The user shall provide the list of all the test cases with corresponding nominal time in csv format, using the \texttt{tests.csv } file as an example.
In the first column of the csv file there shall be an identifier for the test case. The second column shall contain the nominal execution time in ms.

\begin{lstlisting}
test_01,11002
test_02,13456
test_03,58347
\end{lstlisting}

This file will be used by the \DAMA pipeline for two purposes:
\begin{enumerate}
	\item the nominal execution time will be used to set a timeout for each test case.
	\item the whole list will be used to generate a list for each mutant containing only the test cases that cover it.
\end{enumerate}

\subsection{Setting the variables for the \DAMA pipeline}

% The user shall then modify three scripts to configure the \DAMA pipeline:
% \begin{itemize}
% 	\item \texttt{DAMAt\_configure.sh}
% 	\item \texttt{DAMAt\_compile.sh}
% 	\item \texttt{DAMAt\_run\_tests.sh}
% \end{itemize}

The user must set the following variables inside the \texttt{DAMAt\_configure.sh} script
\begin{lstlisting}[language=bash]

tests_list=$DAMAt_FOLDER/tests.csv

fault_model=$DAMAt_FOLDER/fault_model.csv

buffer_type="unsigned char"

singleton="TRUE"

padding=0

\end{lstlisting}

\texttt{test_list} shall be set to the path of the csv containing the test names and execution times.
\texttt{fault_model} shall be set to the path of the csv containing the fault model of the SUT that the user shall define for the SUT.
\texttt{buffer_type} shall contain the type of the elements of the buffer that will be targeted by the mutation.
\texttt{singleton} shall be set to \texttt{TRUE} or \texttt{FALSE}. If set to \texttt{TRUE}, the Fault Model will be initialized in a singleton variable, to avoid memory issues.
\texttt{buffer_type} shall be set to an integer number representing the number of bytes to skip at the beginning of the tarrget buffer. Normally it shall be set to \texttt{0}, but it can be used to skip the header of the buffer if needed.

\subsection{Setting up the compilation of the mutants}

The user shall modify \texttt{DAMAt\_compile.sh} to include the commands for the compilation of the mutants.

Every mutant is identified by an integer called "MutationOpt".

To enable the data-driven mutation, the user shall compile the SUT with this macro enabled: \item \texttt{-DMUTATIONOPT=<MutationOpt>}.

To use the singleton mode, the user shall compile the SUT with this macro enabled: \item \texttt{ -D_FAQAS_SINGLETON_FM="TRUE"}.

A way to do it is to include the following lines in the SUT makefile:

\begin{lstlisting}[label={language=bash]
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DMUTATIONOPT=$ENV{MUTATIONOPT}")
# comment the following line if you do not want to use the singleton option.
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D_FAQAS_SINGLETON_FM=$ENV{_FAQAS_SINGLETON_FM}")
\end{lstlisting}

and then export the corresponding variables in the \texttt{DAMAt\_compile.sh} script as shown in the \texttt{DAMAt\_compile.sh} stub.

The contents of the \texttt{DAMAt\_compile.sh} stub are portrayed in Listing~\ref{lst:compile}

\begin{lstlisting}[label={lst:compile},language=bash]

#!/bin/bash

mutant_id=$1
singleton=$2

###############################################################################
#enabling extended pattern matching features:
shopt -s
#options for enabling aliases:
shopt -s expand_aliases
###############################################################################


echo "------------------------------------"
echo "------------------------------------"
echo "Mutant opt: "$mutant_id
echo "------------------------------------"
echo "------------------------------------"

# The user shall complete the following section:
###############################################################################
#exporting the operation counter
export MUTATIONOPT=$mutant_id

if [$singleton == "TRUE"]; then
export _FAQAS_SINGLETON_FM=$singleton
fi

# here the user must invoke the compilation of the SUT, we provided a simple example.

compilation_folder="/home/SUT"

pushd $compilation_folder

make install-debug

    if [ $? -eq 0 ]; then
        echo $x " compilation OK"
    else
        echo $x " compilation FAILED"
    fi

popd


\end{lstlisting}

Once completed, the \texttt{DAMAt\_compile.sh} script shall take as input the value of the MutationOpt that refers to the mutant being currently compiled and of the singleton variable, and then compile the SUT accordingly.

\subsection{Setting up the execution of the test suite against the mutants}

The user shall modify \texttt{DAMAt\_run\_tests.sh} stub to include the commands for the execution of the mutants.
Every mutant is identified by an integer called "MutationOpt".
This script shall take as input the mutationOpt and a list of test in the format described in section~\ref{subsec:test_list}.
The contents of the \texttt{DAMAt\_run\_tests.sh} stub are portrayed in Listing~\ref{lst:run_tests}.
The user shall complete the stub by substiting the generic execution command with a command or a series of commands that execute a specific test case using the test identifier specified in the csv as input.
The output should be \texttt{0} if the test passes, \texttt{n!=0} if it fails and \texttt{124} in case of timeout.
The user may use the timeout command as shown in the example included in the stub.

\begin{lstlisting}[label={lst:run_tests},language=bash]

#!/bin/bash

mutant_id=$1
tests_list=$2
DAMAT_FOLDER=$3
results_dir=$DAMAT_FOLDER/results

mutant_dir=$results_dir/run_"$mutant_id"
execution_log=$mutant_dir/"$mutant_id"_execution.out
coverage_file=$mutant_dir/"$mutant_id"_coverage.csv
results_file=$mutant_dir/main.csv

###############################################################################
#date in milliseconds
start_time=$(($(date +%s%N)/1000000))

mkdir $results_dir
echo "this is the results folder: $results_dir"
mkdir $mutant_dir
echo "this is the folder of this mutant $mutant_dir"
touch $execution_log
echo "this is the logfile of the tests' execution $execution_log"
touch $coverage_file
echo "this is the file with the results $results_file"
touch $results_file
echo "this is the coverage file: $coverage_file"
export FAQAS_COVERAGE_FILE=$coverage_file
export _FAQAS_SINGLETON_FM

###############################################################################

while IFS="," read -r p || [ -n "$p" ];do

    mutant_start_time=$(($(date +%s%N)/1000000))

    # obtaining test number to be executed
    read tst <<< $(awk -F',' '{print $1}' <<< "$p")

    # obtaining corresponding timeout for the test case
    TIMEOUT=$(echo "$p" | awk -F',' '{$2=($2*4)/1000; printf("%.0f\n", $2);}')

    echo "*********************************************************"
    echo "*********************************************************"
    echo "Running mutant $mutant_id against test case "$tst
    echo "*********************************************************"
    echo "*********************************************************"
    echo -n "${mutant_id};COMPILED;${tst};" >> $results_file


###############################################################################
# here the user shall call the execution of the current test case,
# we provided a simple example

  timeout $TIMEOUT bash execute_test_case.sh $tst


###############################################################################
#the exec return code should be 0 if the test case passes, 1 if the test case fails and 124 in case of a timeout
EXEC_RET_CODE=$?


  mutant_end_time=$(($(date +%s%N)/1000000))
  mutant_elapsed="$(($mutant_end_time-$mutant_start_time))"



  if [ $EXEC_RET_CODE -ge 124 ]; then
     echo "Test return code: [$EXEC_RET_CODE]"
     echo "Mutant timeout by $tst"
     echo -ne "TIMEOUT;KILLED_${EXEC_RET_CODE};${mutant_elapsed}\n" >> $results_file

  else
      if [ $EXEC_RET_CODE -eq 0 ]; then
        echo "Test return code: [$EXEC_RET_CODE]"
        echo -ne "PASSED;LIVE;${mutant_elapsed}\n" >> $results_file

      else
        echo "Test return code: [$EXEC_RET_CODE]"
        echo "Mutant killed by $tst"
        echo -ne "FAILED;KILLED;${mutant_elapsed}\n" >> $results_file
      fi
  fi


###############################################################################

	#create a different coverage file for every test

	NEW_COVERAGE_FILE=$mutant_dir/coverage_"$tst".csv
	cp $coverage_file $NEW_COVERAGE_FILE
	>$FAQAS_COVERAGE_FILE

done < $tests_list

rm -rf ~/Obsw/Test/System/testresults/*

end_time=$(($(date +%s%N)/1000000))
elapsed="$(($end_time-$start_time))"

echo "elapsed time $elapsed [ms]"


\end{lstlisting}

% There is one bash script that should be edited by the engineer and there are also two Bash scripts stumps that should be edited by the engineer to allow the execution of \DAMA. These scripts enable \DAMA to correctly identify the SUT paths (e.g., source code folder, test suite folder), the SUT compilation commands, the SUT test suite execution commands, and the configuration of \DAMA itself.

\subsection{Running \DAMA on Single Machines}
\label{sec:dama_singlelaunch}

%\DONE{Add a paragraph that explains that you are going to describe two ways of running MASS}

\DAMA can be executed in two modes, \emph{single machine} and \emph{shared resources mode}. The single machine mode provides the advantage of running \DAMA in an unsupervised mode, executing the methodology on one step. Instead, the shared resources facilities mode gives the possibility of running multiple steps in parallel and executing a higher number of mutants, in a similar time frame, with respect to the single machine mode. In this section we describe the \emph{single machine}, Section \ref{sec:dama_shared} covers the \emph{shared resources mode}.


\subsubsection{One Step Launcher}

\subsubsection{Multiple Step Launchers}
\label{sec:dama_launchers}

\subsection{Running MASS on Shared Resources Facilities}
\label{sec:dama_shared}

Given that resources from HPC infrastructures has to be requested for every performed tasks, it is not possible to run all the steps from \DAMA in one step.
However, since resources can be requested accordingly, \DAMA can perform multiple steps simultaneously, enhancing the capabilities of the toolset. With an HPC, for example, \DAMA could analyze more mutants than if \DAMA was executed on a single machine.

\subsection{MASS results}

After the execution of \DAMA the results are stored in dedicated folders. Such folders are defined as follows:


\section{Normal Termination}

%\DONE{"The SUM shall describe how the user can cease or interrupt use of the software and how to determine whether normal termination or cessation has occurred."}

Each methodology step of \DAMA is executed when invoked and computes a result. There is no software interruption foreseen during the computation and the procedure terminates by returning the result.
If the engineer decides to interrupt \DAMA execution, it can be done by sending a signal interrupt \texttt{SIGINT} to the running process.

\section{Error Conditions}

%\DONE{Can 't we say anything about each program not returning any error message?}

There is no error condition handling in the \FAQAS. If all preconditions are met, there should not be any error.

\section{Recover Runs}

%\DONE{Shall we say that an engineer can restart the process form a task if all the precondiions are met?}

If for any reason the execution of \DAMA is interrupted, an engineer can restart the process from a specific task if all preconditions are met. This is possible since each \DAMA step work by processing data that is permanently stored by previous steps.
