% !TEX root = MAIN.tex

\chapter{SEMUS - Libutil Tutorial}
\label{chapter:semus:tutorial}

\section{Introduction}

This tutorial instructs on how to use \SEMUS on the Libutil Case Study provided by GomSpace Luxembourg.

\section{Running \SEMUS}
\label{sec:semus_running}

Firstly, the user needs to set up the \SEMUS toolset, please refer to Section~\ref{sec:install:semus}. For this tutorial, we have distributed to GomSpace Luxembourg a Singularity container with \SEMUS already configured and installed on it, the toolset can be found at \texttt{/opt/faqas\_semu}, being the case study installed at the relative path \texttt{faqas\_semu/case\_studies/LIBUTIL}.

The objective of this tutorial is to generate test inputs that kill the mutants non detected by the Libutil test suite. Consequently, we consider a precondition of this tutorial to have applied \MASS to the Libutil case study, and thus to have the list of live mutants---provided by SnT at the relative path \texttt{case\_studies/LIBUTIL/WORKSPACE/DOWNLOADED/} for this tutorial.

For the sake of this tutorial, we consider a reduced set of sources of the library. This set is composed of the following files:

\begin{itemize}
    \item src/byteorder.c
    \item src/clock.c
    \item src/drivers/sys/memory.c
    \item src/error.c
    \item src/timestamp.c
\end{itemize}

Given that the engineer has already properly setup and initialized the workspace for \SEMUS (see Section~\ref{sec:semus:initialization}). The steps for test generation on the Libutil case study consists of:

\begin{enumerate}
    \item Configure the file \texttt{faqas\_semus\_config.sh}
    \item Configure the \texttt{generate\_template\_config.json} files
    \item Generate the test templates for the SUT functions
    \item Launch the test generation process for the case study
    \item Verifying the generated unit test cases
\end{enumerate}


\subsection{Step 1: configuring \SEMUS}

The first step consists of configuring \SEMUS; for doing so it is necessary to provide the paths for the SUT paths, the SUT compilation commands, the output folders, and the configuration of \SEMU for guiding the symbolic search. Listing~\ref{listing:LIBUTIL:conf} provides an example of configuration file for the case study, the file can be found at \begin{footnotesize}\texttt{/opt/faqas\_semu/case\_studies/LIBUTIL/scripts/faqas\_semus\_conf.sh}\end{footnotesize}: 

\begin{lstlisting}[language=bash,label=listing:LIBUTIL:conf,caption=faqas\_semus\_conf.sh file for LIBUTIL case study.]
FAQAS_SEMU_CASE_STUDY_TOPDIR=../

FAQAS_SEMU_CASE_STUDY_WORKSPACE=$FAQAS_SEMU_CASE_STUDY_TOPDIR/WORKSPACE

FAQAS_SEMU_OUTPUT_TOPDIR=$FAQAS_SEMU_CASE_STUDY_WORKSPACE/OUTPUT/"${ENV_FAQAS_SEMU_SRC_FILE%.c}"

FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/mutants_generation

FAQAS_SEMU_REPO_ROOTDIR=$FAQAS_SEMU_CASE_STUDY_WORKSPACE/DOWNLOADED/libutil

FAQAS_SEMU_ORIGINAL_SOURCE_FILE=$FAQAS_SEMU_REPO_ROOTDIR/"${ENV_FAQAS_SEMU_SRC_FILE}"

FAQAS_SEMU_COMPILE_COMMAND_SPECIFIED_SOURCE_FILE=./"${ENV_FAQAS_SEMU_SRC_FILE}"

FAQAS_SEMU_GENERATED_MUTANTS_DIR=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/"${ENV_FAQAS_SEMU_SRC_FILE%.c}"

FAQAS_SEMU_BUILD_CODE_FUNC_STR='
FAQAS_SEMU_BUILD_CODE_FUNC()
{
    local in_file=$1
    local out_file=$2
    local repo_root_dir=$3
    local compiler=$4
    local flags="$5"
    # compile
    $compiler $flags -g -std=gnu99 -m64 -O0 -Wall -Wextra -Wshadow -Wcast-align -Wwrite-strings -Wno-unused-parameter -I$repo_root_dir/src -I$repo_root_dir/src/gosh -I$repo_root_dir/src/zip -I$repo_root_dir/src/watchdog  -I$repo_root_dir/build/src/watchdog -I$repo_root_dir/build/src -I$repo_root_dir/include -I$repo_root_dir/build/include -I$repo_root_dir/include/gs -I$repo_root_dir/build/include/gs -I$repo_root_dir/include/deprecated -I$repo_root_dir/build/include/deprecated -I$repo_root_dir/include/deprecated/gs/gosh -I$repo_root_dir/build/include/deprecated/gs/gosh -I$repo_root_dir/include -o $out_file $in_file $flags
    return $?
}
'

FAQAS_SEMU_BUILD_LLVM_BC()
{
    local in_file=$1
    local out_bc=$2
    eval "$FAQAS_SEMU_BUILD_CODE_FUNC_STR"
    FAQAS_SEMU_BUILD_CODE_FUNC $in_file $out_bc $FAQAS_SEMU_REPO_ROOTDIR clang '-c -emit-llvm'
    return $?
}

FAQAS_SEMU_META_MU_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/meta_mu_topdir

FAQAS_SEMU_GENERATED_META_MU_SRC_FILE=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/"${ENV_FAQAS_SEMU_SRC_FILE%.c}".MetaMu.c

FAQAS_SEMU_GENERATED_META_MU_BC_FILE=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/"${ENV_FAQAS_SEMU_SRC_FILE%.c}".MetaMu.bc

FAQAS_SEMU_GENERATED_META_MU_MAKE_SYM_TOP_DIR=$FAQAS_SEMU_GENERATED_MUTANTS_TOPDIR/"MakeSym-TestGen-Input"

FAQAS_SEMU_GENERATED_TESTS_TOPDIR=$FAQAS_SEMU_OUTPUT_TOPDIR/test_generation

# timeout in seconds
FAQAS_SEMU_TEST_GEN_TIMEOUT=300

# This is the config for SEMU heuristics. The accepted values of 'PSS' are 'RND' for random and 'MDO' for minimum distance to output
FAQAS_SEMU_HEURISTICS_CONFIG='{
        "PL": "0",
        "CW": "4294967295",
        "MPD": "0",
        "PP": "1.0",
        "NTPM": "5",
        "PSS": "RND"
}'

# max Test Generation memory in MB
FAQAS_SEMU_TEST_GEN_MAX_MEMORY=2000

# Set to 'ON' to stop test generation when the memory limit is reached
FAQAS_SEMU_STOP_TG_ON_MEMORY_LIMIT='OFF'

# Set this to 'ON' so thae the states the sate fork is disabled when the memory limit is reached, to avoid going much over it
FAQAS_SEMU_TG_MAX_MEMORY_INHIBIT="ON"
\end{lstlisting}

Concerning \SEMU configuration, we can see that we have setup the tool to run for a maximum of 5 minutes, and to use a maximum of 2000 MB of memory.

\subsection{Step 2 and 3: configuring the \texttt{generate\_template\_config.json} files and generating test templates}

For the generation of test templates we provide a Bash script that automates the invocation of the script \texttt{generate\_direct.py} for a specific source. This script is called \texttt{call\_generate\_direct.sh}, and receives the relative path to the source under test. Furthermore, as a demonstration we provide examples of \texttt{generate\_template\_config.json} files for the five sources considered in this tutorial. Such examples can be found at the path \begin{small}\texttt{case\_studies/LIBUTIL/util\_codes/template\_configs}\end{small}.

Listing~\ref{listing:LIBUTIL:timestamp} shows an example of configuration JSON file for the timestamp.c source.

\begin{lstlisting}[language=bash,label=listing:LIBUTIL:timestamp,caption=JSON configuration file for timestamp.c.]
{
    "TYPES_TO_INTCONVERT": {},
     "TYPES_TO_PRINTCODE": {"gs_timestamp_t": "printf(\"FAQAS-SEMU-TEST-OUTPUT: result_faqas_semu = tv_sec: %u, tv_nsec: %u\\n\", {}.tv_sec, {}.tv_nsec);"},
    "OUT_ARGS_NAMES": [],
    "IN_OUT_ARGS_NAMES": ["base"],
    "TYPE_TO_INITIALIZATIONCODE": {},
    "TYPE_TO_SYMBOLIC_FIELDS_ACCESS": {},
    "VOID_ARG_SUBSTITUTE_TYPE": "",
    "ARG_TYPE_TO_ITS_POINTER_ELEM_NUM": {}
}
\end{lstlisting}

The engineer shall execute the Bash script \texttt{call\_generate\_direct.sh} for the generation of test templates with the following command.

\begin{lstlisting}[language=bash]
$ case_studies/LIBUTIL/util_codes/call_generated_direct.sh src/timestamp.c
$ case_studies/LIBUTIL/util_codes/call_generated_direct.sh src/byteorder.c
$ case_studies/LIBUTIL/util_codes/call_generated_direct.sh src/error.c
$ case_studies/LIBUTIL/util_codes/call_generated_direct.sh src/clock.c
$ case_studies/LIBUTIL/util_codes/call_generated_direct.sh src/drivers/sys/memory.c
\end{lstlisting}

\subsection{Step 4: launching the test generation process}

Given that the test generation targets the source files \begin{small}\texttt{byteorder.c, clock.c, memory.c, error.c, timestamp.c}\end{small}, we provide in folder \texttt{case\_studies/LIBUTIL/WORKSPACE/DOWNLOADED/} the corresponding list of live mutants for each of these sources. 
Since we are executing the example in the Singularity container, we execute the test generation through the \texttt{run.sh} script, and not through the wrapper \texttt{docker\_run.sh}, as explained in Chapter~\ref{chapter:semus:operations}.

The corresponding commands for starting the test generation follows:

\begin{lstlisting}[language=bash]
 $ ENV_FAQAS_SEMU_SRC_FILE=src/timestamp.c scripts/run.sh mutation WORKSPACE/DOWNLOADED/live-src.timestamp WORKSPACE/OUTPUT/live_mutants_output
 $ ENV_FAQAS_SEMU_SRC_FILE=src/error.c scripts/run.sh mutation WORKSPACE/DOWNLOADED/live-src.error WORKSPACE/OUTPUT/live_mutants_output
 $ ENV_FAQAS_SEMU_SRC_FILE=src/byteorder.c scripts/run.sh mutation WORKSPACE/DOWNLOADED/live-src.byteorder WORKSPACE/OUTPUT/live_mutants_output
 $ ENV_FAQAS_SEMU_SRC_FILE=src/clock.c scripts/run.sh mutation WORKSPACE/DOWNLOADED/live-src.clock WORKSPACE/OUTPUT/live_mutants_output
 $ ENV_FAQAS_SEMU_SRC_FILE=src/drivers/sys/memory.c scripts/run.sh mutation WORKSPACE/DOWNLOADED/live-src.drivers.sys.memory WORKSPACE/OUTPUT/live_mutants_output
\end{lstlisting}

\subsection{Step 5: verifying the generated test cases}

\SEMUS output is stored in the directory \texttt{WORKSPACE/OUTPUT/live\_mutants\_output}. The generated unit test cases are stored in the directory \begin{small}\texttt{live\_mutants\_output/test\_generation/<test template name>/<function under test>/FAQAS\_SEMU-out/produced-unittests}\end{small}.

For example, in the \texttt{produced-unittests} folder for the \texttt{timestamp\_ge} function of the \texttt{timestamp.c} source, after test generation, we will find the following files:

\begin{itemize}
\item runtest.sh
\item test000001.ktest.c
\item test000001.ktest.c.expected
\item test000003.ktest.c
\item test000003.ktest.c.expected
\item test000006.ktest.c
\item test000006.ktest.c.expected
\end{itemize}

The Bash script \texttt{runtest.sh} provides the necessary commands to execute the generated test case, the \texttt{*.ktest.c} files represent the generated test cases by \SEMUS, and the \emph{.expected} files contain the output that is observed when executing the test case with the SUT.

Then, the generated test case can be executed through the following command:

\begin{lstlisting}[language=bash]
 $ ./runtest.sh test000001.ktest.c
\end{lstlisting}

This command will generate a \texttt{test000001.ktest.c.got} file, which stores the test outputs. The script will also compare the observed output (i.e., got file) with the output generated during test generation (i.e., expected file) through a \emph{diff} command. If the function under test was not modified since the test generation phase, the \texttt{runtest.sh} script should not output any difference.
