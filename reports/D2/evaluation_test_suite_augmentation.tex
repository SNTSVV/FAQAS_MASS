% !TEX root = MAIN.tex

\subsection{Empirical Evaluation}

We address the following research questions:

\emph{RQ1. Does SEMuS improves the mutation score of test suites?}

\emph{RQ2. Does the approach scale in the context of space software?}

\subsubsection{RQ1 - Approach effectiveness}

We applied our code-driven mutation analysis tool (MASS) to the ASN.1 case study, with the purpose of identifying the set of live mutants to be used by SEMuS. Similar to Section~\ref{sec:caseStudies:GSL:ASN1}, we applied the methodology only to the autogenerated source code by ASN1SCC compiler. In particular, when applying MASS we observe the following:

\begin{itemize}
	\item 9\,904 mutants were generated
	\item 1\,319 mutants were not compilable
	\item 3\,262 were considered equivalent or redundant by means of TCE
	\item 3\,104 were killed by the test suite
	\item 2\,219 were live mutants
	\item The test suite under analysis has a mutation score of 58.31\%
\end{itemize}

Then, we applied SEMuS to generate test cases for the 2,219 live mutants. As a result, we generated test inputs for 1\,717 mutants, which translate into an improved mutation score of 90.57\%.

To further analyze SEMuS results, we inspect manually the test inputs generated for the mutant \texttt{test.mut.1298.2\_1\_23.ICR.T\_INT\_IsConstraintValid}. Particularly, through this mutant we discovered one shortcoming of the ASN.1 test suite.

The original code of the mutated function, \texttt{T\_INT\_IsConstraintValid}, is shown in Listing~\ref{original_ans_code}.

\begin{lstlisting}[style=CStyle, caption=Original code., label=original_asn_code]
flag T_INT_IsConstraintValid(const T_INT* pVal, int* pErrCode) {
    flag ret = TRUE;
    (void)pVal;

    ret = ((*(pVal)) <= 50UL);
    *pErrCode = ret ? 0 : ERR_T_INT; 

    return ret;
}
\end{lstlisting}

Instead, Listing~\ref{mutant_asn_code} shows the mutated version of the function \texttt{T\_INT\_IsConstraintValid}.

\begin{lstlisting}[style=CStyle, caption=Mutant code., label=mutant_asn_code]
flag T_INT_IsConstraintValid(const T_INT* pVal, int* pErrCode) {
    flag ret = TRUE;
    (void)pVal;

    ret = ((*(pVal)) <= 50UL);
    *pErrCode = ret ? -1 : ERR_T_INT;

    return ret;
}
\end{lstlisting}

For this particular mutant, SEMuS produced the following output for \texttt{pVal} argument of the function (an integer of 8 bytes):

\begin{lstlisting}[language={}, caption=Klee-test output, label=ktest]
ktest file : 'test000001.ktest'
args       : ['/MakeSym-TestGen-Input/direct/T_INT_IsConstraintValid/test.MetaMu.bc']
num objects: 2
object    0: name: b'model_version'
object    0: size: 4
object    0: data: b'\x01\x00\x00\x00'
object    1: name: b'pVal'
object    1: size: 8
object    1: data: b'\x00\x00\x00\x00\x00\x00\x00\x00'
\end{lstlisting}

SEMuS output shows that a \texttt{pVal} value equal to 0 would kill the mutant. However, we noticed that the ASN.1 test suite already contains test inputs where \texttt{pVal = 0}, in addition to \texttt{pVal = 50}.

Listing~\ref{test_code} shows an excerpt of the ASN.1 test suite, and in particular, the function that verifies the output of \texttt{T\_INT\_IsConstraintValid}. 

\begin{lstlisting}[style=CStyle, caption=ASN.1 test code., label=test_code]
flag T_INT_enc_dec(const T_INT* pVal, int* pErrCode, const char* filename)
{
    static T_INT decodedPDU;
    flag ret = TRUE;
    ...
            // validate decoded data
            ret = T_INT_IsConstraintValid(&decodedPDU, pErrCode); 
            if (ret) {
                ret = T_INT_Equal(pVal, &decodedPDU);
                *pErrCode = ret ? 0 : 4;
                if (ret) {
                    char buf[1024];
                    strcpy(buf, filename);
                    FILE* fp = fopen(strcat(buf,".dat"), "wb");
                    fwrite(bitStrm.buf, 1, bitStrm.count, fp);
                    fclose(fp);
                }
            }
    ...
}
\end{lstlisting}

We notice that after the invocation of the function under test, the value of \texttt{pErrCode} is never checked and it is re-written on line 10. We confirmed this shortcoming with ASN1SCC engineers, who provided a solution to fix this issue.