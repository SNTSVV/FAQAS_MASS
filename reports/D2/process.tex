% !TEX root = MutationTestingSurvey.tex

\section{Mutation Testing Process}
\label{sec:process}

	\begin{figure}
	\centering
		\includegraphics[width=\textwidth]{images/process}
		\caption{Mutation Testing Process.}
		\label{fig:code:process}
	\end{figure}

Figure~\ref{fig:code:process} shows the reference code-driven mutation testing process that will be considered in this book. The process depicted in Figure~\ref{fig:code:process} has been inspired by the mutation testing process described in related work~\cite{offutt2001mutation,papadakis2019mutation}, it has been presented in deliverable D1. The process is based on two main sub-processes, \emph{test suite evaluation} and \emph{test suite augmentation}, which are described in Sections~\ref{sub:test_suite_evaluation}~and~\ref{sub:test_suite_augmentation}, respectively.

\input

\endinput

\subsection{Test Suite Evaluation} % (fold)
\label{sub:test_suite_evaluation}

The \INDEX{Test Suite Evaluation process} concerns the automatic generation of modified versions (i.e., the mutants) of the software under test (SUT) and the evaluation of the quality of the SUT test suite. 
Figure~\ref{fig:code:process} provides an overview of the test suite evaluation process.
It consists of three activities: \emph{create mutants}, \emph{execute mutants}, and \emph{analyze results}.  
These activities are typically automated by toolsets that often include strategies to address scalability issues. The are described in the following paragraphs.


\subsubsection{Create mutants}

The Test Suite Evaluation process starts with engineers providing the SUT and a set of mutation operators selected to create modified versions of the software. 
A mutation operator is a function that can automatically alter the syntax of the source code of the SUT to simulate one or more programming errors.
For example, a conceptually simple operator is the \textit{SSDL} operator, which deletes (or comment out) one or more statements in the source code.

%\DONE{Does SSDL delete a statement or a line? PLease be consistent in the following}

%\DONE{Complete the following}

Listings~\ref{isPalindrome_m1} to~\ref{isPalindrome_m7}, provide the results obtained when applying the \textit{SSDL} operator to the source code in Listing~\ref{isPalindrome}.
Listing~\ref{isPalindrome} shows the implementation of function \texttt{isPalindrome}, which checks if a given word is palindrome or not.
Listing~\ref{isPalindrome_m1} shows that the statement in line 12 has been deleted, i.e., the statement \texttt{`return 0;'}.
Listing~\ref{isPalindrome_m2} shows that the statements from line 11 to line 13 have been deleted, i.e., all the content of the if branch.
Listing~\ref{isPalindrome_m3} shows that the statements from line 10 to line 13 have been deleted, i.e., the whole if statement.
Listing~\ref{isPalindrome_m4} shows that the statement in line 14 have been deleted, i.e., the statement \texttt{`l++;'}.
Listing~\ref{isPalindrome_m5} shows that the statement in line 15 have been deleted, i.e., the statement \texttt{`h-}\texttt{-;'}.
Listing~\ref{isPalindrome_m6} shows that the statements from line 6 to line 16 have been deleted, i.e., all the content of the function \texttt{isPalindrome} except for the statement \texttt{`return 1;'}.
Listing~\ref{isPalindrome_m7} shows that the statements in line 8, 9, and 16 have been deleted, i.e., the while loop structure.

\input{listings/isPalindrome}
\input{listings/isPalindrome_m1}
\input{listings/isPalindrome_m2}
\input{listings/isPalindrome_m3}
\input{listings/isPalindrome_m4}
\input{listings/isPalindrome_m5}
\input{listings/isPalindrome_m6}
\input{listings/isPalindrome_m7}

%The mutants produced by the \textit{SSDL} operator can be seen in Table~\ref{table:mutants}. In this case, it has been produced six mutants, for example, \textit{M1} deletes the line 12 from Listing~\ref{isPalindrome}, that is, the \texttt{return 0;} statement. Also, \textit{M6} deletes the statements in Listing~\ref{isPalindrome} from line 6 to 16.

%A set of mutation operators implemented by most of the existing toolsets consists of the relational (ROR), logical (LCR), arithmetic (AOR), absolute (ABS) and unary insertion (UOI) operators~\cite{rothermel1996experimental}. 

In the test suite evaluation process, the activity \emph{create mutants} concerns the application of the mutation operators to the source code of the SUT; it leads to the generation of modified versions of the SUT (i.e., the mutants) that should be compiled and then executed against the test suite to evaluate the test suite quality. 
The set of available mutation operators depends on the toolset implementing the test suite evaluation process.
Section~\ref{sec:operators} provides an overview of the mutation operators defined in the literature that can be applied in the context of space and embedded systems.

\subsubsection{Execute mutants}

%\DONE{You should write "the function <functionName>" not "the <functionName> function"}

The \INDEX{execution of mutants} implies the execution of the test suite of the SUT against all the generated mutants. 
%Optimizations for the execution of mutants concern the scalability of the execution process and 
%the identification at run-time of equivalent and redundant mutants.

\input{listings/isPalindrome_TS}

%\DONE{are passing => pass}

%\DONE{The example is not good enough. You should show that the test suite fails with most of the mutants except one. Please reorder the examples and the description to fix it.}

In Listing~\ref{isPalindrome_TS} we introduce an example test suite for the function \texttt{isPalindrome} (Listing~\ref{isPalindrome}). 
The outcome of the execution of the test suite against the function \texttt{isPalindrome} is that all the five test cases pass.

%FAbrizio: you don't put things like "now" in a book, is not a story
If we execute the same test suite against all mutants, we observe that for mutants \textit{M1, M2, M3, M4, M5} and \textit{M6}, the test suite fails, but for mutant \textit{M7} the test suite passes. We say that a \INDEX{test suite fails} when at least one test case fails. A \INDEX{test suite passes} when all the test cases pass. If a test suite passes when executed against a mutant it means that it is \EMPH{not adequate}; indeed, a test suite should, in principle, identify all the faults introduced.

In a real and complex system, unfortunately, the activity \emph{create mutants} may lead to a high number of mutants to be generated, which, in turn, leads to scalability issues due to the compilation and execution of the different program versions generated. Recent surveys provide an overview of existing optimization techniques~\cite{ferrari2018systematic};
the most relevant optimization approaches target the reduction of the number of mutants to be compiled and executed, 
the reduction of the compilation iterations, the reduction of the execution time, and the identification of equivalent and redundant mutants. They are presented in detail in the next sections.

To reduce the number of program versions that need to be compiled and executed, existing approaches automatically select subsets of the generated mutants. Two main mutant selection approaches have been defined: the selection of representative mutation operators and the random selection of mutants~\cite{zhang2010operator}. The first approach consists of the empirical identification of a subset of mutation operators that is sufficient to predict the mutation score~\cite{siami2008sufficient,barbosa2001toward}. The second approach consists of randomly selecting a certain percentage of mutants from the generated ones~\cite{wong1995reducing}, possibly with a uniform distribution of the different mutation operators~\cite{zhang2010operator}. Empirical results with academic case studies~\cite{zhang2010operator} show that the first approach is not superior to random selection when selecting the same number of mutants. Other work~\cite{zhang2013operator} show that the combination of operator-based selection and random sampling leads to better results since it leads to high mutation score (above 98\%) while reducing the average mutation testing time to 6.54\%. The use of higher-order mutants is another solution to reduce the overall number of mutants. 
Other optimizations are framework specific, for example, Mull limits mutations to reachable code~\cite{hariri2018srciror}. Section~\ref{sec:opt:selection} provides an overview of mutant selection approaches.

To reduce the time spent in the compilation of the generated mutants, \INDEX{mutant schemata}~\cite{untch1993mutation} consist of encoding all the mutants in a single file and parametrize the mutant execution so that mutants are compiled in a single pass and selected at runtime. Section~\ref{sub:compileTime} provides an overview of compile-time optimization approaches.

Another optimization that speeds up the compilation of mutants concerns the identification of equivalent and redundant mutants. Equivalent mutants are mutants that behave as the original program, while redundant mutants are mutants that lead to the same test failures. 

%\DONE{We should have an example of an equivalent mutant. Can you think of anything for the isPalindrome? Maybe replacing l++ with ++l ? If so you have to introduce the operator as well.}

\input{listings/isPalindrome_equivalent}

Listing~\ref{isPalindrome_equivalent} shows an equivalent mutant for the function isPalindrome (Listing~\ref{isPalindrome}). The mutant in Listing~\ref{isPalindrome_equivalent} has been obtained by applying the \INDEX{OPPO operator} to the source code in Listing~\ref{isPalindrome}. The \textit{OPPO} operator mutates expressions such as \texttt{l++} into \texttt{++l} and \texttt{l-}\texttt{-}.
Despite both versions of the function are syntactically different, they have the same semantic, i.e., they behave the same way. The mutation does not change the output of the function for any possible input.

To determine if a program and one of its mutants are
equivalent is undecidable~\cite{Budd:1982}; however, heuristics to partially address this problem have been defined in the literature.
\INDEX{Trivial compiler optimization} might be adopted to detect both equivalent and redundant mutants; it relies on the idea that source code that leads to the same program behaviour often belongs to the same optimized compiled code~\cite{papadakis2015trivial}. Other approaches concern the adoption of \INDEX{symbolic execution}~\cite{papadakis2012mutation,kurtz2015static} and the \INDEX{runtime monitoring} of the SUT (e.g., mutants that lead to the same execution paths are likely equivalent~\cite{schuler2013covering}). Finally, Shin et al. proposed the \INDEX{distinguishing mutation adequacy criterion}, which aims to ensure that the test suite includes enough different test inputs so that every mutant is distinguished by each other, if feasible~\cite{shin2017theoretical}. 
Solutions to address the problem of identifying equivalent and redundant mutants are detailed in Sections~\ref{sec:opt:equivalent} and~\ref{sec:opt:redundant}, respectively.


A well-known optimization to \INDEX{reduce execution time} is the \INDEX{split-stream} optimization, which consists of generating a modified version of the SUT that creates multiple processes (one for each mutant) only when the mutated code is reached~\cite{tokumoto2016muvm}. With split-stream execution, the code shared by multiple mutants is executed only once thus saving time and resources. Other execution optimizations consist of minimizing the number of processes being created by sharing one single process among mutants that bring the system into the same state~\cite{wang2017faster}.
Section~\ref{sec:opt:execution} provides an overview of techniques to reduce execution time and, more generally, addresses \INDEX{run-time scalability issues}.

\subsubsection{Analyze results}

The \emph{analysis of test results} concerns the identification of mutants that lead to the failure of at least one test case of the SUT test suite; these mutants are said to be \INDEX{killed}. Mutants that do not lead to the failure of any test case are said to be \INDEX{live mutants}. 
%\DONE{COplete}

In the examples concerning the mutation of function \texttt{isPalindrome} (Listings~\ref{isPalindrome_m1} to~\ref{isPalindrome_m7}), mutants \textit{M1, M2, M3, M4, M5} and \textit{M6} are killed, instead mutant \textit{M7} is alive.

The identification of killed and live mutants enable the definition of a \INDEX{mutation adequacy criterion} as follow, \EMPH{a test suite is mutation-adequate if all mutants are killed by at least one test case of the test suite}. 
Also, the percentage of killed mutants is used to quantitatively measure the quality of a test suite. This measure is referred to as \INDEX{mutation score}.

%\DONE{Add comment concerning the example.}

The mutation score of the function \texttt{isPalindrome} is $6/7 = 85.71\%$, this result shows that the test suite for the function is not \textit{mutation-adequate}.

Because of equivalent and redundant mutants, mutation-adequacy is difficult to achieve. In addition, the mutation score might not be representative of test suites quality~\cite{papadakis2016threats}. Section~\ref{sub:mutationscore} provides an overview of solutions addressing the problems related to the computation of the mutation score.



The capability of a test case to kill a mutant often depends on the observability of the system state. 
To overcome the limitations due to observability, different strategies for distinguishing program executions (i.e, to determine if the execution of two test cases led to different results) have been defined. These strategies are known as strong, weak, firm, and flexible mutation coverage.
\EMPH{\INDEX{Strong mutation} coverage} indicates that the computation of the mutation score is based on the percentage of mutants identified by test failures, i.e., based on difference between the expected and the observed output of the system.  
\EMPH{\INDEX{Weak mutation} coverage} consists of verifying if the state of the system has been altered, with respect to the original code, after the execution of the mutated statement. 
\EMPH{\INDEX{Firm mutation} coverage} consists of verifying if the change in the state of the system propagates after the mutated code, e.g., at function boundaries. 
\EMPH{\INDEX{Flexible mutation} coverage} consists of checking if the mutated code leads to object corruption~\cite{mateo2012validating}. The main difference between these four coverage strategies is that \EMPH{only strong mutation coverage enables engineers to assess the quality of test cases in their entirety}, i.e., by evaluating both the capability of triggering an erroneous behavior and the capability of reporting the erroneous behaviour. 
%thanks to complete test oracles. 
The other strategies only evaluate the capability of the test suites of triggering the erroneous behavior. 

% subsection test_suite_evaluation (end)

\subsection{Test Suite Augmentation} % (fold)
\label{sub:test_suite_augmentation}

The \INDEX{test suite augmentation} process concerns the definition of test cases that kill live mutants.


It consists of four activities \EMPH{Identify Test Inputs}, \EMPH{Generate Test Oracles}, \EMPH{Execute the SUT}, \EMPH{Fix the SUT}. The first two activities concern the definition of new test cases.
The third activity, i.e., the execution of the SUT, enables engineers to determine if the newly defined test cases spot faults not identified by the original test suite. 
Finally, the repair of the SUT (i.e., activity \emph{Fix the SUT}) is performed in the case of test failures.
In this book we focus on the techniques that can be applied to automate the first two activities (i.e., \emph{Identify Test Inputs}, and \emph{Generate Test Oracles}).
 
The identification of test inputs has the objective of identifying inputs for the SUT that make the SUT produce an output that is different than the one produced by one of the mutants not killed by the existing test suite. 
A \EMPH{\INDEX{test oracle}} is an executable instruction that verifies if the systems behaves according to its requirements. 
A test oracle usually consists of a set of assertions verifying if the output generated by the system matches the expectations.
The generation of test oracles should lead to executable code instructions (e.g., assertions) implementing an oracle. The generated instructions are expected to report a test failure for at least one of the live mutants.


%F: already done, deleted statement => statement deleted}
In the case of the example of function \textit{isPalindrome}, test suite augmentation should introduce a new test case that 
exercises the statement deleted by the operator before returning that the input is not palindrome.
More precisely, the new test case should exercise an odd non-palindrome word with non-palindrome characters positioned in the internal part of the string (i.e., to execute the while loop, the head and tail characters should be equal). In Listing~\ref{isPalindrome_TS_improved}, we added a test case with the input \textit{abbaa}, this test case will fail against \textit{M7}. This process should be done iteratively for all the live mutants of the mutation process. 

\input{listings/isPalindrome_TS_improved}


 
%\DONE{If there are multiple live mutant, please add an example for each}

%To this end, mutants could be ranked according to their importance in order to ensure that, for a given test budget, the most relevant mutants are considered first. MuRanker~\cite{namin2015muranker}, for example, ranks mutants according to their predicted difficulty and complexity in being detected. 
To automate the generation of test cases, existing work investigates the adoption of the KLEE \INDEX{symbolic execution} engine~\cite{holling2016nequivack} and the use of \INDEX{bounded model checking}~\cite{riener2011test}. Other work combines \INDEX{dynamic symbolic execution} (DSE) with \INDEX{search-based software testing} (SBST) to generate test inputs that lead to strong mutations~\cite{harman2011strong}. 


Concerning the automated \INDEX{generation of test oracles}, 
%a state-of-the-art approach consists of the generation of assertions that verify the value of variables that enable the killing of mutants~\cite{fraser2011mutation}. 
%In the case of test suite generation for mutation testing, 
it could be driven by the comparison of the outputs generate by the SUT and by the specific mutants targeted during test generation~\cite{Staats2012}.



Test failures observed after updating a test suite should be investigated by the engineers who are expected to fix the SUT.
If test failures are not observed, engineers evaluate the quality of the newly generated test suite by executing it against the mutants and by observing the mutation score achieved. 

Section~\ref{sec:testGeneration} provides an overview of approaches for the automated generation of test cases.




%\DONE{Please STOP using the word 'besides' :)}


