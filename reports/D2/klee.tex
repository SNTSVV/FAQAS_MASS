% !TEX root = MAIN.tex

\subsection{KLEE}

KLEE~\cite{cadar2008klee} is an open source tool that implements {\em Concolic Execution}, a technique that performs symbolic execution along a concrete execution path. KLEE was designed to automatically generate test cases that achieve high code coverage. The tool is implemented as a modified LLVM virtual machine that targets LLVM bytecode programs.
KLEE also provides a symbolic POSIX library that enable analysis of programs that uses the system's environment. For example, KLEE can be executed with the flag \texttt{-sym-stdin N} which will make stdin symbolic with size \texttt{N}.  

In the context of FAQAS, we aim to rely on KLEE to automatically produce the inputs that make the mutated version of the program generate a different output than the original version.
This is observed in the outcome of the verification \emph{true}, i.e., the assertion indicating that the output of the original and mutated program are different does hold. In this case, KLEE produces the values of the inputs for which both versions of the program have a different result.

When the outcome of the verification is \emph{false}, the assertion that indicates if the output of the original and mutated program are the same does not hold. A \emph{false} outcome means that the mutant is equivalent and thus the test case can be ignored. 
We only consider the test inputs produced when the verification of the assertion holds.

\input{listings/GSLaugmentation_klee}

Listing~\ref{GSLaugmentation_klee} shows an example of generation of inputs with KLEE for the mutant \linebreak\emph{MUT\_gs\_bswap\_16} presented in Listing~\ref{GSLaugmentation}. In this case, the function \emph{main} is used to declare all the variables and assertions to be processed by KLEE to generate the required inputs for testing. Particularly, the function creates an input of type \texttt{uint16\_t} with a symbolic value given by the KLEE function \texttt{klee\_make\_symbolic}. The symbolic value is then passed to both the original and the mutated functions. To produce test inputs that kill mutants the assertion of line 30 should be inserted.

To run this example, the program must be compiled with clang, instead of its original compiler, and with the \texttt{-emit-llvm} option enabled, since KLEE runs on bitcode rather than source code or binaries. The command used to compile this example is the following:

\begin{verbatim}
clang -DKLEE -I ~/klee/include -Iinclude -emit-llvm -c -g -O0 -Xclang 
-disable-O0-optnone byteorder.c
\end{verbatim}

By default, KLEE works on programs that do not use any external code such as C library functions. To enable KLEE to work with external code the KLEE POSIX runtime capability should be enabled. To generate the test inputs for this example, the following command should be used:

\begin{verbatim}
~/klee/build/bin/klee --libc=uclibc --posix-runtime 
-silent-klee-assume byteorder.bc
\end{verbatim}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.4\textwidth]{images/klee_output_1}
\caption{KLEE output}
\label{fig:klee_output_1}
\end{center}
\end{figure}

\input{listings/GSLaugmentationTest_klee}

Figure~\ref{fig:klee_output_1} shows the output generated by KLEE when processing the function. It indicates that for the input \emph{symbolicValue=256}, the outcome of the assertion \texttt{res != resMUT} holds. Listing~\ref{GSLaugmentationTest_klee} shows a test case manually written based on the output produced by KLEE.

\input{listings/GSLaugmentation2_klee}

Listing~\ref{GSLaugmentationTwo_klee} shows another example of a source file to be parsed by KLEE to automatically derive inputs for a test case. Similar to Section~\ref{subsec:cbmc}, we also apply KLEE to the mutant \texttt{MUT\_base16\_decode}. Function \emph{main} provide the setup for KLEE. While function \emph{main} is the test case manually derived from the KLEE output.

Comparing Listings~\ref{GSLaugmentationTwo} and~\ref{GSLaugmentationTwo_klee} can be seen the advantages of KLEE; basically, is it not longer necessary to provide KLEE the implementation of standard library functions (e.g., \emph{strtoul}), because they are provided by the POSIX runtime capability. This capability makes easier the integration of KLEE with the case study systems of FAQAS, and makes the results more accurate, since KLEE is aware of the standard library functions definitions and implementations.

