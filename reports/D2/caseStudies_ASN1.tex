% !TEX root = MAIN.tex

\clearpage

\section{ASN1SCC}
\label{sec:caseStudies:GSL:ASN1}

\subsection{Overview of the case study}

ASN1SCC is an open source ASN.1 compiler that generates C/C++ and SPARK/Ada code suitable for low resource environments such as space systems. Moreover, the compiler can produce a test harness that provides full statement coverage in the generated code, and therefore significantly improves its quality.

Details about ASN.1 compiler are provided in the document \emph{taste-documentation-current.pdf} uploaded on Alfresco.

In the context of FAQAS, we focus our analysis on the auto-generated source code by the ASN.1 compiler, rather than in ASN1SCC software itself.

For the definition of the ASN.1 compiler case study, we introduce the example of a specific grammar. An excerpt of such grammar is shown in Listing~\ref{asn_excerpt}. 
The excerpt of the grammar introduces the definition of six data types, each data type also specifies the expected constraint, for example, the data type \texttt{MyInt} is an INTEGER which can have values from 0 to 20. The full source code of the grammar can be found in the file \emph{test.asn} uploaded on Alfresco.

For the given grammar, the size of the auto-generated source code is 4\,338 LOC. While the unit test suite consists of 107 auto-generated test cases.

\input{listings/asn}

\subsection{Code-driven mutation testing}

\input{tables/asn1grammar_coverage}



The objective of this case study is to provide ASN1SCC engineers tangible evidence on how to improve the auto-generated test cases, by reporting detailed information of live mutants and possible candidates of new test cases. In this manner, the quality of test suites of embedded systems that includes the auto-generated source code from ASN.1, can also be improved.

Table~\ref{table:asn1grammar_coverage} provides the code coverage information of the auto-generated source code of the \emph{test.asn} grammar. Given the code coverage, we focus our code-driven mutation testing analysis to the following subset of components (i.e., components with code coverage greater than 0\%):

\begin{itemize}
	\item asn1crt\_encoding.c: implementation of the ASN.1 constraints encoding/decoding procedures.
	\item test.c: implementation of the grammar data types encoding/decoding procedures.
	\item test\_auto\_tcs.c: wrapper of the grammar data types encoding/decoding procedures used in the test cases.
\end{itemize}

\subsubsection{Mutation Testing Preliminary Results}

\input{tables/asn1_preliminary}

In order to analyze the feasibility of the code-driven mutation testing for ASN.1, we conducted a preliminary experimentation using the mutation operators AOR, ROR, ICR, LCR, ABS, UOI and SDL we generated 9\,174 mutants. Preliminary results can be found in Table~\ref{table:asn1_preliminary}.
Particularly, we observe that from the 9\,174 generated mutants, we had 1\,215 mutants that were not compiled by the compilation toolset of ASN.1, most probably because the mutation introduced a syntactical error that was detected by the toolset.
Then, we identified 4\,263 live mutants that were not detected by the test suite. Instead, we had 3\,009 killed mutants detected by the test suite, and 687 mutants that produced the auto generated code of the ASN.1 grammar to go into an infinite loop, and thus were killed by timeout. The final mutation score was of 53.56\%.

The identification of equivalent mutants still needs to be performed.


\subsection{Data-driven mutation testing}

In the context of this project, we foresee two scenarios on how to apply the data-driven mutation testing approach to the ASN.1 case study system. 

\subsubsection{Scenario 1: Testing the ASN.1 Compiler}

The first scenario simply automates robustness testing for ASN.1; we aim to rely on the automatically generated configuration parameters for mutation operators to generate data values that do not respect such constraints. This enables to verify the capability of the ASN.1 code to verifies the constraints of the data types defined in ASN.1 grammars.





%In the first scenario, we focus on the robustness of the auto-generated test cases of an ASN.1 grammar through the ASN.1 compiler.
%Particularly, we aim to apply a fault model that enables different mutations on the data types automatically generated by the ASN.1 compiler. Consequently, for every data type defined in the ASN.1 grammar, we automatically generate a set of probes that stresses all the data types constraints, where each probe contains a single instance of the defined fault model.
%
%The full description of the fault model can be found in Section~\ref{subsub:asn1model}.

\subsubsection{Scenario 2: Testing Case Study Systems using ASN.1}

%The second scenario aims to stress test suites from software systems that uses the encoding and decoding procedures derived from the ASN.1 compiler.
%
%More details about each scenario is provided in the following.

In this second scenario, we aim to assess the adequacy of test suites from software systems that embed the decoding and decoding auto-generated source code from ASN.1 grammar through the ASN.1 compiler.

For this task, we will ask engineers to specify fault models to decide what mutation operator to apply for each data type defined in the ASN.1 grammar.
Additionally, the engineer will be asked to specify in the fault model the nominal ranges for each data type; after applying a specific mutation operator, we will assess if the existing test suite is able to detect the corresponding mutated value by killing the introduced mutant.

For this scenario, further discussions with ESA are required in order to identify case study systems using the ASN.1 compiler. 


