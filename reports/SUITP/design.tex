% !TEX root = MAIN.tex

\chapter{MASS - Software Unit and Integration Test Case Design}
\label{chap:spec}


\section{General}

The MASS unit test suite concerns the source code mutation component (SRCMutation). It address its functional requirements. A single test design has been identified, it is based on the category partition method and reported in the following sections.



\section{MASS - Test Design - SRCMutation - Operators}

\subsection{Test design identifier}

The test design identifier is \emph{MASS-TD-SRCMutation-1}

With this test design we aim to ensure that each mutation operator for the FAQAS is implemented according to its requirements.

\subsection{Features to be tested}

Table~\ref{table:operators} shows the specifications for the mutation operators implemented by SRCMutation.

The set of SRCMutation mutation operators is composed of the following: Absolute Value Insertion (ABS), Arithmetic Operator Replacement (AOR), Integer Constraint Replacement (ICR), Logical Connector Replacement (LCR), Relational Operator Replacement (ROR), Unary Operator Insertion (UOI), Statement Deletion Operator (SDL), and Literal Value Replacement (LVR).
It also include OODL mutation operators: delete Arithmetic (AOD), Bitwise (BOD), Logical (LOD), Relational (ROD), and Shift (SOD) operators.

\input{tables/operators}

Each mutation operator, when applied to a statement, generates one or more mutated statements.
Each mutation operator works by altering the value of a \emph{term} in a statement, which could be either an operator  ($op$), a value ($v$), or a literal ($l$). More precisely, each mutation operator replaces a term with a number of replacement terms, which are identified based on the rules in the description column of Table~\ref{table:operators}.
For each term to mutate, SRCMutation shall generate one mutant including each replacement term.
If a statement includes more than one term to mutate, the mutation operator generates a set of mutants for each term to mutate.




\section{Organization of the Test Cases}

Test cases are identified using the name of the operator acronym and the input type to be processed, for example the test case \texttt{ror\_lt.sh} represents the ROR operator for the ``less than'' input.

Mutation operators
We define one test case for each mutation operator 
The purpose of each test case is to verify that, for a selected CMC produces an output that matches the specifications. This implies that every line of

 i.e., alters the line

 according to the SDD, which implies that  that is, the corresponding syntactically altered version of the software according to operators defined in Table~\ref{table:operators}. 
Note that a mutation operator might produce one or more mutants for a single input, all outputs shall be as expected.

\begin{lstlisting}[language=C, label=test_source, caption=C function example.]
double function() {
int a = 4, b = 5;
return a / b;
}
\end{lstlisting}

\begin{lstlisting}[language=bash, label=test_example, caption=ABS test case example.]
$MUTATOR --compilation "$FILE -o test" --operators ABS

EXPECTED="double function() {\ndouble a = 3;\nreturn -(a);\n}"

tst=`diff test.mut.3.1_1_8.ABS.function.c <(echo -e $EXPECTED) | wc -l`

if [ $tst -eq 0 ];then
    echo -e "TEST abs_val PASSED"
else
    echo -e "TEST abs_val FAILED"
fi
\end{lstlisting}


Listings~\ref{test_source} and~\ref{test_example} introduce an example of source code and test case for the mutation operator ABS, respectively. As shown in Listing~\ref{test_example}, each test case (i) invokes the mutator component selecting the corresponding operator acronym, (ii) defines the expected output for operator, (iii) checks if there are differences between the actual output of the component and the expected output.

All test cases are independent from each other; therefore there is no need of executing test cases in a specific order.


Table~\ref{table:matrix} provides the complete list of unit test cases that covers all the mutation operators of \FAQAS. 
Column \emph{Input} indicates the operator appearing in the line to be mutated.
Note that the mutator shall generate one mutant for each element of the replacement column.

\input{tables/matrix}

