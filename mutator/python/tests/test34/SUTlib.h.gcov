        -:    0:Source:./SUTlib.h
        -:    0:Graph:SUT.gcno
        -:    0:Data:SUT.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "FAQAS_dataDrivenMutator.h"
        -:    2:#include <iostream>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include <vector>
        -:    7:
        -:    8:int mutate(std::vector<long int> *v, FaultModel *fm) {
       30:    9:  return _FAQAS_mutate(v->data(), fm);
        -:   10:}
        -:   11:
        -:   12://*****************************************************************************
        -:   13:// These 3 functions are used to write various datatypes into the buffer
        -:   14:
        -:   15:void double_push_back(std::vector<long int> *v, double val) {
        -:   16:
       50:   17:  long int tmp = 0;
        -:   18:
       50:   19:  memcpy(&tmp, &val, sizeof(double));
        -:   20:
       50:   21:  v->push_back(tmp);
       50:   22:}
        -:   23:
        -:   24:void float_push_back(std::vector<long int> *v, float val) {
       50:   25:  long int tmp = 0;
        -:   26:
       50:   27:  memcpy(&tmp, &val, sizeof(float));
        -:   28:
       50:   29:  v->push_back(tmp);
       50:   30:}
        -:   31:
        -:   32:void int_push_back(std::vector<long int> *v, int val) {
       50:   33:  long int tmp = 0;
        -:   34:
       50:   35:  memcpy(&tmp, &val, sizeof(int));
        -:   36:
       50:   37:  v->push_back(tmp);
       50:   38:}
        -:   39:
        -:   40://*****************************************************************************
        -:   41:// this vector represents the state variables of a system
        -:   42:
        2:   43:std::vector<int> vectorA;
        -:   44:
        2:   45:std::vector<float> vectorB;
        -:   46:
        2:   47:std::vector<double> vectorC;
        -:   48:
        -:   49://*****************************************************************************
        -:   50:// this vectors represent the buffer
        -:   51:
        2:   52:std::vector<long int> bufferA;
        2:   53:std::vector<long int> bufferB;
        2:   54:std::vector<long int> bufferC;
        2:   55:std::vector<long int> bufferMain;
        -:   56:
        -:   57://*****************************************************************************
        -:   58:// this vectors will contain the parameters in which the variables must remain
        -:   59:
        2:   60:std::vector<int> minA;
        2:   61:std::vector<int> maxA;
        2:   62:std::vector<float> minB;
        2:   63:std::vector<float> maxB;
        2:   64:std::vector<double> minC;
        2:   65:std::vector<double> maxC;
        -:   66:
        -:   67://*****************************************************************************
        -:   68:// these functions simulate sensors acquiring the values of the state variables
        -:   69:// and writing them on the buffer to be read by a control system
        -:   70:
        -:   71:void sensorA() {
        -:   72:
        -:   73:
       20:   74:  bufferA.clear();
       10:   75:  int position = 0;
      120:   76:  while (position < 5) {
       50:   77:    int_push_back(&bufferA, vectorA[position]);
       50:   78:    position = position + 1;
        -:   79:  }
        -:   80:
        -:   81:  // PROBE
       10:   82:  FaultModel *fm = _FAQAS_SensorA_FM();
       10:   83:  mutate(&bufferA, fm);
        -:   84:  // END OF THE PROBE
       10:   85:}
        -:   86:
        -:   87:void sensorB() {
        -:   88:
        -:   89:
       20:   90:  bufferB.clear();
       10:   91:  int position = 0;
      120:   92:  while (position < 5) {
       50:   93:    float_push_back(&bufferB, vectorB[position]);
       50:   94:    position = position + 1;
        -:   95:  }
        -:   96:  // PROBE
       10:   97:  FaultModel *fm = _FAQAS_SensorB_FM();
       10:   98:  mutate(&bufferA, fm);
        -:   99:  // END OF THE PROBE
       10:  100:}
        -:  101:
        -:  102:void sensorC() {
        -:  103:
        -:  104:
       20:  105:  bufferC.clear();
       10:  106:  int position = 0;
      120:  107:  while (position < 5) {
       50:  108:    double_push_back(&bufferC, vectorC[position]);
       50:  109:    position = position + 1;
        -:  110:  }
        -:  111:
        -:  112:  // PROBE
       10:  113:  FaultModel *fm = _FAQAS_SensorC_FM();
       10:  114:  mutate(&bufferA, fm);
        -:  115:  // END OF THE PROBE
       10:  116:}
        -:  117:
        -:  118://*****************************************************************************
        -:  119:// these functions emulate actuators acting on the state variables using the
        -:  120:// vector BufferMain as reference
        -:  121:
        -:  122:void actuatorA() {
        -:  123:
    #####:  124:  int add = 0;
        -:  125:
        -:  126:  // PROBE
    #####:  127:  FaultModel *fm = _FAQAS_ActuatorA_FM();
    #####:  128:  mutate(&bufferMain, fm);
        -:  129:  // END OF THE PROBE
        -:  130:
    #####:  131:  memcpy(&add, &bufferMain[0], sizeof(add));
    #####:  132:  vectorA[0] = vectorA[0] + add;
    #####:  133:  add = 0;
    #####:  134:  memcpy(&add, &bufferMain[1], sizeof(add));
    #####:  135:  vectorA[1] = vectorA[1] + add;
    #####:  136:  add = 0;
    #####:  137:  memcpy(&add, &bufferMain[2], sizeof(add));
    #####:  138:  vectorA[2] = vectorA[2] + add;
    #####:  139:  add = 0;
    #####:  140:  memcpy(&add, &bufferMain[3], sizeof(add));
    #####:  141:  vectorA[3] = vectorA[3] + add;
    #####:  142:  add = 0;
    #####:  143:  memcpy(&add, &bufferMain[4], sizeof(add));
    #####:  144:  vectorA[4] = vectorA[4] + add;
    #####:  145:  bufferMain.clear();
    #####:  146:}
        -:  147:
        -:  148:void actuatorB() {
        -:  149:
        -:  150:  // PROBE
    #####:  151:  FaultModel *fm = _FAQAS_ActuatorB_FM();
    #####:  152:  mutate(&bufferMain, fm);
        -:  153:  // END OF THE PROBE
        -:  154:
    #####:  155:  int add = 0;
    #####:  156:  memcpy(&add, &bufferMain[0], sizeof(add));
    #####:  157:  vectorB[0] = vectorB[0] + add;
    #####:  158:  add = 0;
    #####:  159:  memcpy(&add, &bufferMain[1], sizeof(add));
    #####:  160:  vectorB[1] = vectorB[1] + add;
    #####:  161:  add = 0;
    #####:  162:  memcpy(&add, &bufferMain[2], sizeof(add));
    #####:  163:  vectorB[2] = vectorB[2] + add;
    #####:  164:  add = 0;
    #####:  165:  memcpy(&add, &bufferMain[3], sizeof(add));
    #####:  166:  vectorB[3] = vectorB[3] + add;
    #####:  167:  add = 0;
    #####:  168:  memcpy(&add, &bufferMain[4], sizeof(add));
    #####:  169:  vectorB[4] = vectorB[4] + add;
    #####:  170:  bufferMain.clear();
    #####:  171:}
        -:  172:
        -:  173:void actuatorC() {
        -:  174:
        -:  175:  // PROBE
    #####:  176:  FaultModel *fm = _FAQAS_ActuatorC_FM();
    #####:  177:  mutate(&bufferMain, fm);
        -:  178:  // END OF THE PROBE
        -:  179:
    #####:  180:  int add = 0;
    #####:  181:  memcpy(&add, &bufferMain[0], sizeof(add));
    #####:  182:  vectorC[0] = vectorC[0] + add;
    #####:  183:  add = 0;
    #####:  184:  memcpy(&add, &bufferMain[1], sizeof(add));
    #####:  185:  vectorC[1] = vectorC[1] + add;
    #####:  186:  add = 0;
    #####:  187:  memcpy(&add, &bufferMain[2], sizeof(add));
    #####:  188:  vectorC[2] = vectorC[2] + add;
    #####:  189:  add = 0;
    #####:  190:  memcpy(&add, &bufferMain[3], sizeof(add));
    #####:  191:  vectorC[3] = vectorC[3] + add;
    #####:  192:  add = 0;
    #####:  193:  memcpy(&add, &bufferMain[4], sizeof(add));
    #####:  194:  vectorC[4] = vectorC[4] + add;
    #####:  195:  bufferMain.clear();
    #####:  196:}
        -:  197:
        -:  198://*****************************************************************************
        -:  199:// this functions represent a proportional controller taking as input the error
        -:  200:// and giving different outputs depending on the magnitude of the error
        -:  201:
        -:  202:int getCorrection(int error) {
        -:  203:
    #####:  204:  int absoluteError = abs(error);
        -:  205:  // e in base a quanto Ã© sceglie il comando da applicare
    #####:  206:  int absCorrection = 0;
        -:  207:
    #####:  208:  if (absoluteError == 0) {
    #####:  209:    absCorrection = 0;
    #####:  210:  }
        -:  211:
    #####:  212:  else if (absoluteError > 0 && absoluteError < 5) {
    #####:  213:    absCorrection = 1;
    #####:  214:  }
        -:  215:
    #####:  216:  else if (absoluteError >= 5 && absoluteError < 10) {
    #####:  217:    absCorrection = 5;
    #####:  218:  }
        -:  219:
    #####:  220:  else if (absoluteError >= 10 && absoluteError < 50) {
    #####:  221:    absCorrection = 10;
    #####:  222:  }
        -:  223:
        -:  224:  else {
    #####:  225:    absCorrection = 100;
        -:  226:  }
        -:  227:
        -:  228:  int correction;
        -:  229:
    #####:  230:  if (error <= 0) {
        -:  231:
    #####:  232:    correction = -absCorrection;
    #####:  233:  }
        -:  234:
    #####:  235:  if (error > 0) {
    #####:  236:    correction = absCorrection;
    #####:  237:  }
        -:  238:
    #####:  239:  return correction;
        -:  240:}
