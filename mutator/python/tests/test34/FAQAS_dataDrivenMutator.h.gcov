        -:    0:Source:./FAQAS_dataDrivenMutator.h
        -:    0:Graph:SUT.gcno
        -:    0:Data:SUT.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://max MUTATIONOPT=5//
        -:    2:// Copyright (c) University of Luxembourg 2020.
        -:    3:// Created by Fabrizio PASTORE, fabrizio.pastore@uni.lu, SnT, 2020.
        -:    4:// Modified by Oscar Eduardo CORNEJO OLIVARES, oscar.cornejo@uni.lu, SnT, 2020.
        -:    5://
        -:    6:
        -:    7:#include <stdlib.h>
        -:    8:#include <stdio.h>
        -:    9:#include <string.h>
        -:   10:
        -:   11://time.h is  included for seeding the INV random number generator in the footer
        -:   12:#include <time.h>
        -:   13:
        -:   14://math.h is included for the INV (normal distribution) and for the BF operator
        -:   15:#include <math.h>
        -:   16:
        -:   17:#define MAX_OPS 10
        -:   18:#define ITEMS 10
        -:   19://#define MUTATIONOPT 2
        -:   20:
        -:   21:int MUTATION=MUTATIONOPT;
        -:   22:
        -:   23:// #typedef T_LONG long long
        -:   24:
        -:   25:double faqas_abs(double a){
    #####:   26:	if ( a < 0 )
    #####:   27:		return - a;
    #####:   28:	return a;
    #####:   29:}
        -:   30:
        -:   31:int faqas_double_equal(double a, double b){
    #####:   32:	return faqas_abs(a-b) < 1E-3;
        -:   33:}
        -:   34:
        -:   35:enum DataType {
        -:   36:    INT,
        -:   37:    FLOAT,
        -:   38:    DOUBLE,
        -:   39:    BIN,
        -:   40:    LONG
        -:   41:};
        -:   42:
        -:   43:typedef enum DataType DataType;
        -:   44:
        -:   45:enum MutationType{
        -:   46:    BF,
        -:   47:    IV,
        -:   48:    VOR,
        -:   49:    VAT,
        -:   50:    VBT,
        -:   51:    INV,
        -:   52:    SS,
        -:   53:		ASA,
        -:   54:		HV
        -:   55:};
        -:   56:
        -:   57:typedef enum MutationType MutationType;
        -:   58:
        -:   59:int _FAQAS_mutated = 0;
        -:   60:
        -:   61:struct MutationOperator {
        -:   62:    MutationType type;
        -:   63:
        -:   64:    // int min;
        -:   65:    // int max;
        -:   66:    // int threshold;
        -:   67:    // int delta;
        -:   68:    // int state;
        -:   69:    // int value;
        -:   70:
        -:   71:    double min;
        -:   72:    double max;
        -:   73:    double threshold;
        -:   74:    double delta;
        -:   75:    int state;
        -:   76:    double value;
        -:   77:
        -:   78:};
        -:   79:
        -:   80:typedef struct MutationOperator MutationOperator;
        -:   81:
        -:   82:struct DataItem {
        -:   83:    DataType type;
        -:   84:    int span;
        -:   85:    int operatorsN;
        -:   86:    struct MutationOperator operators[MAX_OPS];
        -:   87:};
        -:   88:
        -:   89:struct FaultModel {
        -:   90:    int itemsN;
        -:   91:    int ID;
        -:   92:    struct DataItem *items;
        -:   93:};
        -:   94:
        -:   95:typedef struct FaultModel FaultModel;
        -:   96:
        -:   97:struct FaultModel* _FAQAS_create_FM(int items){
       30:   98:    struct FaultModel *dm = (struct FaultModel *) malloc ( sizeof( *dm ) );
       30:   99:    dm->itemsN=items;
       30:  100:    dm->items = (struct DataItem *) malloc( sizeof ( struct DataItem ) * items );
       30:  101:    return dm;
        -:  102:}
        -:  103:
        -:  104:void _FAQAS_delete_FM(FaultModel *dm) {
    #####:  105:    if ( dm == 0 )
    #####:  106:        return;
    #####:  107:    free( dm->items );
    #####:  108:    free( dm );
    #####:  109:}
        -:  110:
        -:  111://memory for HV
        -:  112:int storedValueInt;
        -:  113:unsigned long long storedValueBin;
        -:  114:double storedValueDouble;
        -:  115:float storedValueFloat;
        -:  116:
        -:  117:int repeatCounter;
        -:  118:int sample=1;
        -:  119:
        -:  120:
        -:  121://_FAQAS_slice_it_up divides long integers in "slices" of binary to be stored in the elements of the buffer when span!=1
        -:  122:unsigned long long _FAQAS_slice_it_up(unsigned long long numberToSlice, int sliceStart,
        -:  123:                             int sliceEnd) {
        -:  124:
    #####:  125:  int i = sliceStart;
    #####:  126:  unsigned long long slice = 0;
    #####:  127:  while(i<=sliceEnd) {
    #####:  128:    unsigned long long mask = pow(2, i);
    #####:  129:    unsigned long long relevant = numberToSlice & mask;
        -:  130:
    #####:  131:    if (relevant == mask) {
    #####:  132:      unsigned long long knife = pow(2, i - sliceStart);
    #####:  133:      slice = slice | knife;
    #####:  134:    }
    #####:  135:    i=i+1;
        -:  136:  }
    #####:  137:  return (slice);
        -:  138:}
        -:  139:
        -:  140://this function is useful for checking the binary data during debugging
        -:  141:
        -:  142:void _FAQAS_print_binary(unsigned long long n) {
        -:  143:
    #####:  144:  int steps = 8 * sizeof(n) - 1;
        -:  145:
    #####:  146:  while (steps >= 0) {
        -:  147:
    #####:  148:    unsigned long long mask = pow(2, steps);
        -:  149:
    #####:  150:    unsigned long long relevant = n & mask;
        -:  151:
    #####:  152:    if (relevant == mask) {
        -:  153:
    #####:  154:      printf("1");
        -:  155:
    #####:  156:    } else {
        -:  157:
    #####:  158:      printf("0");
        -:  159:
        -:  160:    }
        -:  161:
    #####:  162:    steps = steps - 1;
        -:  163:  }
        -:  164:
    #####:  165:  printf("\n");
    #####:  166:}
        -:  167:#define SIZE_SensorA 2
        -:  168:#define SIZE_SensorB 2
        -:  169:#define SIZE_SensorC 2
        -:  170:#define SIZE_ActuatorA 2
        -:  171:#define SIZE_ActuatorB 2
        -:  172:#define SIZE_ActuatorC 2
        -:  173:
        -:  174:
        -:  175:struct FaultModel* _FAQAS_SensorA_FM(){
       20:  176:FaultModel *fm = _FAQAS_create_FM(SIZE_SensorA);
       10:  177:fm->ID = 0;
        -:  178:
       10:  179:fm->items[1].operators[0].type=SS;
       10:  180:fm->items[1].operators[0].threshold=0;
       10:  181:fm->items[1].operators[0].delta=1000;
       10:  182:fm->items[1].operatorsN=1;
       10:  183:fm->items[1].span=1;
       10:  184:fm->items[1].type=INT;
       10:  185:return fm;
        -:  186:}
        -:  187:struct FaultModel* _FAQAS_SensorB_FM(){
       20:  188:FaultModel *fm = _FAQAS_create_FM(SIZE_SensorB);
       10:  189:fm->ID = 1;
        -:  190:
       10:  191:fm->items[1].operators[0].type=SS;
       10:  192:fm->items[1].operators[0].threshold=0;
       10:  193:fm->items[1].operators[0].delta=1000;
       10:  194:fm->items[1].operatorsN=1;
       10:  195:fm->items[1].span=1;
       10:  196:fm->items[1].type=FLOAT;
       10:  197:return fm;
        -:  198:}
        -:  199:struct FaultModel* _FAQAS_SensorC_FM(){
       20:  200:FaultModel *fm = _FAQAS_create_FM(SIZE_SensorC);
       10:  201:fm->ID = 2;
        -:  202:
       10:  203:fm->items[1].operators[0].type=SS;
       10:  204:fm->items[1].operators[0].threshold=0;
       10:  205:fm->items[1].operators[0].delta=1000;
       10:  206:fm->items[1].operatorsN=1;
       10:  207:fm->items[1].span=1;
       10:  208:fm->items[1].type=DOUBLE;
       10:  209:return fm;
        -:  210:}
        -:  211:struct FaultModel* _FAQAS_ActuatorA_FM(){
    #####:  212:FaultModel *fm = _FAQAS_create_FM(SIZE_ActuatorA);
    #####:  213:fm->ID = 3;
        -:  214:
    #####:  215:fm->items[1].operators[0].type=SS;
    #####:  216:fm->items[1].operators[0].threshold=0;
    #####:  217:fm->items[1].operators[0].delta=1000;
    #####:  218:fm->items[1].operatorsN=1;
    #####:  219:fm->items[1].span=1;
    #####:  220:fm->items[1].type=INT;
    #####:  221:return fm;
        -:  222:}
        -:  223:struct FaultModel* _FAQAS_ActuatorB_FM(){
    #####:  224:FaultModel *fm = _FAQAS_create_FM(SIZE_ActuatorB);
    #####:  225:fm->ID = 4;
        -:  226:
    #####:  227:fm->items[1].operators[0].type=SS;
    #####:  228:fm->items[1].operators[0].threshold=0;
    #####:  229:fm->items[1].operators[0].delta=1000;
    #####:  230:fm->items[1].operatorsN=1;
    #####:  231:fm->items[1].span=1;
    #####:  232:fm->items[1].type=FLOAT;
    #####:  233:return fm;
        -:  234:}
        -:  235:struct FaultModel* _FAQAS_ActuatorC_FM(){
    #####:  236:FaultModel *fm = _FAQAS_create_FM(SIZE_ActuatorC);
    #####:  237:fm->ID = 5;
        -:  238:
    #####:  239:fm->items[1].operators[0].type=SS;
    #####:  240:fm->items[1].operators[0].threshold=0;
    #####:  241:fm->items[1].operators[0].delta=1000;
    #####:  242:fm->items[1].operatorsN=1;
    #####:  243:fm->items[1].span=1;
    #####:  244:fm->items[1].type=DOUBLE;
    #####:  245:return fm;
        -:  246:}
        -:  247:
        -:  248:
        -:  249:int _FAQAS_selectItem(){
    #####:  250:if ( MUTATION == 0 )
    #####:  251:    return 1;
    #####:  252:if ( MUTATION == 1 )
    #####:  253:    return 1;
    #####:  254:if ( MUTATION == 2 )
    #####:  255:    return 1;
    #####:  256:if ( MUTATION == 3 )
    #####:  257:    return 1;
    #####:  258:if ( MUTATION == 4 )
    #####:  259:    return 1;
    #####:  260:if ( MUTATION == 5 )
    #####:  261:    return 1;
    #####:  262:return -999;
    #####:  263:}
        -:  264:int _FAQAS_selectOperator(){
    #####:  265:if ( MUTATION == 0 )
    #####:  266:    return 0;
    #####:  267:if ( MUTATION == 1 )
    #####:  268:    return 0;
    #####:  269:if ( MUTATION == 2 )
    #####:  270:    return 0;
    #####:  271:if ( MUTATION == 3 )
    #####:  272:    return 0;
    #####:  273:if ( MUTATION == 4 )
    #####:  274:    return 0;
    #####:  275:if ( MUTATION == 5 )
    #####:  276:    return 0;
    #####:  277:return -999;
    #####:  278:}
        -:  279:int _FAQAS_selectOperation(){
    #####:  280:if ( MUTATION == 0 )
    #####:  281:    return 0;
    #####:  282:if ( MUTATION == 1 )
    #####:  283:    return 0;
    #####:  284:if ( MUTATION == 2 )
    #####:  285:    return 0;
    #####:  286:if ( MUTATION == 3 )
    #####:  287:    return 0;
    #####:  288:if ( MUTATION == 4 )
    #####:  289:    return 0;
    #####:  290:if ( MUTATION == 5 )
    #####:  291:    return 0;
    #####:  292:return -999;
    #####:  293:}
        -:  294:
        -:  295:
        -:  296:#define APPLY_ONE_MUTATION 0
        -:  297:
        -:  298:int FAQAS_fmCov;
        -:  299:void _FAQAS_fmCoverage(int fm){
       30:  300:    switch (fm){
        -:  301:    case 0:
       10:  302:    FAQAS_fmCov++;
       10:  303:    break;
        -:  304:    case 1:
       10:  305:    FAQAS_fmCov++;
       10:  306:    break;
        -:  307:    case 2:
       10:  308:    FAQAS_fmCov++;
       10:  309:    break;
        -:  310:    case 3:
    #####:  311:    FAQAS_fmCov++;
    #####:  312:    break;
        -:  313:    case 4:
    #####:  314:    FAQAS_fmCov++;
    #####:  315:    break;
        -:  316:    case 5:
    #####:  317:    FAQAS_fmCov++;
    #####:  318:    break;
        -:  319:    default:
    #####:  320:    break;
        -:  321:    }
       30:  322:}
        -:  323:
        -:  324://
        -:  325:// Copyright (c) University of Luxembourg 2020.
        -:  326:// Created by Fabrizio PASTORE, fabrizio.pastore@uni.lu, SnT, 2020.
        -:  327:// Modified by Oscar Eduardo CORNEJO OLIVARES, oscar.cornejo@uni.lu, SnT, 2020.
        -:  328://
        -:  329:
        -:  330:int _FAQAS_mutate(long *data, FaultModel *fm) {
        -:  331:  if (APPLY_ONE_MUTATION && _FAQAS_mutated == 1)
        -:  332:    // if (_FAQAS_mutated == 1)
        -:  333:    return 0;
        -:  334:
       30:  335:  if (MUTATION == -1)
    #####:  336:    return 0;
        -:  337:
       30:  338:  if (MUTATION == -2) {
       30:  339:    _FAQAS_fmCoverage(fm->ID);
        -:  340:    //FILE *f = fopen("/home/csp/logging.txt", "ab+");
        -:  341:    //fprintf(f, "fm.ID: %d\n", fm->ID);
        -:  342:    //fclose(f);
        -:  343:
       30:  344:    return 0;
        -:  345:  }
        -:  346:
    #####:  347:  int pos = _FAQAS_selectItem();
    #####:  348:  int op = _FAQAS_selectOperator();
    #####:  349:  int opt = _FAQAS_selectOperation();
        -:  350:
    #####:  351:  int valueInt = 0;
        -:  352:  // int valueBin = 0;
    #####:  353:  unsigned long long valueBin = 0;
    #####:  354:  double valueDouble = 0;
    #####:  355:  float valueFloat = 0;
        -:  356:
    #####:  357:  srand(time(NULL));
        -:  358:  //
        -:  359:  // Load the data
        -:  360:  //
        -:  361:
    #####:  362:  int span = fm->items[pos].span;
        -:  363:
        -:  364:  // if (span == 1) {
        -:  365:  //
        -:  366:  //   if (fm->items[pos].type == BIN) {
        -:  367:  //     valueBin = (int)data[pos];
        -:  368:  //   }
        -:  369:  //   if (fm->items[pos].type == INT) {
        -:  370:  //
        -:  371:  //     valueInt = (int)data[pos];
        -:  372:  //   }
        -:  373:  //   if (fm->items[pos].type == DOUBLE) {
        -:  374:  //     valueDouble = (double)data[pos];
        -:  375:  //   }
        -:  376:  //   if (fm->items[pos].type == FLOAT) {
        -:  377:  //     valueFloat = (float)data[pos];
        -:  378:  //   }
        -:  379:  // }
        -:  380:
        -:  381:  // else if (span != 1) {
        -:  382:
        -:  383:  int kk;
        -:  384:  int step;
    #####:  385:  unsigned long long row = 0;
    #####:  386:  unsigned long long intermediate = 0;
        -:  387:
    #####:  388:  for (kk = 0; kk < (span); kk = kk + 1) {
        -:  389:
    #####:  390:    step = 8 * sizeof(data[pos + kk]);
        -:  391:
    #####:  392:    intermediate = intermediate << step;
        -:  393:
    #####:  394:    row = 0;
        -:  395:
    #####:  396:    memcpy(&row, &data[pos + kk], sizeof(data[pos + kk]));
        -:  397:
    #####:  398:    intermediate = (intermediate | row);
    #####:  399:  }
        -:  400:
    #####:  401:  if (fm->items[pos].type == BIN) {
        -:  402:
    #####:  403:    unsigned long long fitToSize = (unsigned long long)intermediate;
        -:  404:
    #####:  405:    memcpy(&valueBin, &fitToSize, sizeof(valueBin));
    #####:  406:  }
        -:  407:
    #####:  408:  if (fm->items[pos].type == INT) {
        -:  409:
    #####:  410:    unsigned int fitToSize = (unsigned int)intermediate;
        -:  411:
    #####:  412:    memcpy(&valueInt, &fitToSize, sizeof(valueInt));
    #####:  413:  }
        -:  414:
    #####:  415:  if (fm->items[pos].type == DOUBLE) {
        -:  416:
    #####:  417:    unsigned long long int fitToSize = (unsigned long long int)intermediate;
        -:  418:
    #####:  419:    memcpy(&valueDouble, &fitToSize, sizeof(valueDouble));
    #####:  420:  }
        -:  421:
    #####:  422:  if (fm->items[pos].type == FLOAT) {
        -:  423:
    #####:  424:    unsigned long int fitToSize = (unsigned long int)intermediate;
        -:  425:
    #####:  426:    memcpy(&valueFloat, &fitToSize, sizeof(valueFloat));
    #####:  427:  }
        -:  428:
        -:  429:  // }
        -:  430:  //  if else closing bracket
        -:  431:
    #####:  432:  MutationOperator *OP = &(fm->items[pos].operators[op]);
        -:  433:
        -:  434:
    #####:  435:  if (OP->type == HV) {
        -:  436:
    #####:  437:    if (sample==1){
        -:  438:
    #####:  439:      if (fm->items[pos].type == INT) {
        -:  440:
    #####:  441:        storedValueInt = valueInt;
    #####:  442:      }
        -:  443:
    #####:  444:      if (fm->items[pos].type == DOUBLE) {
        -:  445:
    #####:  446:        storedValueDouble = valueDouble;
    #####:  447:      }
        -:  448:
    #####:  449:      if (fm->items[pos].type == FLOAT) {
        -:  450:
    #####:  451:        storedValueFloat = valueFloat;
    #####:  452:      }
        -:  453:
    #####:  454:      if (fm->items[pos].type == BIN) {
        -:  455:
    #####:  456:        storedValueBin = valueBin;
    #####:  457:      }
        -:  458:
    #####:  459:      sample=0;
        -:  460:
    #####:  461:      repeatCounter = OP->value;
        -:  462:
    #####:  463:    }
        -:  464:
    #####:  465:    if(repeatCounter>0){
        -:  466:
    #####:  467:      if (fm->items[pos].type == INT) {
        -:  468:
    #####:  469:        valueInt = storedValueInt;
    #####:  470:      }
        -:  471:
    #####:  472:      if (fm->items[pos].type == DOUBLE) {
        -:  473:
    #####:  474:        valueDouble = storedValueDouble;
    #####:  475:      }
        -:  476:
    #####:  477:      if (fm->items[pos].type == FLOAT) {
        -:  478:
    #####:  479:        valueFloat = storedValueFloat;
    #####:  480:      }
        -:  481:
    #####:  482:      if (fm->items[pos].type == BIN) {
        -:  483:
    #####:  484:        valueBin = storedValueBin;
    #####:  485:      }
        -:  486:
    #####:  487:      repeatCounter=repeatCounter-1;
    #####:  488:    }
        -:  489:
    #####:  490:    if(repeatCounter==0){
    #####:  491:      sample=1;
    #####:  492:    }
        -:  493:
    #####:  494:    _FAQAS_mutated = 1;
    #####:  495:  }
        -:  496:
        -:  497:
    #####:  498:  if (OP->type == BF) {
        -:  499:
        -:  500:    unsigned long long mask;
        -:  501:    // min = position of the first flippable bit from right to left
    #####:  502:    int Min = OP->min;
        -:  503:    // max = position of the last flippable bit from right to left
    #####:  504:    int Max = OP->max;
        -:  505:    // numberOfBits: (maximum) number of bits to change
        -:  506:
    #####:  507:    int numberOfBits = OP->value;
        -:  508:    // state: 1 mutate only bits ==1 and viceversa
    #####:  509:    int State = OP->state;
        -:  510:    // random position of the bit to be changed
        -:  511:    int randomPosition;
        -:  512:
        -:  513:    unsigned long long flipped;
        -:  514:
        -:  515:    int avoidInfinite;
        -:  516:
    #####:  517:    if (State == 0) {
        -:  518:
        -:  519:      // printf("entra nello state 0\n" );
        -:  520:
    #####:  521:      int ii = 0;
        -:  522:
    #####:  523:      for (ii = 0; ii < numberOfBits; ii = ii + 1) {
        -:  524:
    #####:  525:        avoidInfinite = 0;
        -:  526:
    #####:  527:        flipped = valueBin;
        -:  528:
    #####:  529:        while (flipped == valueBin) {
        -:  530:
    #####:  531:          randomPosition = (rand() % (Max - Min + 1)) + Min;
        -:  532:
    #####:  533:          mask = pow(2, randomPosition);
        -:  534:
    #####:  535:          flipped = valueBin | mask;
        -:  536:
    #####:  537:          avoidInfinite = avoidInfinite + 1;
        -:  538:
    #####:  539:          if (avoidInfinite == numberOfBits * 10) {
    #####:  540:            break;
        -:  541:          }
        -:  542:        }
        -:  543:
    #####:  544:        valueBin = flipped;
    #####:  545:      }
    #####:  546:    }
        -:  547:
    #####:  548:    else if (State == 1) {
        -:  549:
    #####:  550:      int ii = 0;
        -:  551:
    #####:  552:      for (ii = 0; ii < numberOfBits; ii = ii + 1) {
        -:  553:
    #####:  554:        avoidInfinite = 0;
        -:  555:
    #####:  556:        flipped = valueBin;
        -:  557:
    #####:  558:        while (flipped == valueBin) {
        -:  559:
    #####:  560:          randomPosition = (rand() % (Max - Min + 1)) + Min;
        -:  561:
    #####:  562:          mask = pow(2, randomPosition);
        -:  563:
    #####:  564:          flipped = valueBin & ~mask;
        -:  565:
    #####:  566:          avoidInfinite = avoidInfinite + 1;
        -:  567:
    #####:  568:          if (avoidInfinite == numberOfBits * 10) {
    #####:  569:            break;
        -:  570:          }
        -:  571:        }
        -:  572:
    #####:  573:        valueBin = flipped;
    #####:  574:      }
    #####:  575:    }
        -:  576:
        -:  577:    // else if (State==-1)
        -:  578:    else {
        -:  579:
        -:  580:      // mask = 1;                   // 00000011
        -:  581:      // valueBin = valueBin ^ mask; // 00000100
        -:  582:
    #####:  583:      int ii = 0;
        -:  584:
    #####:  585:      for (ii = 0; ii < numberOfBits; ii = ii + 1) {
        -:  586:
    #####:  587:        flipped = valueBin;
        -:  588:
    #####:  589:        avoidInfinite = 0;
        -:  590:
    #####:  591:        while (flipped == valueBin) {
        -:  592:
    #####:  593:          randomPosition = (rand() % (Max - Min + 1)) + Min;
        -:  594:
    #####:  595:          mask = pow(2, randomPosition);
        -:  596:
    #####:  597:          flipped = valueBin & ~mask;
        -:  598:
    #####:  599:          if (flipped == valueBin) {
        -:  600:
    #####:  601:            flipped = valueBin | mask;
    #####:  602:          }
        -:  603:
    #####:  604:          avoidInfinite = avoidInfinite + 1;
        -:  605:
    #####:  606:          if (avoidInfinite == numberOfBits * 10)
    #####:  607:            break;
        -:  608:        }
        -:  609:
    #####:  610:        valueBin = flipped;
    #####:  611:      }
        -:  612:    }
        -:  613:
    #####:  614:    _FAQAS_mutated = 1;
    #####:  615:  }
        -:  616:
    #####:  617:  if (OP->type == VOR) {
        -:  618:
    #####:  619:    if (fm->items[pos].type == INT) {
        -:  620:
    #####:  621:      if (opt == 0) {
        -:  622:
    #####:  623:        valueInt = OP->min - OP->delta;
    #####:  624:      }
        -:  625:
    #####:  626:      else if (opt == 1) {
    #####:  627:        valueInt = OP->max + OP->delta;
    #####:  628:      }
        -:  629:
        -:  630:      else {
        -:  631:        // ERROR
        -:  632:      }
        -:  633:
    #####:  634:      _FAQAS_mutated = 1;
    #####:  635:    }
        -:  636:
    #####:  637:    if (fm->items[pos].type == DOUBLE) {
        -:  638:
    #####:  639:      if (opt == 0) {
        -:  640:
    #####:  641:        valueDouble = (double)OP->min - OP->delta;
    #####:  642:      }
        -:  643:
    #####:  644:      else if (opt == 1) {
    #####:  645:        valueDouble = (double)OP->max + OP->delta;
    #####:  646:      }
        -:  647:
        -:  648:      else {
        -:  649:        // ERROR
        -:  650:      }
        -:  651:
    #####:  652:      _FAQAS_mutated = 1;
    #####:  653:    }
        -:  654:
    #####:  655:    if (fm->items[pos].type == FLOAT) {
        -:  656:
    #####:  657:      if (opt == 0) {
        -:  658:
    #####:  659:        valueFloat = (float)OP->min - OP->delta;
    #####:  660:      }
        -:  661:
    #####:  662:      else if (opt == 1) {
    #####:  663:        valueFloat = (float)OP->max + OP->delta;
    #####:  664:      }
        -:  665:
        -:  666:      else {
        -:  667:        // ERROR
        -:  668:      }
        -:  669:
    #####:  670:      _FAQAS_mutated = 1;
    #####:  671:    }
    #####:  672:  }
        -:  673:
    #####:  674:  if (OP->type == VAT) {
        -:  675:
    #####:  676:    if (fm->items[pos].type == INT) {
        -:  677:
    #####:  678:      valueInt = OP->threshold + OP->delta;
        -:  679:
    #####:  680:      _FAQAS_mutated = 1;
    #####:  681:    }
        -:  682:
    #####:  683:    if (fm->items[pos].type == DOUBLE) {
        -:  684:
    #####:  685:      valueDouble = (double)OP->threshold + OP->delta;
        -:  686:
    #####:  687:      _FAQAS_mutated = 1;
    #####:  688:    }
        -:  689:
    #####:  690:    if (fm->items[pos].type == FLOAT) {
        -:  691:
    #####:  692:      valueFloat = (float)OP->threshold + OP->delta;
        -:  693:
    #####:  694:      _FAQAS_mutated = 1;
    #####:  695:    }
    #####:  696:  }
        -:  697:
    #####:  698:  if (OP->type == VBT) {
        -:  699:
    #####:  700:    if (fm->items[pos].type == INT) {
        -:  701:
    #####:  702:      valueInt = OP->threshold - OP->delta;
        -:  703:
    #####:  704:      _FAQAS_mutated = 1;
    #####:  705:    }
        -:  706:
    #####:  707:    if (fm->items[pos].type == DOUBLE) {
        -:  708:
    #####:  709:      valueDouble = (double)OP->threshold - OP->delta;
        -:  710:
    #####:  711:      _FAQAS_mutated = 1;
    #####:  712:    }
        -:  713:
    #####:  714:    if (fm->items[pos].type == FLOAT) {
        -:  715:
    #####:  716:      valueFloat = (float)OP->threshold - OP->delta;
        -:  717:
    #####:  718:      _FAQAS_mutated = 1;
    #####:  719:    }
    #####:  720:  }
        -:  721:
    #####:  722:  if (OP->type == IV) {
        -:  723:
    #####:  724:    if (fm->items[pos].type == INT) {
        -:  725:
    #####:  726:      valueInt = OP->value;
    #####:  727:    }
        -:  728:
    #####:  729:    if (fm->items[pos].type == DOUBLE) {
        -:  730:
    #####:  731:      valueDouble = (double)OP->value;
    #####:  732:    }
        -:  733:
    #####:  734:    if (fm->items[pos].type == FLOAT) {
        -:  735:
    #####:  736:      valueFloat = (float)OP->value;
    #####:  737:    }
        -:  738:
    #####:  739:    _FAQAS_mutated = 1;
    #####:  740:  }
        -:  741:
    #####:  742:  if (OP->type == SS) {
        -:  743:
    #####:  744:    if (fm->items[pos].type == INT) {
        -:  745:
    #####:  746:      int shift = OP->delta;
        -:  747:
    #####:  748:      valueInt = (int)valueInt + shift;
    #####:  749:    }
        -:  750:
    #####:  751:    if (fm->items[pos].type == DOUBLE) {
        -:  752:
    #####:  753:      double shift = OP->delta;
        -:  754:
    #####:  755:      valueDouble = (double)valueDouble + shift;
    #####:  756:    }
        -:  757:
    #####:  758:    if (fm->items[pos].type == FLOAT) {
        -:  759:
    #####:  760:      float shift = OP->delta;
        -:  761:
    #####:  762:      valueFloat = (float)valueFloat + shift;
    #####:  763:    }
        -:  764:
    #####:  765:    _FAQAS_mutated = 1;
    #####:  766:  }
        -:  767:
        -:  768:
    #####:  769:  if (OP->type == INV) {
        -:  770:
    #####:  771:    if (fm->items[pos].type == INT) {
        -:  772:
    #####:  773:      int upper = OP->max;
        -:  774:
    #####:  775:      int lower = OP->min;
        -:  776:
    #####:  777:      if (upper == lower) {
        -:  778:
    #####:  779:        valueInt = upper;
        -:  780:        // FIXME: throw a warning
    #####:  781:      }
        -:  782:
    #####:  783:      else if (upper < lower) {
        -:  784:        // FIXME: throw an error
    #####:  785:      }
        -:  786:
        -:  787:      else {
        -:  788:
    #####:  789:        int randomNum = valueInt;
        -:  790:
    #####:  791:        int avoidInfinite = 0;
        -:  792:
    #####:  793:        while (valueInt == randomNum) {
        -:  794:
    #####:  795:          randomNum = (rand() % (upper - lower + 1)) + lower;
        -:  796:
    #####:  797:          avoidInfinite = avoidInfinite + 1;
        -:  798:
    #####:  799:          if (avoidInfinite == 1000) {
        -:  800:
    #####:  801:            randomNum = upper;
        -:  802:
    #####:  803:            break;
        -:  804:          }
        -:  805:        }
        -:  806:
    #####:  807:        valueInt = randomNum;
        -:  808:      }
    #####:  809:    }
        -:  810:
    #####:  811:    if (fm->items[pos].type == DOUBLE) {
        -:  812:
    #####:  813:      double upper = OP->max;
        -:  814:
    #####:  815:      double lower = OP->min;
        -:  816:
    #####:  817:      if (upper == lower) {
        -:  818:
    #####:  819:        valueDouble = upper;
        -:  820:        // FIXME: throw a warning
    #####:  821:      }
        -:  822:
    #####:  823:      else if (upper < lower) {
        -:  824:        // FIXME: throw an error
    #####:  825:      }
        -:  826:
        -:  827:      else {
        -:  828:
    #####:  829:        double randomNum = valueDouble;
        -:  830:
    #####:  831:        int avoidInfinite = 0;
        -:  832:
    #####:  833:        while (valueDouble == randomNum) {
        -:  834:
    #####:  835:          randomNum = ((double)rand() * (upper - lower)) / RAND_MAX + lower;
        -:  836:
    #####:  837:          avoidInfinite = avoidInfinite + 1;
        -:  838:
    #####:  839:          if (avoidInfinite == 1000) {
        -:  840:
    #####:  841:            randomNum = upper;
        -:  842:
    #####:  843:            break;
        -:  844:          }
        -:  845:        }
        -:  846:
    #####:  847:        valueDouble = randomNum;
        -:  848:      }
    #####:  849:    }
        -:  850:
    #####:  851:    if (fm->items[pos].type == FLOAT) {
        -:  852:
    #####:  853:      float upper = OP->max;
        -:  854:
    #####:  855:      float lower = OP->min;
        -:  856:
    #####:  857:      if (upper == lower) {
        -:  858:
    #####:  859:        valueFloat = upper;
        -:  860:        // FIXME: throw a warning
    #####:  861:      }
        -:  862:
    #####:  863:      else if (upper < lower) {
        -:  864:        // FIXME: throw an error
    #####:  865:      }
        -:  866:
        -:  867:      else {
        -:  868:
    #####:  869:        float randomNum = valueFloat;
        -:  870:
    #####:  871:        int avoidInfinite = 0;
        -:  872:
    #####:  873:        while (valueFloat == randomNum) {
        -:  874:
    #####:  875:          randomNum = ((float)rand() * (upper - lower)) / RAND_MAX + lower;
        -:  876:
    #####:  877:          avoidInfinite = avoidInfinite + 1;
        -:  878:
    #####:  879:          if (avoidInfinite == 1000) {
        -:  880:
    #####:  881:            randomNum = upper;
        -:  882:
    #####:  883:            break;
        -:  884:          }
        -:  885:        }
        -:  886:
    #####:  887:        valueFloat = randomNum;
        -:  888:      }
    #####:  889:    }
        -:  890:
    #####:  891:    _FAQAS_mutated = 1;
    #####:  892:  }
        -:  893:
    #####:  894:  if (OP->type == ASA) {
        -:  895:
    #####:  896:    if (fm->items[pos].type == INT) {
        -:  897:
    #####:  898:      int Tr = OP->threshold;
        -:  899:
    #####:  900:      int De = OP->delta;
        -:  901:
    #####:  902:      int Va = OP->value;
        -:  903:
    #####:  904:      if (valueInt >= Tr) {
        -:  905:
    #####:  906:        valueInt = Tr + ((valueInt - Tr) * Va) + De;
    #####:  907:      }
        -:  908:
    #####:  909:      if (valueInt < Tr) {
        -:  910:
    #####:  911:        valueInt = Tr - ((valueInt - Tr) * Va) + De;
    #####:  912:      }
        -:  913:
    #####:  914:      _FAQAS_mutated = 1;
    #####:  915:    }
        -:  916:
    #####:  917:    if (fm->items[pos].type == DOUBLE) {
        -:  918:
    #####:  919:      double Tr = OP->threshold;
        -:  920:
    #####:  921:      double De = OP->delta;
        -:  922:
    #####:  923:      double Va = OP->value;
        -:  924:
    #####:  925:      if (valueDouble >= Tr) {
        -:  926:
    #####:  927:        valueDouble = Tr + ((valueDouble - Tr) * Va) + De;
    #####:  928:      }
        -:  929:
    #####:  930:      if (valueDouble < Tr) {
        -:  931:
    #####:  932:        valueDouble = Tr - ((valueDouble - Tr) * Va) + De;
    #####:  933:      }
        -:  934:
    #####:  935:      _FAQAS_mutated = 1;
    #####:  936:    }
        -:  937:
    #####:  938:    if (fm->items[pos].type == FLOAT) {
        -:  939:
    #####:  940:      float Tr = OP->threshold;
        -:  941:
    #####:  942:      float De = OP->delta;
        -:  943:
    #####:  944:      float Va = OP->value;
        -:  945:
    #####:  946:      if (valueFloat >= Tr) {
        -:  947:
    #####:  948:        valueFloat = Tr + ((valueFloat - Tr) * Va) + De;
    #####:  949:      }
        -:  950:
    #####:  951:      if (valueFloat < Tr) {
        -:  952:
    #####:  953:        valueFloat = Tr - ((valueFloat - Tr) * Va) + De;
    #####:  954:      }
        -:  955:
    #####:  956:      _FAQAS_mutated = 1;
    #####:  957:    }
    #####:  958:  }
        -:  959:
        -:  960:
        -:  961:
    #####:  962:  if (_FAQAS_mutated != 1) {
        -:  963:
    #####:  964:    return 0;
        -:  965:  }
        -:  966:
        -:  967:  // Store the data
        -:  968:  //
        -:  969:
        -:  970:  // if (span == 1) {
        -:  971:  //
        -:  972:  //   if (fm->items[pos].type == INT) {
        -:  973:  //     data[pos] = valueInt;
        -:  974:  //   }
        -:  975:  //   if (fm->items[pos].type == DOUBLE) {
        -:  976:  //     data[pos] = valueDouble;
        -:  977:  //   }
        -:  978:  //   if (fm->items[pos].type == BIN) {
        -:  979:  //     data[pos] = valueBin;
        -:  980:  //   }
        -:  981:  //   if (fm->items[pos].type == FLOAT) {
        -:  982:  //     data[pos] = valueFloat;
        -:  983:  //   }
        -:  984:  //
        -:  985:  // }
        -:  986:
        -:  987:  // else if (span != 1) {
        -:  988:
    #####:  989:  unsigned long long fullNumber = 0;
        -:  990:
    #####:  991:  switch (fm->items[pos].type) {
        -:  992:
        -:  993:  case BIN:
        -:  994:
    #####:  995:    memcpy(&fullNumber, &valueBin, sizeof(valueBin));
        -:  996:
    #####:  997:    break;
        -:  998:
        -:  999:  case INT:
        -: 1000:
    #####: 1001:    memcpy(&fullNumber, &valueInt, sizeof(valueInt));
        -: 1002:
    #####: 1003:    break;
        -: 1004:
        -: 1005:  case DOUBLE:
        -: 1006:
    #####: 1007:    memcpy(&fullNumber, &valueDouble, sizeof(valueDouble));
        -: 1008:
    #####: 1009:    break;
        -: 1010:
        -: 1011:  case FLOAT:
        -: 1012:
    #####: 1013:    memcpy(&fullNumber, &valueFloat, sizeof(valueFloat));
        -: 1014:
    #####: 1015:    break;
        -: 1016:
        -: 1017:  case LONG:
        -: 1018:
    #####: 1019:    break;
        -: 1020:  }
        -: 1021:
    #####: 1022:  int counter = 0;
        -: 1023:
    #####: 1024:  while (counter < span) {
        -: 1025:
    #####: 1026:    step = 8 * sizeof(data[pos + counter]);
        -: 1027:
    #####: 1028:    int startSlice = (span - counter - 1) * step;
        -: 1029:
    #####: 1030:    int endSlice = (span - counter) * step - 1;
        -: 1031:
    #####: 1032:    unsigned long long slice =
    #####: 1033:        _FAQAS_slice_it_up(fullNumber, startSlice, endSlice);
        -: 1034:
    #####: 1035:    memcpy(&data[pos + counter], &slice, sizeof(data[pos + counter]));
        -: 1036:
    #####: 1037:    counter = counter + 1;
        -: 1038:  }
        -: 1039:
        -: 1040:  // }
        -: 1041:  // else if closing bracket
        -: 1042:
    #####: 1043:  return _FAQAS_mutated;
       30: 1044:}
